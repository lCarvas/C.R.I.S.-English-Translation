import {
  d as Nt,
  Q as On,
  f as tt,
  a8 as Gi,
  o as Re,
  c as Pe,
  a as le,
  t as nr,
  C as vn,
  H as Rr,
  m as Fr,
  a1 as pr,
  p as Kt,
  b as en,
  _ as Mt,
  a9 as Xg,
  r as It,
  e as Is,
  w as Si,
  n as Ei,
  q as Rs,
  v as Pu,
  J as Hi,
  aa as Op,
  a3 as Yg,
  k as Ra,
  i as Qg,
  j as vi,
  x as qu,
  T as jg,
  a4 as Kg,
  ab as ey,
  L as Tt,
} from "./index-zHTPDNNN.js";
import { _ as Va } from "./d20-icon-vaz1En3o.js";
import { _ as Tp, a as ry } from "./edit-icon-3vZQUsyW.js";
import { S as ty, s as ny, c as Ci } from "./characterAutomations-VjVSWhq1.js";
import { c as gn, g as pa, a as ay } from "./_commonjsHelpers-4gQjN7DL.js";
import { c as iy, _ as Dp } from "./attributes-pd1IMHTT.js";
import { v as Ga } from "./v4-cyCr5FZV.js";
import { _ as oy } from "./show-more-icon-VvUXKiHG.js";
const sy = (e) => (Kt("data-v-36829786"), (e = e()), en(), e),
  uy = { class: "toast-content" },
  ly = ["src"],
  cy = { key: 1, class: "toast-icon", src: Va, alt: "d20" },
  fy = { class: "text" },
  my = { class: "title" },
  py = { class: "result" },
  vy = { class: "result-container" },
  hy = { key: 0 },
  dy = sy(() => le("span", null, "=", -1)),
  gy = { class: "total-container" },
  zu = "#5cb85c",
  Uu = "#d9534f",
  yy = "#fff",
  by = Nt({
    __name: "CampaignLogToastDice",
    props: { toast: {}, isPrivate: { type: Boolean } },
    setup(e) {
      On((n) => ({ d76afd42: a.value, "08a5de6e": t.value }));
      const r = e,
        t = tt(() => {
          let n = yy;
          if (r.toast.defaultColor || r.toast.title === "Result") return n;
          const i = r.toast.output
            .substring(
              r.toast.output.indexOf("[") + 1,
              r.toast.output.indexOf("]")
            )
            .split(",");
          if (i.length > 1)
            i.map((c) => {
              c.includes("d") ||
                (parseInt(c) === 20 && (n = zu), parseInt(c) === 1 && (n = Uu));
            });
          else {
            const c = r.toast.output.substring(
              r.toast.output.indexOf("[") + 1,
              r.toast.output.indexOf("]")
            );
            parseInt(c) === 20 && (n = zu), parseInt(c) === 1 && (n = Uu);
          }
          return n;
        }),
        a = tt(() =>
          r.toast.skinDice ? r.toast.skinDice.color : "var(--color-primary)"
        );
      return (n, i) => {
        const c = Gi("tooltip");
        return (
          Re(),
          Pe(
            "div",
            {
              class: pr([
                "toast",
                {
                  "private-roll": n.isPrivate,
                  "toast-border": n.toast.skinDice && n.toast.skinDice.isSolid,
                  "toast-img-border":
                    n.toast.skinDice && !n.toast.skinDice.isSolid,
                },
              ]),
            },
            [
              le("div", uy, [
                n.toast.skinDice
                  ? (Re(),
                    Pe(
                      "img",
                      {
                        key: 0,
                        class: "toast-icon",
                        src: n.toast.skinDice.img,
                        alt: "d20",
                      },
                      null,
                      8,
                      ly
                    ))
                  : (Re(), Pe("img", cy)),
                le("div", fy, [
                  le("h3", my, nr(n.toast.title), 1),
                  le("div", py, [
                    le("div", vy, [
                      vn((Re(), Pe("h4", null, [Rr(nr(n.toast.output), 1)])), [
                        [
                          c,
                          {
                            content: n.toast.output,
                            triggers: ["hover", "click"],
                          },
                        ],
                      ]),
                      n.toast.title === "Result"
                        ? vn(
                            (Re(), Pe("h4", hy, [Rr(nr(n.toast.notation), 1)])),
                            [
                              [
                                c,
                                {
                                  content: n.toast.notation,
                                  triggers: ["hover", "click"],
                                },
                              ],
                            ]
                          )
                        : Fr("", !0),
                    ]),
                    dy,
                    le("div", gy, [le("h3", null, nr(n.toast.total), 1)]),
                  ]),
                ]),
              ]),
            ],
            2
          )
        );
      };
    },
  }),
  xy = Mt(by, [["__scopeId", "data-v-36829786"]]),
  Fs = (e) => (Kt("data-v-f7cce5dc"), (e = e()), en(), e),
  wy = { class: "toast-content" },
  Ny = ["src"],
  My = { key: 1, class: "toast-icon", src: Va, alt: "d20" },
  Ay = { class: "text" },
  Sy = { class: "title" },
  Ey = { class: "result" },
  Cy = { class: "attack-container" },
  $y = Fs(() => le("h4", null, "TO HIT", -1)),
  Oy = Fs(() => le("div", { class: "divider" }, null, -1)),
  Ty = { class: "damage-container" },
  Dy = Fs(() => le("h4", { class: "padding-left" }, "DAMAGE", -1)),
  By = "#5cb85c",
  _y = "#d9534f",
  Iy = "#fff",
  Ry = Nt({
    __name: "CampaignLogToastAttack",
    props: { toast: {}, isPrivate: { type: Boolean } },
    setup(e) {
      On((n) => ({ "668da974": a.value, b0082db6: t.value }));
      const r = e,
        t = tt(() =>
          r.toast.critical === 1 ? By : r.toast.critical === -1 ? _y : Iy
        ),
        a = tt(() =>
          r.toast.skinDice ? r.toast.skinDice.color : "var(--color-primary)"
        );
      return (n, i) => {
        const c = Gi("tooltip");
        return (
          Re(),
          Pe(
            "div",
            {
              class: pr([
                "toast",
                {
                  "private-roll": n.isPrivate,
                  "toast-border": n.toast.skinDice && n.toast.skinDice.isSolid,
                  "toast-img-border":
                    n.toast.skinDice && !n.toast.skinDice.isSolid,
                },
              ]),
            },
            [
              le("div", wy, [
                n.toast.skinDice
                  ? (Re(),
                    Pe(
                      "img",
                      {
                        key: 0,
                        class: "toast-icon",
                        src: n.toast.skinDice.img,
                        alt: "d20",
                      },
                      null,
                      8,
                      Ny
                    ))
                  : (Re(), Pe("img", My)),
                le("div", Ay, [
                  le("h3", Sy, nr(n.toast.title), 1),
                  le("div", Ey, [
                    le("div", Cy, [
                      vn(
                        (Re(),
                        Pe("h3", null, [Rr(nr(n.toast.totalAttack), 1)])),
                        [
                          [
                            c,
                            {
                              content: `${n.toast.attackTooltip} = ${n.toast.attackRollTooltip}`,
                              triggers: ["hover", "click"],
                            },
                          ],
                        ]
                      ),
                      $y,
                    ]),
                    Oy,
                    le("div", Ty, [
                      vn(
                        (Re(),
                        Pe("h3", null, [Rr(nr(n.toast.totalDamage), 1)])),
                        [
                          [
                            c,
                            {
                              content: `${n.toast.damageTooltip} | ${n.toast.criticalTooltip} = ${n.toast.damageRollTooltip}`,
                              triggers: ["hover", "click"],
                            },
                          ],
                        ]
                      ),
                      Dy,
                    ]),
                  ]),
                ]),
              ]),
            ],
            2
          )
        );
      };
    },
  }),
  Fy = Mt(Ry, [["__scopeId", "data-v-f7cce5dc"]]),
  Ps = (e) => (Kt("data-v-8c49b71f"), (e = e()), en(), e),
  Py = { class: "campaign-log-content" },
  qy = { class: "header" },
  zy = Ps(() => le("div", { class: "title" }, " Results ", -1)),
  Uy = Ps(() =>
    le("img", { class: "close-icon", src: Hi, alt: "fechar" }, null, -1)
  ),
  Ly = [Uy],
  ky = Ps(() =>
    le("img", { class: "close-icon", src: Hi, alt: "fechar" }, null, -1)
  ),
  Vy = [ky],
  Gy = { class: "log-messages-container" },
  Hy = { class: "log-sender" },
  Zy = { class: "date" },
  Jy = Nt({
    __name: "CampaignLog",
    props: {
      campaignLog: {},
      masterScreen: { type: Boolean },
      isDm: { type: Boolean },
    },
    emits: ["handleCloseCampaignLog", "handleCleanCampaignLog"],
    setup(e) {
      On((f) => ({ ee9c0238: i.value, "1a2aa262": c.value }));
      const { height: r } = Xg(),
        t = e,
        a = It(null),
        n = (f) => {
          const u = new Date(f),
            s = u.getDate(),
            o = s < 10 ? `0${s}` : s.toString(),
            l = u.getMonth() + 1,
            p = l < 10 ? `0${l}` : l.toString(),
            v = u.getFullYear().toString().substring(2, 4),
            h = u.getHours(),
            x = h < 10 ? `0${h}` : h.toString(),
            b = u.getMinutes(),
            N = b < 10 ? `0${b}` : b.toString();
          return `${o}/${p}/${v} ${x}:${N}`;
        },
        i = tt(() => (t.masterScreen ? "52rem" : "55rem")),
        c = tt(() => `${r.value - 190}px`);
      Is(() => {
        var f;
        (f = a.value) == null || f.scrollIntoView();
      }),
        Si(
          () => t.campaignLog.campaignLogMessages,
          () => {
            var f;
            (f = a.value) == null || f.scrollIntoView({ behavior: "smooth" });
          }
        );
      const m = tt(() => {
        const f = [];
        for (const u of t.campaignLog.campaignLogMessages)
          t.isDm ? f.push(u) : u.isPrivate || f.push(u);
        return f;
      });
      return (f, u) => (
        Re(),
        Pe(
          "div",
          {
            class: pr([
              f.masterScreen
                ? "campaign-log-container-master-screen"
                : "campaign-log-container-sheet",
            ]),
          },
          [
            le("div", Py, [
              le("div", qy, [
                zy,
                f.masterScreen
                  ? Fr("", !0)
                  : (Re(),
                    Pe(
                      "button",
                      {
                        key: 0,
                        onClick:
                          u[0] ||
                          (u[0] = (s) => f.$emit("handleCloseCampaignLog")),
                      },
                      Ly
                    )),
                f.masterScreen && f.isDm
                  ? (Re(),
                    Pe(
                      "button",
                      {
                        key: 1,
                        onClick:
                          u[1] ||
                          (u[1] = (s) => f.$emit("handleCleanCampaignLog")),
                      },
                      Vy
                    ))
                  : Fr("", !0),
              ]),
              le("div", Gy, [
                (Re(!0),
                Pe(
                  Ei,
                  null,
                  Rs(
                    m.value,
                    (s, o) => (
                      Re(),
                      Pe("div", { key: o, class: "log-messages" }, [
                        le("div", Hy, nr(s.sender), 1),
                        s.contentType === "roll"
                          ? (Re(),
                            Pu(
                              xy,
                              {
                                key: 0,
                                toast: s.content,
                                "is-private": s.isPrivate,
                              },
                              null,
                              8,
                              ["toast", "is-private"]
                            ))
                          : Fr("", !0),
                        s.contentType === "attackRoll"
                          ? (Re(),
                            Pu(
                              Fy,
                              {
                                key: 1,
                                toast: s.content,
                                "is-private": s.isPrivate,
                              },
                              null,
                              8,
                              ["toast", "is-private"]
                            ))
                          : Fr("", !0),
                        le("div", Zy, nr(n(s.timestamp)), 1),
                      ])
                    )
                  ),
                  128
                )),
                le("div", { ref_key: "bottom", ref: a }, null, 512),
              ]),
            ]),
          ],
          2
        )
      );
    },
  }),
  Bq = Mt(Jy, [["__scopeId", "data-v-8c49b71f"]]),
  va = (e) => (Kt("data-v-05b4e714"), (e = e()), en(), e),
  Wy = { key: 1 },
  Xy = va(() => le("div", { class: "info-bar-fill" }, null, -1)),
  Yy = { key: 0, class: "buttons-container" },
  Qy = ["disabled"],
  jy = va(() =>
    le("img", { class: "invert-icon", src: Tp, alt: "diminuir" }, null, -1)
  ),
  Ky = [jy],
  e0 = ["disabled"],
  r0 = va(() =>
    le("img", { class: "invert-icon", src: Op, alt: "diminuir" }, null, -1)
  ),
  t0 = [r0],
  n0 = { class: "inputs-container" },
  a0 = ["disabled", "value"],
  i0 = ["disabled", "value"],
  o0 = { key: 1, class: "buttons-container" },
  s0 = ["disabled"],
  u0 = va(() => le("img", { src: Op, alt: "aumentar" }, null, -1)),
  l0 = [u0],
  c0 = ["disabled"],
  f0 = va(() => le("img", { src: Tp, alt: "aumentar" }, null, -1)),
  m0 = [f0],
  p0 = { key: 2 },
  v0 = va(() => le("div", { class: "info-bar-fill" }, null, -1)),
  h0 = ["onClick"],
  d0 = { key: 0, class: "heal-button-wrapper" },
  g0 = { class: "inputs-container" },
  y0 = ["disabled", "value"],
  b0 = ["disabled", "value"],
  x0 = Nt({
    __name: "InfoBar",
    props: {
      disabledSheet: { type: Boolean },
      type: {},
      maxValue: {},
      currentValue: {},
      marks: {},
      markMode: { type: Boolean },
      masterScreen: { type: Boolean },
      combatSheet: { type: Boolean },
    },
    emits: [
      "handleChangeCharNumber",
      "handleChangeCharNumberButton",
      "handleChangeCharMark",
      "handleChangeMarkModeToTrue",
      "handleMarkHeal",
    ],
    setup(e, { emit: r }) {
      On((u) => ({ "166941fd": c.value, 17804060: i.value }));
      const t = e,
        a = r,
        n = {
          pv: {
            labelBarMode: "HEALTH",
            labelMarkMode: "DYING",
            currentValue: "currentPv",
            maxValue: "maxPv",
            color: "#B22222",
            halfColor: "#621A1A",
          },
          san: {
            labelBarMode: "SANITY",
            labelMarkMode: "GOING INSANE",
            currentValue: "currentSan",
            maxValue: "maxSan",
            color: "#8A2BE2",
            halfColor: "#46295A",
          },
          pe: {
            labelBarMode: "EFFORT",
            currentValue: "currentPe",
            maxValue: "maxPe",
            color: "#F81",
            halfColor: "#BD6508",
          },
          pd: {
            labelBarMode: "DETERMINATION",
            currentValue: "currentPd",
            maxValue: "maxPd",
            color: "#0089A8",
            halfColor: "#016B83",
          },
        },
        i = tt(() => {
          const u = Math.floor((t.currentValue / t.maxValue) * 100);
          return u > 100 ? "100%" : u < 0 ? "0%" : `${u}%`;
        }),
        c = tt(() => {
          const u = Math.floor((t.currentValue / t.maxValue) * 100);
          if (t.type === "pv") {
            if (u <= 50) return n[t.type].halfColor;
          } else if (u < 50) return n[t.type].halfColor;
          return n[t.type].color;
        }),
        m = (u, s) => {
          a("handleChangeCharNumber", u, s);
        },
        f = (u, s) => {
          a("handleChangeCharNumberButton", u, s);
        };
      return (
        Si(
          () => t.currentValue,
          () => {
            t.type !== "pe" &&
              t.currentValue === 0 &&
              a("handleChangeMarkModeToTrue", t.type);
          }
        ),
        (u, s) => (
          Re(),
          Pe(
            "div",
            {
              class: pr([
                "info-bar-container",
                {
                  "master-info-bar-container": u.masterScreen || u.combatSheet,
                },
              ]),
            },
            [
              u.combatSheet
                ? Fr("", !0)
                : (Re(),
                  Pe(
                    "div",
                    {
                      key: 0,
                      class: pr([
                        "info-bar-label",
                        { "master-info-bar-label": u.masterScreen },
                      ]),
                    },
                    nr(n[u.type].labelBarMode),
                    3
                  )),
              u.markMode
                ? (Re(),
                  Pe("div", p0, [
                    le(
                      "div",
                      {
                        class: pr([
                          "info-bar",
                          { "master-info-bar": u.masterScreen },
                        ]),
                      },
                      [
                        v0,
                        le(
                          "div",
                          {
                            class: pr([
                              "info-bar-components",
                              {
                                "master-info-bar-components-mark":
                                  u.masterScreen,
                              },
                            ]),
                          },
                          [
                            le(
                              "div",
                              {
                                class: pr([
                                  "marks-container",
                                  { "master-marks-container": u.masterScreen },
                                ]),
                              },
                              [
                                (Re(!0),
                                Pe(
                                  Ei,
                                  null,
                                  Rs(
                                    u.marks,
                                    (o, l) => (
                                      Re(),
                                      Pe(
                                        "div",
                                        { key: l, class: "mark-container" },
                                        [
                                          le(
                                            "button",
                                            {
                                              class: pr([
                                                "mark-button button-naked",
                                                {
                                                  "master-mark-button":
                                                    u.masterScreen,
                                                },
                                              ]),
                                              onClick: () =>
                                                u.$emit(
                                                  "handleChangeCharMark",
                                                  u.type,
                                                  l
                                                ),
                                            },
                                            [
                                              le(
                                                "div",
                                                {
                                                  class: pr([
                                                    "mark-button-circle",
                                                    {
                                                      "master-mark-button-circle":
                                                        u.masterScreen,
                                                    },
                                                  ]),
                                                },
                                                [
                                                  le(
                                                    "div",
                                                    {
                                                      class: pr({
                                                        "mark-button-fill": o,
                                                        "master-mark-button-fill":
                                                          u.masterScreen,
                                                      }),
                                                    },
                                                    null,
                                                    2
                                                  ),
                                                ],
                                                2
                                              ),
                                            ],
                                            10,
                                            h0
                                          ),
                                        ]
                                      )
                                    )
                                  ),
                                  128
                                )),
                              ],
                              2
                            ),
                            u.masterScreen
                              ? Fr("", !0)
                              : (Re(),
                                Pe("div", d0, [
                                  le(
                                    "button",
                                    {
                                      class: "heal-button button-naked",
                                      onClick:
                                        s[6] ||
                                        (s[6] = () =>
                                          u.$emit("handleMarkHeal", u.type)),
                                    },
                                    " HEAL "
                                  ),
                                ])),
                            le("div", g0, [
                              le(
                                "input",
                                {
                                  type: "number",
                                  class: pr([
                                    "info-bar-input-mark left-input",
                                    { "master-info-bar-input": u.masterScreen },
                                  ]),
                                  disabled: u.disabledSheet,
                                  value: u.currentValue,
                                  onBlur:
                                    s[7] ||
                                    (s[7] = (o) =>
                                      m(o, n[u.type].currentValue)),
                                },
                                null,
                                42,
                                y0
                              ),
                              le(
                                "div",
                                {
                                  class: pr([
                                    "input-divider",
                                    { "master-input-divider": u.masterScreen },
                                  ]),
                                },
                                " / ",
                                2
                              ),
                              le(
                                "input",
                                {
                                  type: "number",
                                  class: pr([
                                    "info-bar-input-mark",
                                    { "master-info-bar-input": u.masterScreen },
                                  ]),
                                  disabled: u.disabledSheet,
                                  value: u.maxValue,
                                  onBlur:
                                    s[8] ||
                                    (s[8] = (o) => m(o, n[u.type].maxValue)),
                                },
                                null,
                                42,
                                b0
                              ),
                            ]),
                          ],
                          2
                        ),
                      ],
                      2
                    ),
                  ]))
                : (Re(),
                  Pe("div", Wy, [
                    le(
                      "div",
                      {
                        class: pr([
                          "info-bar",
                          { "master-info-bar": u.masterScreen },
                        ]),
                      },
                      [
                        Xy,
                        le(
                          "div",
                          {
                            class: pr([
                              "info-bar-components",
                              { "master-info-bar-components": u.masterScreen },
                            ]),
                          },
                          [
                            u.masterScreen
                              ? Fr("", !0)
                              : (Re(),
                                Pe("div", Yy, [
                                  le(
                                    "button",
                                    {
                                      class: "info-bar-button button-naked",
                                      disabled: u.disabledSheet,
                                      onClick:
                                        s[0] ||
                                        (s[0] = (o) =>
                                          f(
                                            u.currentValue - 5,
                                            n[u.type].currentValue
                                          )),
                                    },
                                    Ky,
                                    8,
                                    Qy
                                  ),
                                  le(
                                    "button",
                                    {
                                      class: "info-bar-button button-naked",
                                      disabled: u.disabledSheet,
                                      onClick:
                                        s[1] ||
                                        (s[1] = (o) =>
                                          f(
                                            u.currentValue - 1,
                                            n[u.type].currentValue
                                          )),
                                    },
                                    t0,
                                    8,
                                    e0
                                  ),
                                ])),
                            le("div", n0, [
                              le(
                                "input",
                                {
                                  type: "number",
                                  class: pr([
                                    "info-bar-input left-input",
                                    { "master-info-bar-input": u.masterScreen },
                                  ]),
                                  disabled: u.disabledSheet,
                                  value: u.currentValue,
                                  onBlur:
                                    s[2] ||
                                    (s[2] = (o) =>
                                      m(o, n[u.type].currentValue)),
                                },
                                null,
                                42,
                                a0
                              ),
                              le(
                                "div",
                                {
                                  class: pr([
                                    "input-divider",
                                    { "master-input-divider": u.masterScreen },
                                  ]),
                                },
                                " / ",
                                2
                              ),
                              le(
                                "input",
                                {
                                  type: "number",
                                  class: pr([
                                    "info-bar-input",
                                    { "master-info-bar-input": u.masterScreen },
                                  ]),
                                  disabled: u.disabledSheet,
                                  value: u.maxValue,
                                  onBlur:
                                    s[3] ||
                                    (s[3] = (o) => m(o, n[u.type].maxValue)),
                                },
                                null,
                                42,
                                i0
                              ),
                            ]),
                            u.masterScreen
                              ? Fr("", !0)
                              : (Re(),
                                Pe("div", o0, [
                                  le(
                                    "button",
                                    {
                                      class: "info-bar-button button-naked",
                                      disabled: u.disabledSheet,
                                      onClick:
                                        s[4] ||
                                        (s[4] = (o) =>
                                          f(
                                            u.currentValue + 1,
                                            n[u.type].currentValue
                                          )),
                                    },
                                    l0,
                                    8,
                                    s0
                                  ),
                                  le(
                                    "button",
                                    {
                                      class: "info-bar-button button-naked",
                                      disabled: u.disabledSheet,
                                      onClick:
                                        s[5] ||
                                        (s[5] = (o) =>
                                          f(
                                            u.currentValue + 5,
                                            n[u.type].currentValue
                                          )),
                                    },
                                    m0,
                                    8,
                                    c0
                                  ),
                                ])),
                          ],
                          2
                        ),
                      ],
                      2
                    ),
                  ])),
            ],
            2
          )
        )
      );
    },
  }),
  _q = Mt(x0, [["__scopeId", "data-v-05b4e714"]]);
function Lr() {
  return (
    (Lr = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = arguments[r];
            for (var a in t)
              Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
          }
          return e;
        }),
    Lr.apply(this, arguments)
  );
}
var Bp = {
  epsilon: 1e-12,
  matrix: "Matrix",
  number: "number",
  precision: 64,
  predictable: !1,
  randomSeed: null,
};
function je(e) {
  return typeof e == "number";
}
function Qe(e) {
  return !e || typeof e != "object" || typeof e.constructor != "function"
    ? !1
    : (e.isBigNumber === !0 &&
        typeof e.constructor.prototype == "object" &&
        e.constructor.prototype.isBigNumber === !0) ||
        (typeof e.constructor.isDecimal == "function" &&
          e.constructor.isDecimal(e) === !0);
}
function Wt(e) {
  return (
    (e && typeof e == "object" && Object.getPrototypeOf(e).isComplex === !0) ||
    !1
  );
}
function ha(e) {
  return (
    (e && typeof e == "object" && Object.getPrototypeOf(e).isFraction === !0) ||
    !1
  );
}
function Ha(e) {
  return (e && e.constructor.prototype.isUnit === !0) || !1;
}
function et(e) {
  return typeof e == "string";
}
var sr = Array.isArray;
function ze(e) {
  return (e && e.constructor.prototype.isMatrix === !0) || !1;
}
function da(e) {
  return Array.isArray(e) || ze(e);
}
function $i(e) {
  return (
    (e && e.isDenseMatrix && e.constructor.prototype.isMatrix === !0) || !1
  );
}
function An(e) {
  return (
    (e && e.isSparseMatrix && e.constructor.prototype.isMatrix === !0) || !1
  );
}
function Zi(e) {
  return (e && e.constructor.prototype.isRange === !0) || !1;
}
function Za(e) {
  return (e && e.constructor.prototype.isIndex === !0) || !1;
}
function w0(e) {
  return typeof e == "boolean";
}
function _p(e) {
  return (e && e.constructor.prototype.isResultSet === !0) || !1;
}
function qs(e) {
  return (e && e.constructor.prototype.isHelp === !0) || !1;
}
function N0(e) {
  return typeof e == "function";
}
function M0(e) {
  return e instanceof Date;
}
function A0(e) {
  return e instanceof RegExp;
}
function zs(e) {
  return !!(
    e &&
    typeof e == "object" &&
    e.constructor === Object &&
    !Wt(e) &&
    !ha(e)
  );
}
function S0(e) {
  return e === null;
}
function E0(e) {
  return e === void 0;
}
function En(e) {
  return (
    (e && e.isAccessorNode === !0 && e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function ut(e) {
  return (
    (e && e.isArrayNode === !0 && e.constructor.prototype.isNode === !0) || !1
  );
}
function C0(e) {
  return (
    (e && e.isAssignmentNode === !0 && e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function $0(e) {
  return (
    (e && e.isBlockNode === !0 && e.constructor.prototype.isNode === !0) || !1
  );
}
function O0(e) {
  return (
    (e &&
      e.isConditionalNode === !0 &&
      e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function lr(e) {
  return (
    (e && e.isConstantNode === !0 && e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Ja(e) {
  return (
    (e &&
      e.isFunctionAssignmentNode === !0 &&
      e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Cn(e) {
  return (
    (e && e.isFunctionNode === !0 && e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function ga(e) {
  return (
    (e && e.isIndexNode === !0 && e.constructor.prototype.isNode === !0) || !1
  );
}
function ir(e) {
  return (e && e.isNode === !0 && e.constructor.prototype.isNode === !0) || !1;
}
function Ji(e) {
  return (
    (e && e.isObjectNode === !0 && e.constructor.prototype.isNode === !0) || !1
  );
}
function Kr(e) {
  return (
    (e && e.isOperatorNode === !0 && e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Wa(e) {
  return (
    (e &&
      e.isParenthesisNode === !0 &&
      e.constructor.prototype.isNode === !0) ||
    !1
  );
}
function T0(e) {
  return (
    (e && e.isRangeNode === !0 && e.constructor.prototype.isNode === !0) || !1
  );
}
function qr(e) {
  return (
    (e && e.isSymbolNode === !0 && e.constructor.prototype.isNode === !0) || !1
  );
}
function Us(e) {
  return (e && e.constructor.prototype.isChain === !0) || !1;
}
function vr(e) {
  var r = typeof e;
  return r === "object"
    ? e === null
      ? "null"
      : Array.isArray(e)
      ? "Array"
      : e instanceof Date
      ? "Date"
      : e instanceof RegExp
      ? "RegExp"
      : Qe(e)
      ? "BigNumber"
      : Wt(e)
      ? "Complex"
      : ha(e)
      ? "Fraction"
      : ze(e)
      ? "Matrix"
      : Ha(e)
      ? "Unit"
      : Za(e)
      ? "Index"
      : Zi(e)
      ? "Range"
      : _p(e)
      ? "ResultSet"
      : ir(e)
      ? e.type
      : Us(e)
      ? "Chain"
      : qs(e)
      ? "Help"
      : "Object"
    : r === "function"
    ? "Function"
    : r;
}
function Fe(e) {
  var r = typeof e;
  if (
    r === "number" ||
    r === "string" ||
    r === "boolean" ||
    e === null ||
    e === void 0
  )
    return e;
  if (typeof e.clone == "function") return e.clone();
  if (Array.isArray(e))
    return e.map(function (t) {
      return Fe(t);
    });
  if (e instanceof Date) return new Date(e.valueOf());
  if (Qe(e)) return e;
  if (e instanceof RegExp) throw new TypeError("Cannot clone " + e);
  return D0(e, Fe);
}
function D0(e, r) {
  var t = {};
  for (var a in e) De(e, a) && (t[a] = r(e[a]));
  return t;
}
function Ls(e, r) {
  for (var t in r) De(r, t) && (e[t] = r[t]);
  return e;
}
function Pa(e, r) {
  var t, a, n;
  if (Array.isArray(e)) {
    if (!Array.isArray(r) || e.length !== r.length) return !1;
    for (a = 0, n = e.length; a < n; a++) if (!Pa(e[a], r[a])) return !1;
    return !0;
  } else {
    if (typeof e == "function") return e === r;
    if (e instanceof Object) {
      if (Array.isArray(r) || !(r instanceof Object)) return !1;
      for (t in e) if (!(t in r) || !Pa(e[t], r[t])) return !1;
      for (t in r) if (!(t in e)) return !1;
      return !0;
    } else return e === r;
  }
}
function B0(e, r, t) {
  var a = !0,
    n;
  Object.defineProperty(e, r, {
    get: function () {
      return a && ((n = t()), (a = !1)), n;
    },
    set: function (c) {
      (n = c), (a = !1);
    },
    configurable: !0,
    enumerable: !0,
  });
}
function De(e, r) {
  return e && Object.hasOwnProperty.call(e, r);
}
function _0(e, r) {
  for (var t = {}, a = 0; a < r.length; a++) {
    var n = r[a],
      i = e[n];
    i !== void 0 && (t[n] = i);
  }
  return t;
}
var I0 = ["Matrix", "Array"],
  R0 = ["number", "BigNumber", "Fraction"],
  fe = function (r) {
    if (r)
      throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);
    return Object.freeze(Bp);
  };
Lr(fe, Bp, { MATRIX_OPTIONS: I0, NUMBER_OPTIONS: R0 });
var Ip = { exports: {} };
(function (e, r) {
  (function (t, a) {
    e.exports = a();
  })(gn, function () {
    function t() {
      return !0;
    }
    function a() {
      return !1;
    }
    function n() {}
    function i() {
      var c = [
          {
            name: "number",
            test: function (F) {
              return typeof F == "number";
            },
          },
          {
            name: "string",
            test: function (F) {
              return typeof F == "string";
            },
          },
          {
            name: "boolean",
            test: function (F) {
              return typeof F == "boolean";
            },
          },
          {
            name: "Function",
            test: function (F) {
              return typeof F == "function";
            },
          },
          { name: "Array", test: Array.isArray },
          {
            name: "Date",
            test: function (F) {
              return F instanceof Date;
            },
          },
          {
            name: "RegExp",
            test: function (F) {
              return F instanceof RegExp;
            },
          },
          {
            name: "Object",
            test: function (F) {
              return (
                typeof F == "object" && F !== null && F.constructor === Object
              );
            },
          },
          {
            name: "null",
            test: function (F) {
              return F === null;
            },
          },
          {
            name: "undefined",
            test: function (F) {
              return F === void 0;
            },
          },
        ],
        m = { name: "any", test: t },
        f = [],
        u = [],
        s = { types: c, conversions: u, ignore: f };
      function o(F) {
        var U = q(s.types, function (k) {
          return k.name === F;
        });
        if (U) return U;
        if (F === "any") return m;
        var ee = q(s.types, function (k) {
          return k.name.toLowerCase() === F.toLowerCase();
        });
        throw new TypeError(
          'Unknown type "' +
            F +
            '"' +
            (ee ? '. Did you mean "' + ee.name + '"?' : "")
        );
      }
      function l(F) {
        return F === m ? 999 : s.types.indexOf(F);
      }
      function p(F) {
        var U = q(s.types, function (ee) {
          return ee.test(F);
        });
        if (U) return U.name;
        throw new TypeError("Value has unknown type. Value: " + F);
      }
      function v(F, U) {
        if (!F.signatures) throw new TypeError("Function is no typed-function");
        var ee;
        if (typeof U == "string") {
          ee = U.split(",");
          for (var k = 0; k < ee.length; k++) ee[k] = ee[k].trim();
        } else if (Array.isArray(U)) ee = U;
        else
          throw new TypeError(
            "String array or a comma separated string expected"
          );
        var me = ee.join(","),
          he = F.signatures[me];
        if (he) return he;
        throw new TypeError(
          "Signature not found (signature: " +
            (F.name || "unnamed") +
            "(" +
            ee.join(", ") +
            "))"
        );
      }
      function h(F, U) {
        var ee = p(F);
        if (U === ee) return F;
        for (var k = 0; k < s.conversions.length; k++) {
          var me = s.conversions[k];
          if (me.from === ee && me.to === U) return me.convert(F);
        }
        throw new Error("Cannot convert from " + ee + " to " + U);
      }
      function x(F) {
        return F.map(function (U) {
          var ee = U.types.map(E);
          return (U.restParam ? "..." : "") + ee.join("|");
        }).join(",");
      }
      function b(F, U) {
        var ee = F.indexOf("...") === 0,
          k = ee ? (F.length > 3 ? F.slice(3) : "any") : F,
          me = k.split("|").map(ae).filter(ce).filter(oe),
          he = D(U, me),
          Me = me.map(function (xe) {
            var Te = o(xe);
            return {
              name: xe,
              typeIndex: l(Te),
              test: Te.test,
              conversion: null,
              conversionIndex: -1,
            };
          }),
          be = he.map(function (xe) {
            var Te = o(xe.from);
            return {
              name: xe.from,
              typeIndex: l(Te),
              test: Te.test,
              conversion: xe,
              conversionIndex: U.indexOf(xe),
            };
          });
        return { types: Me.concat(be), restParam: ee };
      }
      function N(F, U, ee) {
        var k = [];
        return (
          F.trim() !== "" &&
            (k = F.split(",")
              .map(ae)
              .map(function (me, he, Me) {
                var be = b(me, ee);
                if (be.restParam && he !== Me.length - 1)
                  throw new SyntaxError(
                    'Unexpected rest parameter "' +
                      me +
                      '": only allowed for the last parameter'
                  );
                return be;
              })),
          k.some(pe) ? null : { params: k, fn: U }
        );
      }
      function d(F) {
        var U = Ae(F);
        return U ? U.restParam : !1;
      }
      function y(F) {
        return F.types.some(function (U) {
          return U.conversion != null;
        });
      }
      function w(F) {
        if (!F || F.types.length === 0) return t;
        if (F.types.length === 1) return o(F.types[0].name).test;
        if (F.types.length === 2) {
          var U = o(F.types[0].name).test,
            ee = o(F.types[1].name).test;
          return function (he) {
            return U(he) || ee(he);
          };
        } else {
          var k = F.types.map(function (me) {
            return o(me.name).test;
          });
          return function (he) {
            for (var Me = 0; Me < k.length; Me++) if (k[Me](he)) return !0;
            return !1;
          };
        }
      }
      function g(F) {
        var U, ee, k;
        if (d(F)) {
          U = ne(F).map(w);
          var me = U.length,
            he = w(Ae(F)),
            Me = function (be) {
              for (var xe = me; xe < be.length; xe++)
                if (!he(be[xe])) return !1;
              return !0;
            };
          return function (xe) {
            for (var Te = 0; Te < U.length; Te++) if (!U[Te](xe[Te])) return !1;
            return Me(xe) && xe.length >= me + 1;
          };
        } else
          return F.length === 0
            ? function (xe) {
                return xe.length === 0;
              }
            : F.length === 1
            ? ((ee = w(F[0])),
              function (xe) {
                return ee(xe[0]) && xe.length === 1;
              })
            : F.length === 2
            ? ((ee = w(F[0])),
              (k = w(F[1])),
              function (xe) {
                return ee(xe[0]) && k(xe[1]) && xe.length === 2;
              })
            : ((U = F.map(w)),
              function (xe) {
                for (var Te = 0; Te < U.length; Te++)
                  if (!U[Te](xe[Te])) return !1;
                return xe.length === U.length;
              });
      }
      function S(F, U) {
        return U < F.params.length
          ? F.params[U]
          : d(F.params)
          ? Ae(F.params)
          : null;
      }
      function A(F, U, ee) {
        var k = S(F, U),
          me = k ? (ee ? k.types.filter(M) : k.types) : [];
        return me.map(E);
      }
      function E(F) {
        return F.name;
      }
      function M(F) {
        return F.conversion === null || F.conversion === void 0;
      }
      function B(F, U) {
        var ee = Y(
          V(F, function (k) {
            return A(k, U, !1);
          })
        );
        return ee.indexOf("any") !== -1 ? ["any"] : ee;
      }
      function C(F, U, ee) {
        var k,
          me,
          he = F || "unnamed",
          Me = ee,
          be;
        for (be = 0; be < U.length; be++) {
          var xe = Me.filter(function (mr) {
            var Jr = w(S(mr, be));
            return (be < mr.params.length || d(mr.params)) && Jr(U[be]);
          });
          if (xe.length === 0) {
            if (((me = B(Me, be)), me.length > 0)) {
              var Te = p(U[be]);
              return (
                (k = new TypeError(
                  "Unexpected type of argument in function " +
                    he +
                    " (expected: " +
                    me.join(" or ") +
                    ", actual: " +
                    Te +
                    ", index: " +
                    be +
                    ")"
                )),
                (k.data = {
                  category: "wrongType",
                  fn: he,
                  index: be,
                  actual: Te,
                  expected: me,
                }),
                k
              );
            }
          } else Me = xe;
        }
        var or = Me.map(function (mr) {
          return d(mr.params) ? 1 / 0 : mr.params.length;
        });
        if (U.length < Math.min.apply(null, or))
          return (
            (me = B(Me, be)),
            (k = new TypeError(
              "Too few arguments in function " +
                he +
                " (expected: " +
                me.join(" or ") +
                ", index: " +
                U.length +
                ")"
            )),
            (k.data = {
              category: "tooFewArgs",
              fn: he,
              index: U.length,
              expected: me,
            }),
            k
          );
        var br = Math.max.apply(null, or);
        return U.length > br
          ? ((k = new TypeError(
              "Too many arguments in function " +
                he +
                " (expected: " +
                br +
                ", actual: " +
                U.length +
                ")"
            )),
            (k.data = {
              category: "tooManyArgs",
              fn: he,
              index: U.length,
              expectedLength: br,
            }),
            k)
          : ((k = new TypeError(
              'Arguments of type "' +
                U.join(", ") +
                '" do not match any of the defined signatures of function ' +
                he +
                "."
            )),
            (k.data = { category: "mismatch", actual: U.map(p) }),
            k);
      }
      function _(F) {
        for (var U = 999, ee = 0; ee < F.types.length; ee++)
          M(F.types[ee]) && (U = Math.min(U, F.types[ee].typeIndex));
        return U;
      }
      function z(F) {
        for (var U = 999, ee = 0; ee < F.types.length; ee++)
          M(F.types[ee]) || (U = Math.min(U, F.types[ee].conversionIndex));
        return U;
      }
      function I(F, U) {
        var ee;
        return (
          (ee = F.restParam - U.restParam),
          ee !== 0 ||
          ((ee = y(F) - y(U)), ee !== 0) ||
          ((ee = _(F) - _(U)), ee !== 0)
            ? ee
            : z(F) - z(U)
        );
      }
      function T(F, U) {
        var ee = Math.min(F.params.length, U.params.length),
          k,
          me;
        if (((me = F.params.some(y) - U.params.some(y)), me !== 0)) return me;
        for (k = 0; k < ee; k++)
          if (((me = y(F.params[k]) - y(U.params[k])), me !== 0)) return me;
        for (k = 0; k < ee; k++)
          if (((me = I(F.params[k], U.params[k])), me !== 0)) return me;
        return F.params.length - U.params.length;
      }
      function D(F, U) {
        var ee = {};
        return (
          F.forEach(function (k) {
            U.indexOf(k.from) === -1 &&
              U.indexOf(k.to) !== -1 &&
              !ee[k.from] &&
              (ee[k.from] = k);
          }),
          Object.keys(ee).map(function (k) {
            return ee[k];
          })
        );
      }
      function Z(F, U) {
        var ee = U;
        if (F.some(y)) {
          var k = d(F),
            me = F.map(O);
          ee = function () {
            for (
              var xe = [],
                Te = k ? arguments.length - 1 : arguments.length,
                or = 0;
              or < Te;
              or++
            )
              xe[or] = me[or](arguments[or]);
            return k && (xe[Te] = arguments[Te].map(me[Te])), U.apply(this, xe);
          };
        }
        var he = ee;
        if (d(F)) {
          var Me = F.length - 1;
          he = function () {
            return ee.apply(
              this,
              Ce(arguments, 0, Me).concat([Ce(arguments, Me)])
            );
          };
        }
        return he;
      }
      function O(F) {
        var U,
          ee,
          k,
          me,
          he = [],
          Me = [];
        switch (
          (F.types.forEach(function (be) {
            be.conversion &&
              (he.push(o(be.conversion.from).test),
              Me.push(be.conversion.convert));
          }),
          Me.length)
        ) {
          case 0:
            return function (xe) {
              return xe;
            };
          case 1:
            return (
              (U = he[0]),
              (k = Me[0]),
              function (xe) {
                return U(xe) ? k(xe) : xe;
              }
            );
          case 2:
            return (
              (U = he[0]),
              (ee = he[1]),
              (k = Me[0]),
              (me = Me[1]),
              function (xe) {
                return U(xe) ? k(xe) : ee(xe) ? me(xe) : xe;
              }
            );
          default:
            return function (xe) {
              for (var Te = 0; Te < Me.length; Te++)
                if (he[Te](xe)) return Me[Te](xe);
              return xe;
            };
        }
      }
      function H(F) {
        var U = {};
        return (
          F.forEach(function (ee) {
            ee.params.some(y) ||
              Q(ee.params, !0).forEach(function (k) {
                U[x(k)] = ee.fn;
              });
          }),
          U
        );
      }
      function Q(F, U) {
        function ee(k, me, he) {
          if (me < k.length) {
            var Me = k[me],
              be = U ? Me.types.filter(M) : Me.types,
              xe;
            if (Me.restParam) {
              var Te = be.filter(M);
              xe = Te.length < be.length ? [Te, be] : [be];
            } else
              xe = be.map(function (br) {
                return [br];
              });
            return V(xe, function (br) {
              return ee(k, me + 1, he.concat([br]));
            });
          } else {
            var or = he.map(function (br, mr) {
              return { types: br, restParam: mr === k.length - 1 && d(k) };
            });
            return [or];
          }
        }
        return ee(F, 0, []);
      }
      function te(F, U) {
        for (
          var ee = Math.max(F.params.length, U.params.length), k = 0;
          k < ee;
          k++
        ) {
          var me = A(F, k, !0),
            he = A(U, k, !0);
          if (!Se(me, he)) return !1;
        }
        var Me = F.params.length,
          be = U.params.length,
          xe = d(F.params),
          Te = d(U.params);
        return xe ? (Te ? Me === be : be >= Me) : Te ? Me >= be : Me === be;
      }
      function J(F, U) {
        if (Object.keys(U).length === 0)
          throw new SyntaxError("No signatures provided");
        var ee = [];
        Object.keys(U)
          .map(function (dr) {
            return N(dr, U[dr], s.conversions);
          })
          .filter(se)
          .forEach(function (dr) {
            var _r = q(ee, function (st) {
              return te(st, dr);
            });
            if (_r)
              throw new TypeError(
                'Conflicting signatures "' +
                  x(_r.params) +
                  '" and "' +
                  x(dr.params) +
                  '".'
              );
            ee.push(dr);
          });
        var k = V(ee, function (dr) {
          var _r = dr ? Q(dr.params, !1) : [];
          return _r.map(function (st) {
            return { params: st, fn: dr.fn };
          });
        }).filter(se);
        k.sort(T);
        var me = k[0] && k[0].params.length <= 2 && !d(k[0].params),
          he = k[1] && k[1].params.length <= 2 && !d(k[1].params),
          Me = k[2] && k[2].params.length <= 2 && !d(k[2].params),
          be = k[3] && k[3].params.length <= 2 && !d(k[3].params),
          xe = k[4] && k[4].params.length <= 2 && !d(k[4].params),
          Te = k[5] && k[5].params.length <= 2 && !d(k[5].params),
          or = me && he && Me && be && xe && Te,
          br = k.map(function (dr) {
            return g(dr.params);
          }),
          mr = me ? w(k[0].params[0]) : a,
          Jr = he ? w(k[1].params[0]) : a,
          Wr = Me ? w(k[2].params[0]) : a,
          ot = be ? w(k[3].params[0]) : a,
          rr = xe ? w(k[4].params[0]) : a,
          $t = Te ? w(k[5].params[0]) : a,
          $ = me ? w(k[0].params[1]) : a,
          X = he ? w(k[1].params[1]) : a,
          ue = Me ? w(k[2].params[1]) : a,
          we = be ? w(k[3].params[1]) : a,
          ke = xe ? w(k[4].params[1]) : a,
          Ye = Te ? w(k[5].params[1]) : a,
          Or = k.map(function (dr) {
            return Z(dr.params, dr.fn);
          }),
          Ca = me ? Or[0] : n,
          wo = he ? Or[1] : n,
          No = Me ? Or[2] : n,
          Mo = be ? Or[3] : n,
          Ao = xe ? Or[4] : n,
          So = Te ? Or[5] : n,
          kn = me ? k[0].params.length : -1,
          Vn = he ? k[1].params.length : -1,
          Eo = Me ? k[2].params.length : -1,
          Co = be ? k[3].params.length : -1,
          $o = xe ? k[4].params.length : -1,
          Oo = Te ? k[5].params.length : -1,
          To = or ? 6 : 0,
          Do = k.length,
          Bo = function () {
            for (var _r = To; _r < Do; _r++)
              if (br[_r](arguments)) return Or[_r].apply(this, arguments);
            return s.onMismatch(F, arguments, k);
          },
          $a = function dr(_r, st) {
            return arguments.length === kn && mr(_r) && $(st)
              ? Ca.apply(dr, arguments)
              : arguments.length === Vn && Jr(_r) && X(st)
              ? wo.apply(dr, arguments)
              : arguments.length === Eo && Wr(_r) && ue(st)
              ? No.apply(dr, arguments)
              : arguments.length === Co && ot(_r) && we(st)
              ? Mo.apply(dr, arguments)
              : arguments.length === $o && rr(_r) && ke(st)
              ? Ao.apply(dr, arguments)
              : arguments.length === Oo && $t(_r) && Ye(st)
              ? So.apply(dr, arguments)
              : Bo.apply(dr, arguments);
          };
        try {
          Object.defineProperty($a, "name", { value: F });
        } catch {}
        return ($a.signatures = H(k)), $a;
      }
      function re(F, U, ee) {
        throw C(F, U, ee);
      }
      function oe(F) {
        return s.ignore.indexOf(F) === -1;
      }
      function ae(F) {
        return F.trim();
      }
      function ce(F) {
        return !!F;
      }
      function se(F) {
        return F !== null;
      }
      function pe(F) {
        return F.types.length === 0;
      }
      function ne(F) {
        return F.slice(0, F.length - 1);
      }
      function Ae(F) {
        return F[F.length - 1];
      }
      function Ce(F, U, ee) {
        return Array.prototype.slice.call(F, U, ee);
      }
      function ge(F, U) {
        return F.indexOf(U) !== -1;
      }
      function Se(F, U) {
        for (var ee = 0; ee < F.length; ee++) if (ge(U, F[ee])) return !0;
        return !1;
      }
      function q(F, U) {
        for (var ee = 0; ee < F.length; ee++) if (U(F[ee])) return F[ee];
      }
      function Y(F) {
        for (var U = {}, ee = 0; ee < F.length; ee++) U[F[ee]] = !0;
        return Object.keys(U);
      }
      function V(F, U) {
        return Array.prototype.concat.apply([], F.map(U));
      }
      function L(F) {
        for (var U = "", ee = 0; ee < F.length; ee++) {
          var k = F[ee];
          if (
            (typeof k.signatures == "object" ||
              typeof k.signature == "string") &&
            k.name !== ""
          ) {
            if (U === "") U = k.name;
            else if (U !== k.name) {
              var me = new Error(
                "Function names do not match (expected: " +
                  U +
                  ", actual: " +
                  k.name +
                  ")"
              );
              throw ((me.data = { actual: k.name, expected: U }), me);
            }
          }
        }
        return U;
      }
      function j(F) {
        var U,
          ee = {};
        function k(be, xe) {
          if (ee.hasOwnProperty(be) && xe !== ee[be])
            throw (
              ((U = new Error('Signature "' + be + '" is defined twice')),
              (U.data = { signature: be }),
              U)
            );
        }
        for (var me = 0; me < F.length; me++) {
          var he = F[me];
          if (typeof he.signatures == "object")
            for (var Me in he.signatures)
              he.signatures.hasOwnProperty(Me) &&
                (k(Me, he.signatures[Me]), (ee[Me] = he.signatures[Me]));
          else if (typeof he.signature == "string")
            k(he.signature, he), (ee[he.signature] = he);
          else
            throw (
              ((U = new TypeError(
                "Function is no typed-function (index: " + me + ")"
              )),
              (U.data = { index: me }),
              U)
            );
        }
        return ee;
      }
      return (
        (s = J("typed", {
          "string, Object": J,
          Object: function (F) {
            var U = [];
            for (var ee in F) F.hasOwnProperty(ee) && U.push(F[ee]);
            var k = L(U);
            return J(k, F);
          },
          "...Function": function (F) {
            return J(L(F), j(F));
          },
          "string, ...Function": function (F, U) {
            return J(F, j(U));
          },
        })),
        (s.create = i),
        (s.types = c),
        (s.conversions = u),
        (s.ignore = f),
        (s.onMismatch = re),
        (s.throwMismatchError = re),
        (s.createError = C),
        (s.convert = h),
        (s.find = v),
        (s.addType = function (F, U) {
          if (!F || typeof F.name != "string" || typeof F.test != "function")
            throw new TypeError(
              "Object with properties {name: string, test: function} expected"
            );
          if (U !== !1) {
            for (var ee = 0; ee < s.types.length; ee++)
              if (s.types[ee].name === "Object") {
                s.types.splice(ee, 0, F);
                return;
              }
          }
          s.types.push(F);
        }),
        (s.addConversion = function (F) {
          if (
            !F ||
            typeof F.from != "string" ||
            typeof F.to != "string" ||
            typeof F.convert != "function"
          )
            throw new TypeError(
              "Object with properties {from: string, to: string, convert: function} expected"
            );
          s.conversions.push(F);
        }),
        s
      );
    }
    return i();
  });
})(Ip);
var F0 = Ip.exports;
const Lu = pa(F0);
function Be(e) {
  return typeof e == "boolean" ? !0 : isFinite(e) ? e === Math.round(e) : !1;
}
var mn =
    Math.sign ||
    function (e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    },
  P0 =
    Math.log2 ||
    function (r) {
      return Math.log(r) / Math.LN2;
    },
  q0 =
    Math.log10 ||
    function (r) {
      return Math.log(r) / Math.LN10;
    },
  z0 =
    Math.log1p ||
    function (e) {
      return Math.log(e + 1);
    },
  U0 =
    Math.cbrt ||
    function (r) {
      if (r === 0) return r;
      var t = r < 0,
        a;
      return (
        t && (r = -r),
        isFinite(r)
          ? ((a = Math.exp(Math.log(r) / 3)), (a = (r / (a * a) + 2 * a) / 3))
          : (a = r),
        t ? -a : a
      );
    },
  L0 =
    Math.expm1 ||
    function (r) {
      return r >= 2e-4 || r <= -2e-4
        ? Math.exp(r) - 1
        : r + (r * r) / 2 + (r * r * r) / 6;
    };
function Po(e, r, t) {
  var a = { 2: "0b", 8: "0o", 16: "0x" },
    n = a[r],
    i = "";
  if (t) {
    if (t < 1) throw new Error("size must be in greater than 0");
    if (!Be(t)) throw new Error("size must be an integer");
    if (e > 2 ** (t - 1) - 1 || e < -(2 ** (t - 1)))
      throw new Error(
        "Value must be in range [-2^".concat(t - 1, ", 2^").concat(t - 1, "-1]")
      );
    if (!Be(e)) throw new Error("Value must be an integer");
    e < 0 && (e = e + 2 ** t), (i = "i".concat(t));
  }
  var c = "";
  return (
    e < 0 && ((e = -e), (c = "-")),
    "".concat(c).concat(n).concat(e.toString(r)).concat(i)
  );
}
function Sn(e, r) {
  if (typeof r == "function") return r(e);
  if (e === 1 / 0) return "Infinity";
  if (e === -1 / 0) return "-Infinity";
  if (isNaN(e)) return "NaN";
  var t = "auto",
    a,
    n;
  if (
    r &&
    (r.notation && (t = r.notation),
    je(r) ? (a = r) : je(r.precision) && (a = r.precision),
    r.wordSize && ((n = r.wordSize), typeof n != "number"))
  )
    throw new Error('Option "wordSize" must be a number');
  switch (t) {
    case "fixed":
      return Rp(e, a);
    case "exponential":
      return Fp(e, a);
    case "engineering":
      return k0(e, a);
    case "bin":
      return Po(e, 2, n);
    case "oct":
      return Po(e, 8, n);
    case "hex":
      return Po(e, 16, n);
    case "auto":
      return V0(e, a, r && r).replace(/((\.\d*?)(0+))($|e)/, function () {
        var i = arguments[2],
          c = arguments[4];
        return i !== "." ? i + c : c;
      });
    default:
      throw new Error(
        'Unknown notation "' +
          t +
          '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.'
      );
  }
}
function Wi(e) {
  var r = String(e)
    .toLowerCase()
    .match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!r) throw new SyntaxError("Invalid number " + e);
  var t = r[1],
    a = r[2],
    n = parseFloat(r[4] || "0"),
    i = a.indexOf(".");
  n += i !== -1 ? i - 1 : a.length - 1;
  var c = a
    .replace(".", "")
    .replace(/^0*/, function (m) {
      return (n -= m.length), "";
    })
    .replace(/0*$/, "")
    .split("")
    .map(function (m) {
      return parseInt(m);
    });
  return (
    c.length === 0 && (c.push(0), n++),
    { sign: t, coefficients: c, exponent: n }
  );
}
function k0(e, r) {
  if (isNaN(e) || !isFinite(e)) return String(e);
  var t = Wi(e),
    a = Xi(t, r),
    n = a.exponent,
    i = a.coefficients,
    c = n % 3 === 0 ? n : n < 0 ? n - 3 - (n % 3) : n - (n % 3);
  if (je(r)) for (; r > i.length || n - c + 1 > i.length; ) i.push(0);
  else
    for (var m = Math.abs(n - c) - (i.length - 1), f = 0; f < m; f++) i.push(0);
  for (var u = Math.abs(n - c), s = 1; u > 0; ) s++, u--;
  var o = i.slice(s).join(""),
    l = (je(r) && o.length) || o.match(/[1-9]/) ? "." + o : "",
    p = i.slice(0, s).join("") + l + "e" + (n >= 0 ? "+" : "") + c.toString();
  return a.sign + p;
}
function Rp(e, r) {
  if (isNaN(e) || !isFinite(e)) return String(e);
  var t = Wi(e),
    a = typeof r == "number" ? Xi(t, t.exponent + 1 + r) : t,
    n = a.coefficients,
    i = a.exponent + 1,
    c = i + (r || 0);
  return (
    n.length < c && (n = n.concat(ta(c - n.length))),
    i < 0 && ((n = ta(-i + 1).concat(n)), (i = 1)),
    i < n.length && n.splice(i, 0, i === 0 ? "0." : "."),
    a.sign + n.join("")
  );
}
function Fp(e, r) {
  if (isNaN(e) || !isFinite(e)) return String(e);
  var t = Wi(e),
    a = r ? Xi(t, r) : t,
    n = a.coefficients,
    i = a.exponent;
  n.length < r && (n = n.concat(ta(r - n.length)));
  var c = n.shift();
  return (
    a.sign +
    c +
    (n.length > 0 ? "." + n.join("") : "") +
    "e" +
    (i >= 0 ? "+" : "") +
    i
  );
}
function V0(e, r, t) {
  if (isNaN(e) || !isFinite(e)) return String(e);
  var a = t && t.lowerExp !== void 0 ? t.lowerExp : -3,
    n = t && t.upperExp !== void 0 ? t.upperExp : 5,
    i = Wi(e),
    c = r ? Xi(i, r) : i;
  if (c.exponent < a || c.exponent >= n) return Fp(e, r);
  var m = c.coefficients,
    f = c.exponent;
  m.length < r && (m = m.concat(ta(r - m.length))),
    (m = m.concat(ta(f - m.length + 1 + (m.length < r ? r - m.length : 0)))),
    (m = ta(-f).concat(m));
  var u = f > 0 ? f : 0;
  return u < m.length - 1 && m.splice(u + 1, 0, "."), c.sign + m.join("");
}
function Xi(e, r) {
  for (
    var t = {
        sign: e.sign,
        coefficients: e.coefficients,
        exponent: e.exponent,
      },
      a = t.coefficients;
    r <= 0;

  )
    a.unshift(0), t.exponent++, r++;
  if (a.length > r) {
    var n = a.splice(r, a.length - r);
    if (n[0] >= 5) {
      var i = r - 1;
      for (a[i]++; a[i] === 10; )
        a.pop(), i === 0 && (a.unshift(0), t.exponent++, i++), i--, a[i]++;
    }
  }
  return t;
}
function ta(e) {
  for (var r = [], t = 0; t < e; t++) r.push(0);
  return r;
}
function G0(e) {
  return e
    .toExponential()
    .replace(/e.*$/, "")
    .replace(/^0\.?0*|\./, "").length;
}
var H0 = Number.EPSILON || 2220446049250313e-31;
function nt(e, r, t) {
  if (t == null) return e === r;
  if (e === r) return !0;
  if (isNaN(e) || isNaN(r)) return !1;
  if (isFinite(e) && isFinite(r)) {
    var a = Math.abs(e - r);
    return a < H0 ? !0 : a <= Math.max(Math.abs(e), Math.abs(r)) * t;
  }
  return !1;
}
var Z0 =
    Math.acosh ||
    function (e) {
      return Math.log(Math.sqrt(e * e - 1) + e);
    },
  J0 =
    Math.asinh ||
    function (e) {
      return Math.log(Math.sqrt(e * e + 1) + e);
    },
  W0 =
    Math.atanh ||
    function (e) {
      return Math.log((1 + e) / (1 - e)) / 2;
    },
  X0 =
    Math.cosh ||
    function (e) {
      return (Math.exp(e) + Math.exp(-e)) / 2;
    },
  Y0 =
    Math.sinh ||
    function (e) {
      return (Math.exp(e) - Math.exp(-e)) / 2;
    },
  Q0 =
    Math.tanh ||
    function (e) {
      var r = Math.exp(2 * e);
      return (r - 1) / (r + 1);
    };
function j0(e, r) {
  var t = e > 0 ? !0 : e < 0 ? !1 : 1 / e === 1 / 0,
    a = r > 0 ? !0 : r < 0 ? !1 : 1 / r === 1 / 0;
  return t ^ a ? -e : e;
}
function qo(e, r, t) {
  var a = e.constructor,
    n = new a(2),
    i = "";
  if (t) {
    if (t < 1) throw new Error("size must be in greater than 0");
    if (!Be(t)) throw new Error("size must be an integer");
    if (e.greaterThan(n.pow(t - 1).sub(1)) || e.lessThan(n.pow(t - 1).mul(-1)))
      throw new Error(
        "Value must be in range [-2^".concat(t - 1, ", 2^").concat(t - 1, "-1]")
      );
    if (!e.isInteger()) throw new Error("Value must be an integer");
    e.lessThan(0) && (e = e.add(n.pow(t))), (i = "i".concat(t));
  }
  switch (r) {
    case 2:
      return "".concat(e.toBinary()).concat(i);
    case 8:
      return "".concat(e.toOctal()).concat(i);
    case 16:
      return "".concat(e.toHexadecimal()).concat(i);
    default:
      throw new Error("Base ".concat(r, " not supported "));
  }
}
function K0(e, r) {
  if (typeof r == "function") return r(e);
  if (!e.isFinite())
    return e.isNaN() ? "NaN" : e.gt(0) ? "Infinity" : "-Infinity";
  var t = "auto",
    a,
    n;
  if (
    r !== void 0 &&
    (r.notation && (t = r.notation),
    typeof r == "number" ? (a = r) : r.precision && (a = r.precision),
    r.wordSize && ((n = r.wordSize), typeof n != "number"))
  )
    throw new Error('Option "wordSize" must be a number');
  switch (t) {
    case "fixed":
      return r1(e, a);
    case "exponential":
      return ku(e, a);
    case "engineering":
      return e1(e, a);
    case "bin":
      return qo(e, 2, n);
    case "oct":
      return qo(e, 8, n);
    case "hex":
      return qo(e, 16, n);
    case "auto": {
      var i = r && r.lowerExp !== void 0 ? r.lowerExp : -3,
        c = r && r.upperExp !== void 0 ? r.upperExp : 5;
      if (e.isZero()) return "0";
      var m,
        f = e.toSignificantDigits(a),
        u = f.e;
      return (
        u >= i && u < c ? (m = f.toFixed()) : (m = ku(e, a)),
        m.replace(/((\.\d*?)(0+))($|e)/, function () {
          var s = arguments[2],
            o = arguments[4];
          return s !== "." ? s + o : o;
        })
      );
    }
    default:
      throw new Error(
        'Unknown notation "' +
          t +
          '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.'
      );
  }
}
function e1(e, r) {
  var t = e.e,
    a = t % 3 === 0 ? t : t < 0 ? t - 3 - (t % 3) : t - (t % 3),
    n = e.mul(Math.pow(10, -a)),
    i = n.toPrecision(r);
  return (
    i.indexOf("e") !== -1 && (i = n.toString()),
    i + "e" + (t >= 0 ? "+" : "") + a.toString()
  );
}
function ku(e, r) {
  return r !== void 0 ? e.toExponential(r - 1) : e.toExponential();
}
function r1(e, r) {
  return e.toFixed(r);
}
function t1(e, r) {
  var t = e.length - r.length,
    a = e.length;
  return e.substring(t, a) === r;
}
function Ze(e, r) {
  var t = n1(e, r);
  return r && typeof r == "object" && "truncate" in r && t.length > r.truncate
    ? t.substring(0, r.truncate - 3) + "..."
    : t;
}
function n1(e, r) {
  if (typeof e == "number") return Sn(e, r);
  if (Qe(e)) return K0(e, r);
  if (a1(e))
    return !r || r.fraction !== "decimal"
      ? e.s * e.n + "/" + e.d
      : e.toString();
  if (Array.isArray(e)) return Pp(e, r);
  if (et(e)) return '"' + e + '"';
  if (typeof e == "function") return e.syntax ? String(e.syntax) : "function";
  if (e && typeof e == "object") {
    if (typeof e.format == "function") return e.format(r);
    if (e && e.toString(r) !== {}.toString()) return e.toString(r);
    var t = Object.keys(e).map((a) => '"' + a + '": ' + Ze(e[a], r));
    return "{" + t.join(", ") + "}";
  }
  return String(e);
}
function hi(e) {
  for (var r = String(e), t = "", a = 0; a < r.length; ) {
    var n = r.charAt(a);
    n === "\\"
      ? ((t += n),
        a++,
        (n = r.charAt(a)),
        (n === "" || '"\\/bfnrtu'.indexOf(n) === -1) && (t += "\\"),
        (t += n))
      : n === '"'
      ? (t += '\\"')
      : (t += n),
      a++;
  }
  return '"' + t + '"';
}
function lt(e) {
  var r = String(e);
  return (
    (r = r
      .replace(/&/g, "&amp;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")),
    r
  );
}
function Pp(e, r) {
  if (Array.isArray(e)) {
    for (var t = "[", a = e.length, n = 0; n < a; n++)
      n !== 0 && (t += ", "), (t += Pp(e[n], r));
    return (t += "]"), t;
  } else return Ze(e, r);
}
function a1(e) {
  return (
    (e &&
      typeof e == "object" &&
      typeof e.s == "number" &&
      typeof e.n == "number" &&
      typeof e.d == "number") ||
    !1
  );
}
function Jn(e, r) {
  if (!et(e))
    throw new TypeError(
      "Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " +
        vr(e) +
        ", index: 0)"
    );
  if (!et(r))
    throw new TypeError(
      "Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " +
        vr(r) +
        ", index: 1)"
    );
  return e === r ? 0 : e > r ? 1 : -1;
}
function Je(e, r, t) {
  if (!(this instanceof Je))
    throw new SyntaxError("Constructor must be called with the new operator");
  (this.actual = e),
    (this.expected = r),
    (this.relation = t),
    (this.message =
      "Dimension mismatch (" +
      (Array.isArray(e) ? "[" + e.join(", ") + "]" : e) +
      " " +
      (this.relation || "!=") +
      " " +
      (Array.isArray(r) ? "[" + r.join(", ") + "]" : r) +
      ")"),
    (this.stack = new Error().stack);
}
Je.prototype = new RangeError();
Je.prototype.constructor = RangeError;
Je.prototype.name = "DimensionError";
Je.prototype.isDimensionError = !0;
function At(e, r, t) {
  if (!(this instanceof At))
    throw new SyntaxError("Constructor must be called with the new operator");
  (this.index = e),
    arguments.length < 3
      ? ((this.min = 0), (this.max = r))
      : ((this.min = r), (this.max = t)),
    this.min !== void 0 && this.index < this.min
      ? (this.message =
          "Index out of range (" + this.index + " < " + this.min + ")")
      : this.max !== void 0 && this.index >= this.max
      ? (this.message =
          "Index out of range (" + this.index + " > " + (this.max - 1) + ")")
      : (this.message = "Index out of range (" + this.index + ")"),
    (this.stack = new Error().stack);
}
At.prototype = new RangeError();
At.prototype.constructor = RangeError;
At.prototype.name = "IndexError";
At.prototype.isIndexError = !0;
function Xe(e) {
  for (var r = []; Array.isArray(e); ) r.push(e.length), (e = e[0]);
  return r;
}
function qp(e, r, t) {
  var a,
    n = e.length;
  if (n !== r[t]) throw new Je(n, r[t]);
  if (t < r.length - 1) {
    var i = t + 1;
    for (a = 0; a < n; a++) {
      var c = e[a];
      if (!Array.isArray(c)) throw new Je(r.length - 1, r.length, "<");
      qp(e[a], r, i);
    }
  } else
    for (a = 0; a < n; a++)
      if (Array.isArray(e[a])) throw new Je(r.length + 1, r.length, ">");
}
function Vu(e, r) {
  var t = r.length === 0;
  if (t) {
    if (Array.isArray(e)) throw new Je(e.length, 0);
  } else qp(e, r, 0);
}
function cr(e, r) {
  if (!je(e) || !Be(e))
    throw new TypeError("Index must be an integer (value: " + e + ")");
  if (e < 0 || (typeof r == "number" && e >= r)) throw new At(e, r);
}
function oa(e, r, t) {
  if (!Array.isArray(e) || !Array.isArray(r))
    throw new TypeError("Array expected");
  if (r.length === 0) throw new Error("Resizing to scalar is not supported");
  r.forEach(function (n) {
    if (!je(n) || !Be(n) || n < 0)
      throw new TypeError(
        "Invalid size, must contain positive integers (size: " + Ze(r) + ")"
      );
  });
  var a = t !== void 0 ? t : 0;
  return ms(e, r, 0, a), e;
}
function ms(e, r, t, a) {
  var n,
    i,
    c = e.length,
    m = r[t],
    f = Math.min(c, m);
  if (((e.length = m), t < r.length - 1)) {
    var u = t + 1;
    for (n = 0; n < f; n++)
      (i = e[n]), Array.isArray(i) || ((i = [i]), (e[n] = i)), ms(i, r, u, a);
    for (n = f; n < m; n++) (i = []), (e[n] = i), ms(i, r, u, a);
  } else {
    for (n = 0; n < f; n++) for (; Array.isArray(e[n]); ) e[n] = e[n][0];
    for (n = f; n < m; n++) e[n] = a;
  }
}
function zp(e, r) {
  var t = Ke(e),
    a = t.length;
  if (!Array.isArray(e) || !Array.isArray(r))
    throw new TypeError("Array expected");
  if (r.length === 0) throw new Je(0, a, "!=");
  r = ks(r, a);
  var n = Up(r);
  if (a !== n) throw new Je(n, a, "!=");
  try {
    return i1(t, r);
  } catch (i) {
    throw i instanceof Je ? new Je(n, a, "!=") : i;
  }
}
function ks(e, r) {
  var t = Up(e),
    a = e.slice(),
    n = -1,
    i = e.indexOf(n),
    c = e.indexOf(n, i + 1) >= 0;
  if (c) throw new Error("More than one wildcard in sizes");
  var m = i >= 0,
    f = r % t === 0;
  if (m)
    if (f) a[i] = -r / t;
    else
      throw new Error(
        "Could not replace wildcard, since " + r + " is no multiple of " + -t
      );
  return a;
}
function Up(e) {
  return e.reduce((r, t) => r * t, 1);
}
function i1(e, r) {
  for (var t = e, a, n = r.length - 1; n > 0; n--) {
    var i = r[n];
    a = [];
    for (var c = t.length / i, m = 0; m < c; m++)
      a.push(t.slice(m * i, (m + 1) * i));
    t = a;
  }
  return t;
}
function Oi(e, r) {
  for (var t = r || Xe(e); Array.isArray(e) && e.length === 1; )
    (e = e[0]), t.shift();
  for (var a = t.length; t[a - 1] === 1; ) a--;
  return a < t.length && ((e = Lp(e, a, 0)), (t.length = a)), e;
}
function Lp(e, r, t) {
  var a, n;
  if (t < r) {
    var i = t + 1;
    for (a = 0, n = e.length; a < n; a++) e[a] = Lp(e[a], r, i);
  } else for (; Array.isArray(e); ) e = e[0];
  return e;
}
function kp(e, r, t, a) {
  var n = a || Xe(e);
  if (t) for (var i = 0; i < t; i++) (e = [e]), n.unshift(1);
  for (e = Vp(e, r, 0); n.length < r; ) n.push(1);
  return e;
}
function Vp(e, r, t) {
  var a, n;
  if (Array.isArray(e)) {
    var i = t + 1;
    for (a = 0, n = e.length; a < n; a++) e[a] = Vp(e[a], r, i);
  } else for (var c = t; c < r; c++) e = [e];
  return e;
}
function Ke(e) {
  if (!Array.isArray(e)) return e;
  var r = [];
  return (
    e.forEach(function t(a) {
      Array.isArray(a) ? a.forEach(t) : r.push(a);
    }),
    r
  );
}
function Xt(e, r) {
  return Array.prototype.map.call(e, r);
}
function Yi(e, r) {
  Array.prototype.forEach.call(e, r);
}
function Gp(e, r) {
  if (Xe(e).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(e, r);
}
function Ti(e, r) {
  if (Xe(e).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(e, (t) => r.test(t));
}
function Gu(e, r) {
  return Array.prototype.join.call(e, r);
}
function sa(e) {
  if (!Array.isArray(e)) throw new TypeError("Array input expected");
  if (e.length === 0) return e;
  var r = [],
    t = 0;
  r[0] = { value: e[0], identifier: 0 };
  for (var a = 1; a < e.length; a++)
    e[a] === e[a - 1] ? t++ : (t = 0), r.push({ value: e[a], identifier: t });
  return r;
}
function Di(e) {
  if (!Array.isArray(e)) throw new TypeError("Array input expected");
  if (e.length === 0) return e;
  for (var r = [], t = 0; t < e.length; t++) r.push(e[t].value);
  return r;
}
function qa(e, r) {
  for (var t, a = 0, n = 0; n < e.length; n++) {
    var i = e[n],
      c = Array.isArray(i);
    if ((n === 0 && c && (a = i.length), c && i.length !== a)) return;
    var m = c ? qa(i, r) : r(i);
    if (t === void 0) t = m;
    else if (t !== m) return "mixed";
  }
  return t;
}
function P(e, r, t, a) {
  function n(i) {
    var c = _0(i, r.map(u1));
    return o1(e, r, i), t(c);
  }
  return (
    (n.isFactory = !0),
    (n.fn = e),
    (n.dependencies = r.slice().sort()),
    a && (n.meta = a),
    n
  );
}
function o1(e, r, t) {
  var a = r.filter((i) => !s1(i)).every((i) => t[i] !== void 0);
  if (!a) {
    var n = r.filter((i) => t[i] === void 0);
    throw new Error(
      'Cannot create function "'.concat(e, '", ') +
        "some dependencies are missing: ".concat(
          n.map((i) => '"'.concat(i, '"')).join(", "),
          "."
        )
    );
  }
}
function s1(e) {
  return e && e[0] === "?";
}
function u1(e) {
  return e && e[0] === "?" ? e.slice(1) : e;
}
function ct(e, r) {
  if (Hp(e) && Vs(e, r)) return e[r];
  throw typeof e[r] == "function" && Gs(e, r)
    ? new Error('Cannot access method "' + r + '" as a property')
    : new Error('No access to property "' + r + '"');
}
function ua(e, r, t) {
  if (Hp(e) && Vs(e, r)) return (e[r] = t), t;
  throw new Error('No access to property "' + r + '"');
}
function l1(e, r) {
  return r in e;
}
function Vs(e, r) {
  return !e || typeof e != "object"
    ? !1
    : De(f1, r)
    ? !0
    : !(r in Object.prototype || r in Function.prototype);
}
function c1(e, r) {
  if (!Gs(e, r)) throw new Error('No access to method "' + r + '"');
}
function Gs(e, r) {
  return e == null ||
    typeof e[r] != "function" ||
    (De(e, r) && Object.getPrototypeOf && r in Object.getPrototypeOf(e))
    ? !1
    : De(m1, r)
    ? !0
    : !(r in Object.prototype || r in Function.prototype);
}
function Hp(e) {
  return typeof e == "object" && e && e.constructor === Object;
}
var f1 = { length: !0, name: !0 },
  m1 = { toString: !0, valueOf: !0, toLocaleString: !0 };
class Hs {
  constructor(r) {
    this.wrappedObject = r;
  }
  keys() {
    return Object.keys(this.wrappedObject);
  }
  get(r) {
    return ct(this.wrappedObject, r);
  }
  set(r, t) {
    return ua(this.wrappedObject, r, t), this;
  }
  has(r) {
    return l1(this.wrappedObject, r);
  }
}
function Gt() {
  return new Map();
}
function Zs(e) {
  if (!e) return Gt();
  if (Qi(e)) return e;
  if (zs(e)) return new Hs(e);
  throw new Error("createMap can create maps from objects or Maps");
}
function p1(e) {
  if (e instanceof Hs) return e.wrappedObject;
  var r = {};
  for (var t of e.keys()) {
    var a = e.get(t);
    ua(r, t, a);
  }
  return r;
}
function Qi(e) {
  return e
    ? e instanceof Map ||
        e instanceof Hs ||
        (typeof e.set == "function" &&
          typeof e.get == "function" &&
          typeof e.keys == "function" &&
          typeof e.has == "function")
    : !1;
}
function Hu(e) {
  for (
    var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), a = 1;
    a < r;
    a++
  )
    t[a - 1] = arguments[a];
  for (var n of t)
    if (n) {
      if (Qi(n)) for (var i of n.keys()) e.set(i, n.get(i));
      else if (zs(n)) for (var c of Object.keys(n)) e.set(c, n[c]);
    }
  return e;
}
var Zp = function () {
    return (Zp = Lu.create), Lu;
  },
  v1 = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"],
  h1 = P("typed", v1, function (r) {
    var { BigNumber: t, Complex: a, DenseMatrix: n, Fraction: i } = r,
      c = Zp();
    return (
      (c.types = [
        { name: "number", test: je },
        { name: "Complex", test: Wt },
        { name: "BigNumber", test: Qe },
        { name: "Fraction", test: ha },
        { name: "Unit", test: Ha },
        { name: "string", test: et },
        { name: "Chain", test: Us },
        { name: "Array", test: sr },
        { name: "Matrix", test: ze },
        { name: "DenseMatrix", test: $i },
        { name: "SparseMatrix", test: An },
        { name: "Range", test: Zi },
        { name: "Index", test: Za },
        { name: "boolean", test: w0 },
        { name: "ResultSet", test: _p },
        { name: "Help", test: qs },
        { name: "function", test: N0 },
        { name: "Date", test: M0 },
        { name: "RegExp", test: A0 },
        { name: "null", test: S0 },
        { name: "undefined", test: E0 },
        { name: "AccessorNode", test: En },
        { name: "ArrayNode", test: ut },
        { name: "AssignmentNode", test: C0 },
        { name: "BlockNode", test: $0 },
        { name: "ConditionalNode", test: O0 },
        { name: "ConstantNode", test: lr },
        { name: "FunctionNode", test: Cn },
        { name: "FunctionAssignmentNode", test: Ja },
        { name: "IndexNode", test: ga },
        { name: "Node", test: ir },
        { name: "ObjectNode", test: Ji },
        { name: "OperatorNode", test: Kr },
        { name: "ParenthesisNode", test: Wa },
        { name: "RangeNode", test: T0 },
        { name: "SymbolNode", test: qr },
        { name: "Map", test: Qi },
        { name: "Object", test: zs },
      ]),
      (c.conversions = [
        {
          from: "number",
          to: "BigNumber",
          convert: function (f) {
            if ((t || zo(f), G0(f) > 15))
              throw new TypeError(
                "Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " +
                  f +
                  "). Use function bignumber(x) to convert to BigNumber."
              );
            return new t(f);
          },
        },
        {
          from: "number",
          to: "Complex",
          convert: function (f) {
            return a || di(f), new a(f, 0);
          },
        },
        {
          from: "number",
          to: "string",
          convert: function (f) {
            return f + "";
          },
        },
        {
          from: "BigNumber",
          to: "Complex",
          convert: function (f) {
            return a || di(f), new a(f.toNumber(), 0);
          },
        },
        {
          from: "Fraction",
          to: "BigNumber",
          convert: function (f) {
            throw new TypeError(
              "Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction."
            );
          },
        },
        {
          from: "Fraction",
          to: "Complex",
          convert: function (f) {
            return a || di(f), new a(f.valueOf(), 0);
          },
        },
        {
          from: "number",
          to: "Fraction",
          convert: function (f) {
            i || Uo(f);
            var u = new i(f);
            if (u.valueOf() !== f)
              throw new TypeError(
                "Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " +
                  f +
                  "). Use function fraction(x) to convert to Fraction."
              );
            return u;
          },
        },
        {
          from: "string",
          to: "number",
          convert: function (f) {
            var u = Number(f);
            if (isNaN(u))
              throw new Error('Cannot convert "' + f + '" to a number');
            return u;
          },
        },
        {
          from: "string",
          to: "BigNumber",
          convert: function (f) {
            t || zo(f);
            try {
              return new t(f);
            } catch {
              throw new Error('Cannot convert "' + f + '" to BigNumber');
            }
          },
        },
        {
          from: "string",
          to: "Fraction",
          convert: function (f) {
            i || Uo(f);
            try {
              return new i(f);
            } catch {
              throw new Error('Cannot convert "' + f + '" to Fraction');
            }
          },
        },
        {
          from: "string",
          to: "Complex",
          convert: function (f) {
            a || di(f);
            try {
              return new a(f);
            } catch {
              throw new Error('Cannot convert "' + f + '" to Complex');
            }
          },
        },
        {
          from: "boolean",
          to: "number",
          convert: function (f) {
            return +f;
          },
        },
        {
          from: "boolean",
          to: "BigNumber",
          convert: function (f) {
            return t || zo(f), new t(+f);
          },
        },
        {
          from: "boolean",
          to: "Fraction",
          convert: function (f) {
            return i || Uo(f), new i(+f);
          },
        },
        {
          from: "boolean",
          to: "string",
          convert: function (f) {
            return String(f);
          },
        },
        {
          from: "Array",
          to: "Matrix",
          convert: function (f) {
            return n || d1(), new n(f);
          },
        },
        {
          from: "Matrix",
          to: "Array",
          convert: function (f) {
            return f.valueOf();
          },
        },
      ]),
      c
    );
  });
function zo(e) {
  throw new Error(
    "Cannot convert value ".concat(
      e,
      " into a BigNumber: no class 'BigNumber' provided"
    )
  );
}
function di(e) {
  throw new Error(
    "Cannot convert value ".concat(
      e,
      " into a Complex number: no class 'Complex' provided"
    )
  );
}
function d1() {
  throw new Error(
    "Cannot convert array into a Matrix: no class 'DenseMatrix' provided"
  );
}
function Uo(e) {
  throw new Error(
    "Cannot convert value ".concat(
      e,
      " into a Fraction, no class 'Fraction' provided."
    )
  );
}
var g1 = "ResultSet",
  y1 = [],
  b1 = P(
    g1,
    y1,
    () => {
      function e(r) {
        if (!(this instanceof e))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        this.entries = r || [];
      }
      return (
        (e.prototype.type = "ResultSet"),
        (e.prototype.isResultSet = !0),
        (e.prototype.valueOf = function () {
          return this.entries;
        }),
        (e.prototype.toString = function () {
          return "[" + this.entries.join(", ") + "]";
        }),
        (e.prototype.toJSON = function () {
          return { mathjs: "ResultSet", entries: this.entries };
        }),
        (e.fromJSON = function (r) {
          return new e(r.entries);
        }),
        e
      );
    },
    { isClass: !0 }
  );
/*!
 *  decimal.js v10.4.1
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */ var ra = 9e15,
  yn = 1e9,
  ps = "0123456789abcdef",
  Bi =
    "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
  _i =
    "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
  vs = {
    precision: 20,
    rounding: 4,
    modulo: 1,
    toExpNeg: -7,
    toExpPos: 21,
    minE: -ra,
    maxE: ra,
    crypto: !1,
  },
  Jp,
  Ht,
  Ve = !0,
  ji = "[DecimalError] ",
  hn = ji + "Invalid argument: ",
  Wp = ji + "Precision limit exceeded",
  Xp = ji + "crypto unavailable",
  Yp = "[object Decimal]",
  Vr = Math.floor,
  Br = Math.pow,
  x1 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
  w1 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
  N1 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
  Qp = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
  bt = 1e7,
  qe = 7,
  M1 = 9007199254740991,
  A1 = Bi.length - 1,
  hs = _i.length - 1,
  ve = { toStringTag: Yp };
ve.absoluteValue = ve.abs = function () {
  var e = new this.constructor(this);
  return e.s < 0 && (e.s = 1), Ie(e);
};
ve.ceil = function () {
  return Ie(new this.constructor(this), this.e + 1, 2);
};
ve.clampedTo = ve.clamp = function (e, r) {
  var t,
    a = this,
    n = a.constructor;
  if (((e = new n(e)), (r = new n(r)), !e.s || !r.s)) return new n(NaN);
  if (e.gt(r)) throw Error(hn + r);
  return (t = a.cmp(e)), t < 0 ? e : a.cmp(r) > 0 ? r : new n(a);
};
ve.comparedTo = ve.cmp = function (e) {
  var r,
    t,
    a,
    n,
    i = this,
    c = i.d,
    m = (e = new i.constructor(e)).d,
    f = i.s,
    u = e.s;
  if (!c || !m)
    return !f || !u ? NaN : f !== u ? f : c === m ? 0 : !c ^ (f < 0) ? 1 : -1;
  if (!c[0] || !m[0]) return c[0] ? f : m[0] ? -u : 0;
  if (f !== u) return f;
  if (i.e !== e.e) return (i.e > e.e) ^ (f < 0) ? 1 : -1;
  for (a = c.length, n = m.length, r = 0, t = a < n ? a : n; r < t; ++r)
    if (c[r] !== m[r]) return (c[r] > m[r]) ^ (f < 0) ? 1 : -1;
  return a === n ? 0 : (a > n) ^ (f < 0) ? 1 : -1;
};
ve.cosine = ve.cos = function () {
  var e,
    r,
    t = this,
    a = t.constructor;
  return t.d
    ? t.d[0]
      ? ((e = a.precision),
        (r = a.rounding),
        (a.precision = e + Math.max(t.e, t.sd()) + qe),
        (a.rounding = 1),
        (t = S1(a, tv(a, t))),
        (a.precision = e),
        (a.rounding = r),
        Ie(Ht == 2 || Ht == 3 ? t.neg() : t, e, r, !0))
      : new a(1)
    : new a(NaN);
};
ve.cubeRoot = ve.cbrt = function () {
  var e,
    r,
    t,
    a,
    n,
    i,
    c,
    m,
    f,
    u,
    s = this,
    o = s.constructor;
  if (!s.isFinite() || s.isZero()) return new o(s);
  for (
    Ve = !1,
      i = s.s * Br(s.s * s, 1 / 3),
      !i || Math.abs(i) == 1 / 0
        ? ((t = zr(s.d)),
          (e = s.e),
          (i = (e - t.length + 1) % 3) && (t += i == 1 || i == -2 ? "0" : "00"),
          (i = Br(t, 1 / 3)),
          (e = Vr((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2))),
          i == 1 / 0
            ? (t = "5e" + e)
            : ((t = i.toExponential()),
              (t = t.slice(0, t.indexOf("e") + 1) + e)),
          (a = new o(t)),
          (a.s = s.s))
        : (a = new o(i.toString())),
      c = (e = o.precision) + 3;
    ;

  )
    if (
      ((m = a),
      (f = m.times(m).times(m)),
      (u = f.plus(s)),
      (a = yr(u.plus(s).times(m), u.plus(f), c + 2, 1)),
      zr(m.d).slice(0, c) === (t = zr(a.d)).slice(0, c))
    )
      if (((t = t.slice(c - 3, c + 1)), t == "9999" || (!n && t == "4999"))) {
        if (!n && (Ie(m, e + 1, 0), m.times(m).times(m).eq(s))) {
          a = m;
          break;
        }
        (c += 4), (n = 1);
      } else {
        (!+t || (!+t.slice(1) && t.charAt(0) == "5")) &&
          (Ie(a, e + 1, 1), (r = !a.times(a).times(a).eq(s)));
        break;
      }
  return (Ve = !0), Ie(a, e, o.rounding, r);
};
ve.decimalPlaces = ve.dp = function () {
  var e,
    r = this.d,
    t = NaN;
  if (r) {
    if (((e = r.length - 1), (t = (e - Vr(this.e / qe)) * qe), (e = r[e]), e))
      for (; e % 10 == 0; e /= 10) t--;
    t < 0 && (t = 0);
  }
  return t;
};
ve.dividedBy = ve.div = function (e) {
  return yr(this, new this.constructor(e));
};
ve.dividedToIntegerBy = ve.divToInt = function (e) {
  var r = this,
    t = r.constructor;
  return Ie(yr(r, new t(e), 0, 1, 1), t.precision, t.rounding);
};
ve.equals = ve.eq = function (e) {
  return this.cmp(e) === 0;
};
ve.floor = function () {
  return Ie(new this.constructor(this), this.e + 1, 3);
};
ve.greaterThan = ve.gt = function (e) {
  return this.cmp(e) > 0;
};
ve.greaterThanOrEqualTo = ve.gte = function (e) {
  var r = this.cmp(e);
  return r == 1 || r === 0;
};
ve.hyperbolicCosine = ve.cosh = function () {
  var e,
    r,
    t,
    a,
    n,
    i = this,
    c = i.constructor,
    m = new c(1);
  if (!i.isFinite()) return new c(i.s ? 1 / 0 : NaN);
  if (i.isZero()) return m;
  (t = c.precision),
    (a = c.rounding),
    (c.precision = t + Math.max(i.e, i.sd()) + 4),
    (c.rounding = 1),
    (n = i.d.length),
    n < 32
      ? ((e = Math.ceil(n / 3)), (r = (1 / eo(4, e)).toString()))
      : ((e = 16), (r = "2.3283064365386962890625e-10")),
    (i = la(c, 1, i.times(r), new c(1), !0));
  for (var f, u = e, s = new c(8); u--; )
    (f = i.times(i)), (i = m.minus(f.times(s.minus(f.times(s)))));
  return Ie(i, (c.precision = t), (c.rounding = a), !0);
};
ve.hyperbolicSine = ve.sinh = function () {
  var e,
    r,
    t,
    a,
    n = this,
    i = n.constructor;
  if (!n.isFinite() || n.isZero()) return new i(n);
  if (
    ((r = i.precision),
    (t = i.rounding),
    (i.precision = r + Math.max(n.e, n.sd()) + 4),
    (i.rounding = 1),
    (a = n.d.length),
    a < 3)
  )
    n = la(i, 2, n, n, !0);
  else {
    (e = 1.4 * Math.sqrt(a)),
      (e = e > 16 ? 16 : e | 0),
      (n = n.times(1 / eo(5, e))),
      (n = la(i, 2, n, n, !0));
    for (var c, m = new i(5), f = new i(16), u = new i(20); e--; )
      (c = n.times(n)), (n = n.times(m.plus(c.times(f.times(c).plus(u)))));
  }
  return (i.precision = r), (i.rounding = t), Ie(n, r, t, !0);
};
ve.hyperbolicTangent = ve.tanh = function () {
  var e,
    r,
    t = this,
    a = t.constructor;
  return t.isFinite()
    ? t.isZero()
      ? new a(t)
      : ((e = a.precision),
        (r = a.rounding),
        (a.precision = e + 7),
        (a.rounding = 1),
        yr(t.sinh(), t.cosh(), (a.precision = e), (a.rounding = r)))
    : new a(t.s);
};
ve.inverseCosine = ve.acos = function () {
  var e,
    r = this,
    t = r.constructor,
    a = r.abs().cmp(1),
    n = t.precision,
    i = t.rounding;
  return a !== -1
    ? a === 0
      ? r.isNeg()
        ? gt(t, n, i)
        : new t(0)
      : new t(NaN)
    : r.isZero()
    ? gt(t, n + 4, i).times(0.5)
    : ((t.precision = n + 6),
      (t.rounding = 1),
      (r = r.asin()),
      (e = gt(t, n + 4, i).times(0.5)),
      (t.precision = n),
      (t.rounding = i),
      e.minus(r));
};
ve.inverseHyperbolicCosine = ve.acosh = function () {
  var e,
    r,
    t = this,
    a = t.constructor;
  return t.lte(1)
    ? new a(t.eq(1) ? 0 : NaN)
    : t.isFinite()
    ? ((e = a.precision),
      (r = a.rounding),
      (a.precision = e + Math.max(Math.abs(t.e), t.sd()) + 4),
      (a.rounding = 1),
      (Ve = !1),
      (t = t.times(t).minus(1).sqrt().plus(t)),
      (Ve = !0),
      (a.precision = e),
      (a.rounding = r),
      t.ln())
    : new a(t);
};
ve.inverseHyperbolicSine = ve.asinh = function () {
  var e,
    r,
    t = this,
    a = t.constructor;
  return !t.isFinite() || t.isZero()
    ? new a(t)
    : ((e = a.precision),
      (r = a.rounding),
      (a.precision = e + 2 * Math.max(Math.abs(t.e), t.sd()) + 6),
      (a.rounding = 1),
      (Ve = !1),
      (t = t.times(t).plus(1).sqrt().plus(t)),
      (Ve = !0),
      (a.precision = e),
      (a.rounding = r),
      t.ln());
};
ve.inverseHyperbolicTangent = ve.atanh = function () {
  var e,
    r,
    t,
    a,
    n = this,
    i = n.constructor;
  return n.isFinite()
    ? n.e >= 0
      ? new i(n.abs().eq(1) ? n.s / 0 : n.isZero() ? n : NaN)
      : ((e = i.precision),
        (r = i.rounding),
        (a = n.sd()),
        Math.max(a, e) < 2 * -n.e - 1
          ? Ie(new i(n), e, r, !0)
          : ((i.precision = t = a - n.e),
            (n = yr(n.plus(1), new i(1).minus(n), t + e, 1)),
            (i.precision = e + 4),
            (i.rounding = 1),
            (n = n.ln()),
            (i.precision = e),
            (i.rounding = r),
            n.times(0.5)))
    : new i(NaN);
};
ve.inverseSine = ve.asin = function () {
  var e,
    r,
    t,
    a,
    n = this,
    i = n.constructor;
  return n.isZero()
    ? new i(n)
    : ((r = n.abs().cmp(1)),
      (t = i.precision),
      (a = i.rounding),
      r !== -1
        ? r === 0
          ? ((e = gt(i, t + 4, a).times(0.5)), (e.s = n.s), e)
          : new i(NaN)
        : ((i.precision = t + 6),
          (i.rounding = 1),
          (n = n.div(new i(1).minus(n.times(n)).sqrt().plus(1)).atan()),
          (i.precision = t),
          (i.rounding = a),
          n.times(2)));
};
ve.inverseTangent = ve.atan = function () {
  var e,
    r,
    t,
    a,
    n,
    i,
    c,
    m,
    f,
    u = this,
    s = u.constructor,
    o = s.precision,
    l = s.rounding;
  if (u.isFinite()) {
    if (u.isZero()) return new s(u);
    if (u.abs().eq(1) && o + 4 <= hs)
      return (c = gt(s, o + 4, l).times(0.25)), (c.s = u.s), c;
  } else {
    if (!u.s) return new s(NaN);
    if (o + 4 <= hs) return (c = gt(s, o + 4, l).times(0.5)), (c.s = u.s), c;
  }
  for (
    s.precision = m = o + 10,
      s.rounding = 1,
      t = Math.min(28, (m / qe + 2) | 0),
      e = t;
    e;
    --e
  )
    u = u.div(u.times(u).plus(1).sqrt().plus(1));
  for (
    Ve = !1, r = Math.ceil(m / qe), a = 1, f = u.times(u), c = new s(u), n = u;
    e !== -1;

  )
    if (
      ((n = n.times(f)),
      (i = c.minus(n.div((a += 2)))),
      (n = n.times(f)),
      (c = i.plus(n.div((a += 2)))),
      c.d[r] !== void 0)
    )
      for (e = r; c.d[e] === i.d[e] && e--; );
  return (
    t && (c = c.times(2 << (t - 1))),
    (Ve = !0),
    Ie(c, (s.precision = o), (s.rounding = l), !0)
  );
};
ve.isFinite = function () {
  return !!this.d;
};
ve.isInteger = ve.isInt = function () {
  return !!this.d && Vr(this.e / qe) > this.d.length - 2;
};
ve.isNaN = function () {
  return !this.s;
};
ve.isNegative = ve.isNeg = function () {
  return this.s < 0;
};
ve.isPositive = ve.isPos = function () {
  return this.s > 0;
};
ve.isZero = function () {
  return !!this.d && this.d[0] === 0;
};
ve.lessThan = ve.lt = function (e) {
  return this.cmp(e) < 0;
};
ve.lessThanOrEqualTo = ve.lte = function (e) {
  return this.cmp(e) < 1;
};
ve.logarithm = ve.log = function (e) {
  var r,
    t,
    a,
    n,
    i,
    c,
    m,
    f,
    u = this,
    s = u.constructor,
    o = s.precision,
    l = s.rounding,
    p = 5;
  if (e == null) (e = new s(10)), (r = !0);
  else {
    if (((e = new s(e)), (t = e.d), e.s < 0 || !t || !t[0] || e.eq(1)))
      return new s(NaN);
    r = e.eq(10);
  }
  if (((t = u.d), u.s < 0 || !t || !t[0] || u.eq(1)))
    return new s(t && !t[0] ? -1 / 0 : u.s != 1 ? NaN : t ? 0 : 1 / 0);
  if (r)
    if (t.length > 1) i = !0;
    else {
      for (n = t[0]; n % 10 === 0; ) n /= 10;
      i = n !== 1;
    }
  if (
    ((Ve = !1),
    (m = o + p),
    (c = pn(u, m)),
    (a = r ? Ii(s, m + 10) : pn(e, m)),
    (f = yr(c, a, m, 1)),
    za(f.d, (n = o), l))
  )
    do
      if (
        ((m += 10),
        (c = pn(u, m)),
        (a = r ? Ii(s, m + 10) : pn(e, m)),
        (f = yr(c, a, m, 1)),
        !i)
      ) {
        +zr(f.d).slice(n + 1, n + 15) + 1 == 1e14 && (f = Ie(f, o + 1, 0));
        break;
      }
    while (za(f.d, (n += 10), l));
  return (Ve = !0), Ie(f, o, l);
};
ve.minus = ve.sub = function (e) {
  var r,
    t,
    a,
    n,
    i,
    c,
    m,
    f,
    u,
    s,
    o,
    l,
    p = this,
    v = p.constructor;
  if (((e = new v(e)), !p.d || !e.d))
    return (
      !p.s || !e.s
        ? (e = new v(NaN))
        : p.d
        ? (e.s = -e.s)
        : (e = new v(e.d || p.s !== e.s ? p : NaN)),
      e
    );
  if (p.s != e.s) return (e.s = -e.s), p.plus(e);
  if (
    ((u = p.d), (l = e.d), (m = v.precision), (f = v.rounding), !u[0] || !l[0])
  ) {
    if (l[0]) e.s = -e.s;
    else if (u[0]) e = new v(p);
    else return new v(f === 3 ? -0 : 0);
    return Ve ? Ie(e, m, f) : e;
  }
  if (
    ((t = Vr(e.e / qe)), (s = Vr(p.e / qe)), (u = u.slice()), (i = s - t), i)
  ) {
    for (
      o = i < 0,
        o
          ? ((r = u), (i = -i), (c = l.length))
          : ((r = l), (t = s), (c = u.length)),
        a = Math.max(Math.ceil(m / qe), c) + 2,
        i > a && ((i = a), (r.length = 1)),
        r.reverse(),
        a = i;
      a--;

    )
      r.push(0);
    r.reverse();
  } else {
    for (a = u.length, c = l.length, o = a < c, o && (c = a), a = 0; a < c; a++)
      if (u[a] != l[a]) {
        o = u[a] < l[a];
        break;
      }
    i = 0;
  }
  for (
    o && ((r = u), (u = l), (l = r), (e.s = -e.s)),
      c = u.length,
      a = l.length - c;
    a > 0;
    --a
  )
    u[c++] = 0;
  for (a = l.length; a > i; ) {
    if (u[--a] < l[a]) {
      for (n = a; n && u[--n] === 0; ) u[n] = bt - 1;
      --u[n], (u[a] += bt);
    }
    u[a] -= l[a];
  }
  for (; u[--c] === 0; ) u.pop();
  for (; u[0] === 0; u.shift()) --t;
  return u[0]
    ? ((e.d = u), (e.e = Ki(u, t)), Ve ? Ie(e, m, f) : e)
    : new v(f === 3 ? -0 : 0);
};
ve.modulo = ve.mod = function (e) {
  var r,
    t = this,
    a = t.constructor;
  return (
    (e = new a(e)),
    !t.d || !e.s || (e.d && !e.d[0])
      ? new a(NaN)
      : !e.d || (t.d && !t.d[0])
      ? Ie(new a(t), a.precision, a.rounding)
      : ((Ve = !1),
        a.modulo == 9
          ? ((r = yr(t, e.abs(), 0, 3, 1)), (r.s *= e.s))
          : (r = yr(t, e, 0, a.modulo, 1)),
        (r = r.times(e)),
        (Ve = !0),
        t.minus(r))
  );
};
ve.naturalExponential = ve.exp = function () {
  return ds(this);
};
ve.naturalLogarithm = ve.ln = function () {
  return pn(this);
};
ve.negated = ve.neg = function () {
  var e = new this.constructor(this);
  return (e.s = -e.s), Ie(e);
};
ve.plus = ve.add = function (e) {
  var r,
    t,
    a,
    n,
    i,
    c,
    m,
    f,
    u,
    s,
    o = this,
    l = o.constructor;
  if (((e = new l(e)), !o.d || !e.d))
    return (
      !o.s || !e.s
        ? (e = new l(NaN))
        : o.d || (e = new l(e.d || o.s === e.s ? o : NaN)),
      e
    );
  if (o.s != e.s) return (e.s = -e.s), o.minus(e);
  if (
    ((u = o.d), (s = e.d), (m = l.precision), (f = l.rounding), !u[0] || !s[0])
  )
    return s[0] || (e = new l(o)), Ve ? Ie(e, m, f) : e;
  if (
    ((i = Vr(o.e / qe)), (a = Vr(e.e / qe)), (u = u.slice()), (n = i - a), n)
  ) {
    for (
      n < 0
        ? ((t = u), (n = -n), (c = s.length))
        : ((t = s), (a = i), (c = u.length)),
        i = Math.ceil(m / qe),
        c = i > c ? i + 1 : c + 1,
        n > c && ((n = c), (t.length = 1)),
        t.reverse();
      n--;

    )
      t.push(0);
    t.reverse();
  }
  for (
    c = u.length,
      n = s.length,
      c - n < 0 && ((n = c), (t = s), (s = u), (u = t)),
      r = 0;
    n;

  )
    (r = ((u[--n] = u[n] + s[n] + r) / bt) | 0), (u[n] %= bt);
  for (r && (u.unshift(r), ++a), c = u.length; u[--c] == 0; ) u.pop();
  return (e.d = u), (e.e = Ki(u, a)), Ve ? Ie(e, m, f) : e;
};
ve.precision = ve.sd = function (e) {
  var r,
    t = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(hn + e);
  return (
    t.d ? ((r = jp(t.d)), e && t.e + 1 > r && (r = t.e + 1)) : (r = NaN), r
  );
};
ve.round = function () {
  var e = this,
    r = e.constructor;
  return Ie(new r(e), e.e + 1, r.rounding);
};
ve.sine = ve.sin = function () {
  var e,
    r,
    t = this,
    a = t.constructor;
  return t.isFinite()
    ? t.isZero()
      ? new a(t)
      : ((e = a.precision),
        (r = a.rounding),
        (a.precision = e + Math.max(t.e, t.sd()) + qe),
        (a.rounding = 1),
        (t = C1(a, tv(a, t))),
        (a.precision = e),
        (a.rounding = r),
        Ie(Ht > 2 ? t.neg() : t, e, r, !0))
    : new a(NaN);
};
ve.squareRoot = ve.sqrt = function () {
  var e,
    r,
    t,
    a,
    n,
    i,
    c = this,
    m = c.d,
    f = c.e,
    u = c.s,
    s = c.constructor;
  if (u !== 1 || !m || !m[0])
    return new s(!u || (u < 0 && (!m || m[0])) ? NaN : m ? c : 1 / 0);
  for (
    Ve = !1,
      u = Math.sqrt(+c),
      u == 0 || u == 1 / 0
        ? ((r = zr(m)),
          (r.length + f) % 2 == 0 && (r += "0"),
          (u = Math.sqrt(r)),
          (f = Vr((f + 1) / 2) - (f < 0 || f % 2)),
          u == 1 / 0
            ? (r = "5e" + f)
            : ((r = u.toExponential()),
              (r = r.slice(0, r.indexOf("e") + 1) + f)),
          (a = new s(r)))
        : (a = new s(u.toString())),
      t = (f = s.precision) + 3;
    ;

  )
    if (
      ((i = a),
      (a = i.plus(yr(c, i, t + 2, 1)).times(0.5)),
      zr(i.d).slice(0, t) === (r = zr(a.d)).slice(0, t))
    )
      if (((r = r.slice(t - 3, t + 1)), r == "9999" || (!n && r == "4999"))) {
        if (!n && (Ie(i, f + 1, 0), i.times(i).eq(c))) {
          a = i;
          break;
        }
        (t += 4), (n = 1);
      } else {
        (!+r || (!+r.slice(1) && r.charAt(0) == "5")) &&
          (Ie(a, f + 1, 1), (e = !a.times(a).eq(c)));
        break;
      }
  return (Ve = !0), Ie(a, f, s.rounding, e);
};
ve.tangent = ve.tan = function () {
  var e,
    r,
    t = this,
    a = t.constructor;
  return t.isFinite()
    ? t.isZero()
      ? new a(t)
      : ((e = a.precision),
        (r = a.rounding),
        (a.precision = e + 10),
        (a.rounding = 1),
        (t = t.sin()),
        (t.s = 1),
        (t = yr(t, new a(1).minus(t.times(t)).sqrt(), e + 10, 0)),
        (a.precision = e),
        (a.rounding = r),
        Ie(Ht == 2 || Ht == 4 ? t.neg() : t, e, r, !0))
    : new a(NaN);
};
ve.times = ve.mul = function (e) {
  var r,
    t,
    a,
    n,
    i,
    c,
    m,
    f,
    u,
    s = this,
    o = s.constructor,
    l = s.d,
    p = (e = new o(e)).d;
  if (((e.s *= s.s), !l || !l[0] || !p || !p[0]))
    return new o(
      !e.s || (l && !l[0] && !p) || (p && !p[0] && !l)
        ? NaN
        : !l || !p
        ? e.s / 0
        : e.s * 0
    );
  for (
    t = Vr(s.e / qe) + Vr(e.e / qe),
      f = l.length,
      u = p.length,
      f < u && ((i = l), (l = p), (p = i), (c = f), (f = u), (u = c)),
      i = [],
      c = f + u,
      a = c;
    a--;

  )
    i.push(0);
  for (a = u; --a >= 0; ) {
    for (r = 0, n = f + a; n > a; )
      (m = i[n] + p[a] * l[n - a - 1] + r),
        (i[n--] = m % bt | 0),
        (r = (m / bt) | 0);
    i[n] = (i[n] + r) % bt | 0;
  }
  for (; !i[--c]; ) i.pop();
  return (
    r ? ++t : i.shift(),
    (e.d = i),
    (e.e = Ki(i, t)),
    Ve ? Ie(e, o.precision, o.rounding) : e
  );
};
ve.toBinary = function (e, r) {
  return Js(this, 2, e, r);
};
ve.toDecimalPlaces = ve.toDP = function (e, r) {
  var t = this,
    a = t.constructor;
  return (
    (t = new a(t)),
    e === void 0
      ? t
      : (rt(e, 0, yn),
        r === void 0 ? (r = a.rounding) : rt(r, 0, 8),
        Ie(t, e + t.e + 1, r))
  );
};
ve.toExponential = function (e, r) {
  var t,
    a = this,
    n = a.constructor;
  return (
    e === void 0
      ? (t = Ft(a, !0))
      : (rt(e, 0, yn),
        r === void 0 ? (r = n.rounding) : rt(r, 0, 8),
        (a = Ie(new n(a), e + 1, r)),
        (t = Ft(a, !0, e + 1))),
    a.isNeg() && !a.isZero() ? "-" + t : t
  );
};
ve.toFixed = function (e, r) {
  var t,
    a,
    n = this,
    i = n.constructor;
  return (
    e === void 0
      ? (t = Ft(n))
      : (rt(e, 0, yn),
        r === void 0 ? (r = i.rounding) : rt(r, 0, 8),
        (a = Ie(new i(n), e + n.e + 1, r)),
        (t = Ft(a, !1, e + a.e + 1))),
    n.isNeg() && !n.isZero() ? "-" + t : t
  );
};
ve.toFraction = function (e) {
  var r,
    t,
    a,
    n,
    i,
    c,
    m,
    f,
    u,
    s,
    o,
    l,
    p = this,
    v = p.d,
    h = p.constructor;
  if (!v) return new h(p);
  if (
    ((u = t = new h(1)),
    (a = f = new h(0)),
    (r = new h(a)),
    (i = r.e = jp(v) - p.e - 1),
    (c = i % qe),
    (r.d[0] = Br(10, c < 0 ? qe + c : c)),
    e == null)
  )
    e = i > 0 ? r : u;
  else {
    if (((m = new h(e)), !m.isInt() || m.lt(u))) throw Error(hn + m);
    e = m.gt(r) ? (i > 0 ? r : u) : m;
  }
  for (
    Ve = !1,
      m = new h(zr(v)),
      s = h.precision,
      h.precision = i = v.length * qe * 2;
    (o = yr(m, r, 0, 1, 1)), (n = t.plus(o.times(a))), n.cmp(e) != 1;

  )
    (t = a),
      (a = n),
      (n = u),
      (u = f.plus(o.times(n))),
      (f = n),
      (n = r),
      (r = m.minus(o.times(n))),
      (m = n);
  return (
    (n = yr(e.minus(t), a, 0, 1, 1)),
    (f = f.plus(n.times(u))),
    (t = t.plus(n.times(a))),
    (f.s = u.s = p.s),
    (l =
      yr(u, a, i, 1).minus(p).abs().cmp(yr(f, t, i, 1).minus(p).abs()) < 1
        ? [u, a]
        : [f, t]),
    (h.precision = s),
    (Ve = !0),
    l
  );
};
ve.toHexadecimal = ve.toHex = function (e, r) {
  return Js(this, 16, e, r);
};
ve.toNearest = function (e, r) {
  var t = this,
    a = t.constructor;
  if (((t = new a(t)), e == null)) {
    if (!t.d) return t;
    (e = new a(1)), (r = a.rounding);
  } else {
    if (((e = new a(e)), r === void 0 ? (r = a.rounding) : rt(r, 0, 8), !t.d))
      return e.s ? t : e;
    if (!e.d) return e.s && (e.s = t.s), e;
  }
  return (
    e.d[0]
      ? ((Ve = !1), (t = yr(t, e, 0, r, 1).times(e)), (Ve = !0), Ie(t))
      : ((e.s = t.s), (t = e)),
    t
  );
};
ve.toNumber = function () {
  return +this;
};
ve.toOctal = function (e, r) {
  return Js(this, 8, e, r);
};
ve.toPower = ve.pow = function (e) {
  var r,
    t,
    a,
    n,
    i,
    c,
    m = this,
    f = m.constructor,
    u = +(e = new f(e));
  if (!m.d || !e.d || !m.d[0] || !e.d[0]) return new f(Br(+m, u));
  if (((m = new f(m)), m.eq(1))) return m;
  if (((a = f.precision), (i = f.rounding), e.eq(1))) return Ie(m, a, i);
  if (((r = Vr(e.e / qe)), r >= e.d.length - 1 && (t = u < 0 ? -u : u) <= M1))
    return (n = Kp(f, m, t, a)), e.s < 0 ? new f(1).div(n) : Ie(n, a, i);
  if (((c = m.s), c < 0)) {
    if (r < e.d.length - 1) return new f(NaN);
    if ((e.d[r] & 1 || (c = 1), m.e == 0 && m.d[0] == 1 && m.d.length == 1))
      return (m.s = c), m;
  }
  return (
    (t = Br(+m, u)),
    (r =
      t == 0 || !isFinite(t)
        ? Vr(u * (Math.log("0." + zr(m.d)) / Math.LN10 + m.e + 1))
        : new f(t + "").e),
    r > f.maxE + 1 || r < f.minE - 1
      ? new f(r > 0 ? c / 0 : 0)
      : ((Ve = !1),
        (f.rounding = m.s = 1),
        (t = Math.min(12, (r + "").length)),
        (n = ds(e.times(pn(m, a + t)), a)),
        n.d &&
          ((n = Ie(n, a + 5, 1)),
          za(n.d, a, i) &&
            ((r = a + 10),
            (n = Ie(ds(e.times(pn(m, r + t)), r), r + 5, 1)),
            +zr(n.d).slice(a + 1, a + 15) + 1 == 1e14 &&
              (n = Ie(n, a + 1, 0)))),
        (n.s = c),
        (Ve = !0),
        (f.rounding = i),
        Ie(n, a, i))
  );
};
ve.toPrecision = function (e, r) {
  var t,
    a = this,
    n = a.constructor;
  return (
    e === void 0
      ? (t = Ft(a, a.e <= n.toExpNeg || a.e >= n.toExpPos))
      : (rt(e, 1, yn),
        r === void 0 ? (r = n.rounding) : rt(r, 0, 8),
        (a = Ie(new n(a), e, r)),
        (t = Ft(a, e <= a.e || a.e <= n.toExpNeg, e))),
    a.isNeg() && !a.isZero() ? "-" + t : t
  );
};
ve.toSignificantDigits = ve.toSD = function (e, r) {
  var t = this,
    a = t.constructor;
  return (
    e === void 0
      ? ((e = a.precision), (r = a.rounding))
      : (rt(e, 1, yn), r === void 0 ? (r = a.rounding) : rt(r, 0, 8)),
    Ie(new a(t), e, r)
  );
};
ve.toString = function () {
  var e = this,
    r = e.constructor,
    t = Ft(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
  return e.isNeg() && !e.isZero() ? "-" + t : t;
};
ve.truncated = ve.trunc = function () {
  return Ie(new this.constructor(this), this.e + 1, 1);
};
ve.valueOf = ve.toJSON = function () {
  var e = this,
    r = e.constructor,
    t = Ft(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
  return e.isNeg() ? "-" + t : t;
};
function zr(e) {
  var r,
    t,
    a,
    n = e.length - 1,
    i = "",
    c = e[0];
  if (n > 0) {
    for (i += c, r = 1; r < n; r++)
      (a = e[r] + ""), (t = qe - a.length), t && (i += ln(t)), (i += a);
    (c = e[r]), (a = c + ""), (t = qe - a.length), t && (i += ln(t));
  } else if (c === 0) return "0";
  for (; c % 10 === 0; ) c /= 10;
  return i + c;
}
function rt(e, r, t) {
  if (e !== ~~e || e < r || e > t) throw Error(hn + e);
}
function za(e, r, t, a) {
  var n, i, c, m;
  for (i = e[0]; i >= 10; i /= 10) --r;
  return (
    --r < 0 ? ((r += qe), (n = 0)) : ((n = Math.ceil((r + 1) / qe)), (r %= qe)),
    (i = Br(10, qe - r)),
    (m = e[n] % i | 0),
    a == null
      ? r < 3
        ? (r == 0 ? (m = (m / 100) | 0) : r == 1 && (m = (m / 10) | 0),
          (c =
            (t < 4 && m == 99999) ||
            (t > 3 && m == 49999) ||
            m == 5e4 ||
            m == 0))
        : (c =
            (((t < 4 && m + 1 == i) || (t > 3 && m + 1 == i / 2)) &&
              ((e[n + 1] / i / 100) | 0) == Br(10, r - 2) - 1) ||
            ((m == i / 2 || m == 0) && ((e[n + 1] / i / 100) | 0) == 0))
      : r < 4
      ? (r == 0
          ? (m = (m / 1e3) | 0)
          : r == 1
          ? (m = (m / 100) | 0)
          : r == 2 && (m = (m / 10) | 0),
        (c = ((a || t < 4) && m == 9999) || (!a && t > 3 && m == 4999)))
      : (c =
          (((a || t < 4) && m + 1 == i) || (!a && t > 3 && m + 1 == i / 2)) &&
          ((e[n + 1] / i / 1e3) | 0) == Br(10, r - 3) - 1),
    c
  );
}
function Ai(e, r, t) {
  for (var a, n = [0], i, c = 0, m = e.length; c < m; ) {
    for (i = n.length; i--; ) n[i] *= r;
    for (n[0] += ps.indexOf(e.charAt(c++)), a = 0; a < n.length; a++)
      n[a] > t - 1 &&
        (n[a + 1] === void 0 && (n[a + 1] = 0),
        (n[a + 1] += (n[a] / t) | 0),
        (n[a] %= t));
  }
  return n.reverse();
}
function S1(e, r) {
  var t, a, n;
  if (r.isZero()) return r;
  (a = r.d.length),
    a < 32
      ? ((t = Math.ceil(a / 3)), (n = (1 / eo(4, t)).toString()))
      : ((t = 16), (n = "2.3283064365386962890625e-10")),
    (e.precision += t),
    (r = la(e, 1, r.times(n), new e(1)));
  for (var i = t; i--; ) {
    var c = r.times(r);
    r = c.times(c).minus(c).times(8).plus(1);
  }
  return (e.precision -= t), r;
}
var yr = (function () {
  function e(a, n, i) {
    var c,
      m = 0,
      f = a.length;
    for (a = a.slice(); f--; )
      (c = a[f] * n + m), (a[f] = c % i | 0), (m = (c / i) | 0);
    return m && a.unshift(m), a;
  }
  function r(a, n, i, c) {
    var m, f;
    if (i != c) f = i > c ? 1 : -1;
    else
      for (m = f = 0; m < i; m++)
        if (a[m] != n[m]) {
          f = a[m] > n[m] ? 1 : -1;
          break;
        }
    return f;
  }
  function t(a, n, i, c) {
    for (var m = 0; i--; )
      (a[i] -= m), (m = a[i] < n[i] ? 1 : 0), (a[i] = m * c + a[i] - n[i]);
    for (; !a[0] && a.length > 1; ) a.shift();
  }
  return function (a, n, i, c, m, f) {
    var u,
      s,
      o,
      l,
      p,
      v,
      h,
      x,
      b,
      N,
      d,
      y,
      w,
      g,
      S,
      A,
      E,
      M,
      B,
      C,
      _ = a.constructor,
      z = a.s == n.s ? 1 : -1,
      I = a.d,
      T = n.d;
    if (!I || !I[0] || !T || !T[0])
      return new _(
        !a.s || !n.s || (I ? T && I[0] == T[0] : !T)
          ? NaN
          : (I && I[0] == 0) || !T
          ? z * 0
          : z / 0
      );
    for (
      f
        ? ((p = 1), (s = a.e - n.e))
        : ((f = bt), (p = qe), (s = Vr(a.e / p) - Vr(n.e / p))),
        B = T.length,
        E = I.length,
        b = new _(z),
        N = b.d = [],
        o = 0;
      T[o] == (I[o] || 0);
      o++
    );
    if (
      (T[o] > (I[o] || 0) && s--,
      i == null
        ? ((g = i = _.precision), (c = _.rounding))
        : m
        ? (g = i + (a.e - n.e) + 1)
        : (g = i),
      g < 0)
    )
      N.push(1), (v = !0);
    else {
      if (((g = (g / p + 2) | 0), (o = 0), B == 1)) {
        for (l = 0, T = T[0], g++; (o < E || l) && g--; o++)
          (S = l * f + (I[o] || 0)), (N[o] = (S / T) | 0), (l = S % T | 0);
        v = l || o < E;
      } else {
        for (
          l = (f / (T[0] + 1)) | 0,
            l > 1 &&
              ((T = e(T, l, f)),
              (I = e(I, l, f)),
              (B = T.length),
              (E = I.length)),
            A = B,
            d = I.slice(0, B),
            y = d.length;
          y < B;

        )
          d[y++] = 0;
        (C = T.slice()), C.unshift(0), (M = T[0]), T[1] >= f / 2 && ++M;
        do
          (l = 0),
            (u = r(T, d, B, y)),
            u < 0
              ? ((w = d[0]),
                B != y && (w = w * f + (d[1] || 0)),
                (l = (w / M) | 0),
                l > 1
                  ? (l >= f && (l = f - 1),
                    (h = e(T, l, f)),
                    (x = h.length),
                    (y = d.length),
                    (u = r(h, d, x, y)),
                    u == 1 && (l--, t(h, B < x ? C : T, x, f)))
                  : (l == 0 && (u = l = 1), (h = T.slice())),
                (x = h.length),
                x < y && h.unshift(0),
                t(d, h, y, f),
                u == -1 &&
                  ((y = d.length),
                  (u = r(T, d, B, y)),
                  u < 1 && (l++, t(d, B < y ? C : T, y, f))),
                (y = d.length))
              : u === 0 && (l++, (d = [0])),
            (N[o++] = l),
            u && d[0] ? (d[y++] = I[A] || 0) : ((d = [I[A]]), (y = 1));
        while ((A++ < E || d[0] !== void 0) && g--);
        v = d[0] !== void 0;
      }
      N[0] || N.shift();
    }
    if (p == 1) (b.e = s), (Jp = v);
    else {
      for (o = 1, l = N[0]; l >= 10; l /= 10) o++;
      (b.e = o + s * p - 1), Ie(b, m ? i + b.e + 1 : i, c, v);
    }
    return b;
  };
})();
function Ie(e, r, t, a) {
  var n,
    i,
    c,
    m,
    f,
    u,
    s,
    o,
    l,
    p = e.constructor;
  e: if (r != null) {
    if (((o = e.d), !o)) return e;
    for (n = 1, m = o[0]; m >= 10; m /= 10) n++;
    if (((i = r - n), i < 0))
      (i += qe),
        (c = r),
        (s = o[(l = 0)]),
        (f = (s / Br(10, n - c - 1)) % 10 | 0);
    else if (((l = Math.ceil((i + 1) / qe)), (m = o.length), l >= m))
      if (a) {
        for (; m++ <= l; ) o.push(0);
        (s = f = 0), (n = 1), (i %= qe), (c = i - qe + 1);
      } else break e;
    else {
      for (s = m = o[l], n = 1; m >= 10; m /= 10) n++;
      (i %= qe),
        (c = i - qe + n),
        (f = c < 0 ? 0 : (s / Br(10, n - c - 1)) % 10 | 0);
    }
    if (
      ((a =
        a ||
        r < 0 ||
        o[l + 1] !== void 0 ||
        (c < 0 ? s : s % Br(10, n - c - 1))),
      (u =
        t < 4
          ? (f || a) && (t == 0 || t == (e.s < 0 ? 3 : 2))
          : f > 5 ||
            (f == 5 &&
              (t == 4 ||
                a ||
                (t == 6 &&
                  (i > 0 ? (c > 0 ? s / Br(10, n - c) : 0) : o[l - 1]) % 10 &
                    1) ||
                t == (e.s < 0 ? 8 : 7)))),
      r < 1 || !o[0])
    )
      return (
        (o.length = 0),
        u
          ? ((r -= e.e + 1),
            (o[0] = Br(10, (qe - (r % qe)) % qe)),
            (e.e = -r || 0))
          : (o[0] = e.e = 0),
        e
      );
    if (
      (i == 0
        ? ((o.length = l), (m = 1), l--)
        : ((o.length = l + 1),
          (m = Br(10, qe - i)),
          (o[l] = c > 0 ? ((s / Br(10, n - c)) % Br(10, c) | 0) * m : 0)),
      u)
    )
      for (;;)
        if (l == 0) {
          for (i = 1, c = o[0]; c >= 10; c /= 10) i++;
          for (c = o[0] += m, m = 1; c >= 10; c /= 10) m++;
          i != m && (e.e++, o[0] == bt && (o[0] = 1));
          break;
        } else {
          if (((o[l] += m), o[l] != bt)) break;
          (o[l--] = 0), (m = 1);
        }
    for (i = o.length; o[--i] === 0; ) o.pop();
  }
  return (
    Ve &&
      (e.e > p.maxE
        ? ((e.d = null), (e.e = NaN))
        : e.e < p.minE && ((e.e = 0), (e.d = [0]))),
    e
  );
}
function Ft(e, r, t) {
  if (!e.isFinite()) return rv(e);
  var a,
    n = e.e,
    i = zr(e.d),
    c = i.length;
  return (
    r
      ? (t && (a = t - c) > 0
          ? (i = i.charAt(0) + "." + i.slice(1) + ln(a))
          : c > 1 && (i = i.charAt(0) + "." + i.slice(1)),
        (i = i + (e.e < 0 ? "e" : "e+") + e.e))
      : n < 0
      ? ((i = "0." + ln(-n - 1) + i), t && (a = t - c) > 0 && (i += ln(a)))
      : n >= c
      ? ((i += ln(n + 1 - c)),
        t && (a = t - n - 1) > 0 && (i = i + "." + ln(a)))
      : ((a = n + 1) < c && (i = i.slice(0, a) + "." + i.slice(a)),
        t && (a = t - c) > 0 && (n + 1 === c && (i += "."), (i += ln(a)))),
    i
  );
}
function Ki(e, r) {
  var t = e[0];
  for (r *= qe; t >= 10; t /= 10) r++;
  return r;
}
function Ii(e, r, t) {
  if (r > A1) throw ((Ve = !0), t && (e.precision = t), Error(Wp));
  return Ie(new e(Bi), r, 1, !0);
}
function gt(e, r, t) {
  if (r > hs) throw Error(Wp);
  return Ie(new e(_i), r, t, !0);
}
function jp(e) {
  var r = e.length - 1,
    t = r * qe + 1;
  if (((r = e[r]), r)) {
    for (; r % 10 == 0; r /= 10) t--;
    for (r = e[0]; r >= 10; r /= 10) t++;
  }
  return t;
}
function ln(e) {
  for (var r = ""; e--; ) r += "0";
  return r;
}
function Kp(e, r, t, a) {
  var n,
    i = new e(1),
    c = Math.ceil(a / qe + 4);
  for (Ve = !1; ; ) {
    if (
      (t % 2 && ((i = i.times(r)), Ju(i.d, c) && (n = !0)),
      (t = Vr(t / 2)),
      t === 0)
    ) {
      (t = i.d.length - 1), n && i.d[t] === 0 && ++i.d[t];
      break;
    }
    (r = r.times(r)), Ju(r.d, c);
  }
  return (Ve = !0), i;
}
function Zu(e) {
  return e.d[e.d.length - 1] & 1;
}
function ev(e, r, t) {
  for (var a, n = new e(r[0]), i = 0; ++i < r.length; )
    if (((a = new e(r[i])), a.s)) n[t](a) && (n = a);
    else {
      n = a;
      break;
    }
  return n;
}
function ds(e, r) {
  var t,
    a,
    n,
    i,
    c,
    m,
    f,
    u = 0,
    s = 0,
    o = 0,
    l = e.constructor,
    p = l.rounding,
    v = l.precision;
  if (!e.d || !e.d[0] || e.e > 17)
    return new l(
      e.d ? (e.d[0] ? (e.s < 0 ? 0 : 1 / 0) : 1) : e.s ? (e.s < 0 ? 0 : e) : NaN
    );
  for (
    r == null ? ((Ve = !1), (f = v)) : (f = r), m = new l(0.03125);
    e.e > -2;

  )
    (e = e.times(m)), (o += 5);
  for (
    a = ((Math.log(Br(2, o)) / Math.LN10) * 2 + 5) | 0,
      f += a,
      t = i = c = new l(1),
      l.precision = f;
    ;

  ) {
    if (
      ((i = Ie(i.times(e), f, 1)),
      (t = t.times(++s)),
      (m = c.plus(yr(i, t, f, 1))),
      zr(m.d).slice(0, f) === zr(c.d).slice(0, f))
    ) {
      for (n = o; n--; ) c = Ie(c.times(c), f, 1);
      if (r == null)
        if (u < 3 && za(c.d, f - a, p, u))
          (l.precision = f += 10), (t = i = m = new l(1)), (s = 0), u++;
        else return Ie(c, (l.precision = v), p, (Ve = !0));
      else return (l.precision = v), c;
    }
    c = m;
  }
}
function pn(e, r) {
  var t,
    a,
    n,
    i,
    c,
    m,
    f,
    u,
    s,
    o,
    l,
    p = 1,
    v = 10,
    h = e,
    x = h.d,
    b = h.constructor,
    N = b.rounding,
    d = b.precision;
  if (h.s < 0 || !x || !x[0] || (!h.e && x[0] == 1 && x.length == 1))
    return new b(x && !x[0] ? -1 / 0 : h.s != 1 ? NaN : x ? 0 : h);
  if (
    (r == null ? ((Ve = !1), (s = d)) : (s = r),
    (b.precision = s += v),
    (t = zr(x)),
    (a = t.charAt(0)),
    Math.abs((i = h.e)) < 15e14)
  ) {
    for (; (a < 7 && a != 1) || (a == 1 && t.charAt(1) > 3); )
      (h = h.times(e)), (t = zr(h.d)), (a = t.charAt(0)), p++;
    (i = h.e),
      a > 1 ? ((h = new b("0." + t)), i++) : (h = new b(a + "." + t.slice(1)));
  } else
    return (
      (u = Ii(b, s + 2, d).times(i + "")),
      (h = pn(new b(a + "." + t.slice(1)), s - v).plus(u)),
      (b.precision = d),
      r == null ? Ie(h, d, N, (Ve = !0)) : h
    );
  for (
    o = h,
      f = c = h = yr(h.minus(1), h.plus(1), s, 1),
      l = Ie(h.times(h), s, 1),
      n = 3;
    ;

  ) {
    if (
      ((c = Ie(c.times(l), s, 1)),
      (u = f.plus(yr(c, new b(n), s, 1))),
      zr(u.d).slice(0, s) === zr(f.d).slice(0, s))
    )
      if (
        ((f = f.times(2)),
        i !== 0 && (f = f.plus(Ii(b, s + 2, d).times(i + ""))),
        (f = yr(f, new b(p), s, 1)),
        r == null)
      )
        if (za(f.d, s - v, N, m))
          (b.precision = s += v),
            (u = c = h = yr(o.minus(1), o.plus(1), s, 1)),
            (l = Ie(h.times(h), s, 1)),
            (n = m = 1);
        else return Ie(f, (b.precision = d), N, (Ve = !0));
      else return (b.precision = d), f;
    (f = u), (n += 2);
  }
}
function rv(e) {
  return String((e.s * e.s) / 0);
}
function gs(e, r) {
  var t, a, n;
  for (
    (t = r.indexOf(".")) > -1 && (r = r.replace(".", "")),
      (a = r.search(/e/i)) > 0
        ? (t < 0 && (t = a), (t += +r.slice(a + 1)), (r = r.substring(0, a)))
        : t < 0 && (t = r.length),
      a = 0;
    r.charCodeAt(a) === 48;
    a++
  );
  for (n = r.length; r.charCodeAt(n - 1) === 48; --n);
  if (((r = r.slice(a, n)), r)) {
    if (
      ((n -= a),
      (e.e = t = t - a - 1),
      (e.d = []),
      (a = (t + 1) % qe),
      t < 0 && (a += qe),
      a < n)
    ) {
      for (a && e.d.push(+r.slice(0, a)), n -= qe; a < n; )
        e.d.push(+r.slice(a, (a += qe)));
      (r = r.slice(a)), (a = qe - r.length);
    } else a -= n;
    for (; a--; ) r += "0";
    e.d.push(+r),
      Ve &&
        (e.e > e.constructor.maxE
          ? ((e.d = null), (e.e = NaN))
          : e.e < e.constructor.minE && ((e.e = 0), (e.d = [0])));
  } else (e.e = 0), (e.d = [0]);
  return e;
}
function E1(e, r) {
  var t, a, n, i, c, m, f, u, s;
  if (r.indexOf("_") > -1) {
    if (((r = r.replace(/(\d)_(?=\d)/g, "$1")), Qp.test(r))) return gs(e, r);
  } else if (r === "Infinity" || r === "NaN")
    return +r || (e.s = NaN), (e.e = NaN), (e.d = null), e;
  if (w1.test(r)) (t = 16), (r = r.toLowerCase());
  else if (x1.test(r)) t = 2;
  else if (N1.test(r)) t = 8;
  else throw Error(hn + r);
  for (
    i = r.search(/p/i),
      i > 0
        ? ((f = +r.slice(i + 1)), (r = r.substring(2, i)))
        : (r = r.slice(2)),
      i = r.indexOf("."),
      c = i >= 0,
      a = e.constructor,
      c &&
        ((r = r.replace(".", "")),
        (m = r.length),
        (i = m - i),
        (n = Kp(a, new a(t), i, i * 2))),
      u = Ai(r, t, bt),
      s = u.length - 1,
      i = s;
    u[i] === 0;
    --i
  )
    u.pop();
  return i < 0
    ? new a(e.s * 0)
    : ((e.e = Ki(u, s)),
      (e.d = u),
      (Ve = !1),
      c && (e = yr(e, n, m * 4)),
      f && (e = e.times(Math.abs(f) < 54 ? Br(2, f) : dn.pow(2, f))),
      (Ve = !0),
      e);
}
function C1(e, r) {
  var t,
    a = r.d.length;
  if (a < 3) return r.isZero() ? r : la(e, 2, r, r);
  (t = 1.4 * Math.sqrt(a)),
    (t = t > 16 ? 16 : t | 0),
    (r = r.times(1 / eo(5, t))),
    (r = la(e, 2, r, r));
  for (var n, i = new e(5), c = new e(16), m = new e(20); t--; )
    (n = r.times(r)), (r = r.times(i.plus(n.times(c.times(n).minus(m)))));
  return r;
}
function la(e, r, t, a, n) {
  var i,
    c,
    m,
    f,
    u = e.precision,
    s = Math.ceil(u / qe);
  for (Ve = !1, f = t.times(t), m = new e(a); ; ) {
    if (
      ((c = yr(m.times(f), new e(r++ * r++), u, 1)),
      (m = n ? a.plus(c) : a.minus(c)),
      (a = yr(c.times(f), new e(r++ * r++), u, 1)),
      (c = m.plus(a)),
      c.d[s] !== void 0)
    ) {
      for (i = s; c.d[i] === m.d[i] && i--; );
      if (i == -1) break;
    }
    (i = m), (m = a), (a = c), (c = i);
  }
  return (Ve = !0), (c.d.length = s + 1), c;
}
function eo(e, r) {
  for (var t = e; --r; ) t *= e;
  return t;
}
function tv(e, r) {
  var t,
    a = r.s < 0,
    n = gt(e, e.precision, 1),
    i = n.times(0.5);
  if (((r = r.abs()), r.lte(i))) return (Ht = a ? 4 : 1), r;
  if (((t = r.divToInt(n)), t.isZero())) Ht = a ? 3 : 2;
  else {
    if (((r = r.minus(t.times(n))), r.lte(i)))
      return (Ht = Zu(t) ? (a ? 2 : 3) : a ? 4 : 1), r;
    Ht = Zu(t) ? (a ? 1 : 4) : a ? 3 : 2;
  }
  return r.minus(n).abs();
}
function Js(e, r, t, a) {
  var n,
    i,
    c,
    m,
    f,
    u,
    s,
    o,
    l,
    p = e.constructor,
    v = t !== void 0;
  if (
    (v
      ? (rt(t, 1, yn), a === void 0 ? (a = p.rounding) : rt(a, 0, 8))
      : ((t = p.precision), (a = p.rounding)),
    !e.isFinite())
  )
    s = rv(e);
  else {
    for (
      s = Ft(e),
        c = s.indexOf("."),
        v
          ? ((n = 2), r == 16 ? (t = t * 4 - 3) : r == 8 && (t = t * 3 - 2))
          : (n = r),
        c >= 0 &&
          ((s = s.replace(".", "")),
          (l = new p(1)),
          (l.e = s.length - c),
          (l.d = Ai(Ft(l), 10, n)),
          (l.e = l.d.length)),
        o = Ai(s, 10, n),
        i = f = o.length;
      o[--f] == 0;

    )
      o.pop();
    if (!o[0]) s = v ? "0p+0" : "0";
    else {
      if (
        (c < 0
          ? i--
          : ((e = new p(e)),
            (e.d = o),
            (e.e = i),
            (e = yr(e, l, t, a, 0, n)),
            (o = e.d),
            (i = e.e),
            (u = Jp)),
        (c = o[t]),
        (m = n / 2),
        (u = u || o[t + 1] !== void 0),
        (u =
          a < 4
            ? (c !== void 0 || u) && (a === 0 || a === (e.s < 0 ? 3 : 2))
            : c > m ||
              (c === m &&
                (a === 4 ||
                  u ||
                  (a === 6 && o[t - 1] & 1) ||
                  a === (e.s < 0 ? 8 : 7)))),
        (o.length = t),
        u)
      )
        for (; ++o[--t] > n - 1; ) (o[t] = 0), t || (++i, o.unshift(1));
      for (f = o.length; !o[f - 1]; --f);
      for (c = 0, s = ""; c < f; c++) s += ps.charAt(o[c]);
      if (v) {
        if (f > 1)
          if (r == 16 || r == 8) {
            for (c = r == 16 ? 4 : 3, --f; f % c; f++) s += "0";
            for (o = Ai(s, n, r), f = o.length; !o[f - 1]; --f);
            for (c = 1, s = "1."; c < f; c++) s += ps.charAt(o[c]);
          } else s = s.charAt(0) + "." + s.slice(1);
        s = s + (i < 0 ? "p" : "p+") + i;
      } else if (i < 0) {
        for (; ++i; ) s = "0" + s;
        s = "0." + s;
      } else if (++i > f) for (i -= f; i--; ) s += "0";
      else i < f && (s = s.slice(0, i) + "." + s.slice(i));
    }
    s = (r == 16 ? "0x" : r == 2 ? "0b" : r == 8 ? "0o" : "") + s;
  }
  return e.s < 0 ? "-" + s : s;
}
function Ju(e, r) {
  if (e.length > r) return (e.length = r), !0;
}
function $1(e) {
  return new this(e).abs();
}
function O1(e) {
  return new this(e).acos();
}
function T1(e) {
  return new this(e).acosh();
}
function D1(e, r) {
  return new this(e).plus(r);
}
function B1(e) {
  return new this(e).asin();
}
function _1(e) {
  return new this(e).asinh();
}
function I1(e) {
  return new this(e).atan();
}
function R1(e) {
  return new this(e).atanh();
}
function F1(e, r) {
  (e = new this(e)), (r = new this(r));
  var t,
    a = this.precision,
    n = this.rounding,
    i = a + 4;
  return (
    !e.s || !r.s
      ? (t = new this(NaN))
      : !e.d && !r.d
      ? ((t = gt(this, i, 1).times(r.s > 0 ? 0.25 : 0.75)), (t.s = e.s))
      : !r.d || e.isZero()
      ? ((t = r.s < 0 ? gt(this, a, n) : new this(0)), (t.s = e.s))
      : !e.d || r.isZero()
      ? ((t = gt(this, i, 1).times(0.5)), (t.s = e.s))
      : r.s < 0
      ? ((this.precision = i),
        (this.rounding = 1),
        (t = this.atan(yr(e, r, i, 1))),
        (r = gt(this, i, 1)),
        (this.precision = a),
        (this.rounding = n),
        (t = e.s < 0 ? t.minus(r) : t.plus(r)))
      : (t = this.atan(yr(e, r, i, 1))),
    t
  );
}
function P1(e) {
  return new this(e).cbrt();
}
function q1(e) {
  return Ie((e = new this(e)), e.e + 1, 2);
}
function z1(e, r, t) {
  return new this(e).clamp(r, t);
}
function U1(e) {
  if (!e || typeof e != "object") throw Error(ji + "Object expected");
  var r,
    t,
    a,
    n = e.defaults === !0,
    i = [
      "precision",
      1,
      yn,
      "rounding",
      0,
      8,
      "toExpNeg",
      -ra,
      0,
      "toExpPos",
      0,
      ra,
      "maxE",
      0,
      ra,
      "minE",
      -ra,
      0,
      "modulo",
      0,
      9,
    ];
  for (r = 0; r < i.length; r += 3)
    if (((t = i[r]), n && (this[t] = vs[t]), (a = e[t]) !== void 0))
      if (Vr(a) === a && a >= i[r + 1] && a <= i[r + 2]) this[t] = a;
      else throw Error(hn + t + ": " + a);
  if (((t = "crypto"), n && (this[t] = vs[t]), (a = e[t]) !== void 0))
    if (a === !0 || a === !1 || a === 0 || a === 1)
      if (a)
        if (
          typeof crypto < "u" &&
          crypto &&
          (crypto.getRandomValues || crypto.randomBytes)
        )
          this[t] = !0;
        else throw Error(Xp);
      else this[t] = !1;
    else throw Error(hn + t + ": " + a);
  return this;
}
function L1(e) {
  return new this(e).cos();
}
function k1(e) {
  return new this(e).cosh();
}
function nv(e) {
  var r, t, a;
  function n(i) {
    var c,
      m,
      f,
      u = this;
    if (!(u instanceof n)) return new n(i);
    if (((u.constructor = n), Wu(i))) {
      (u.s = i.s),
        Ve
          ? !i.d || i.e > n.maxE
            ? ((u.e = NaN), (u.d = null))
            : i.e < n.minE
            ? ((u.e = 0), (u.d = [0]))
            : ((u.e = i.e), (u.d = i.d.slice()))
          : ((u.e = i.e), (u.d = i.d ? i.d.slice() : i.d));
      return;
    }
    if (((f = typeof i), f === "number")) {
      if (i === 0) {
        (u.s = 1 / i < 0 ? -1 : 1), (u.e = 0), (u.d = [0]);
        return;
      }
      if ((i < 0 ? ((i = -i), (u.s = -1)) : (u.s = 1), i === ~~i && i < 1e7)) {
        for (c = 0, m = i; m >= 10; m /= 10) c++;
        Ve
          ? c > n.maxE
            ? ((u.e = NaN), (u.d = null))
            : c < n.minE
            ? ((u.e = 0), (u.d = [0]))
            : ((u.e = c), (u.d = [i]))
          : ((u.e = c), (u.d = [i]));
        return;
      } else if (i * 0 !== 0) {
        i || (u.s = NaN), (u.e = NaN), (u.d = null);
        return;
      }
      return gs(u, i.toString());
    } else if (f !== "string") throw Error(hn + i);
    return (
      (m = i.charCodeAt(0)) === 45
        ? ((i = i.slice(1)), (u.s = -1))
        : (m === 43 && (i = i.slice(1)), (u.s = 1)),
      Qp.test(i) ? gs(u, i) : E1(u, i)
    );
  }
  if (
    ((n.prototype = ve),
    (n.ROUND_UP = 0),
    (n.ROUND_DOWN = 1),
    (n.ROUND_CEIL = 2),
    (n.ROUND_FLOOR = 3),
    (n.ROUND_HALF_UP = 4),
    (n.ROUND_HALF_DOWN = 5),
    (n.ROUND_HALF_EVEN = 6),
    (n.ROUND_HALF_CEIL = 7),
    (n.ROUND_HALF_FLOOR = 8),
    (n.EUCLID = 9),
    (n.config = n.set = U1),
    (n.clone = nv),
    (n.isDecimal = Wu),
    (n.abs = $1),
    (n.acos = O1),
    (n.acosh = T1),
    (n.add = D1),
    (n.asin = B1),
    (n.asinh = _1),
    (n.atan = I1),
    (n.atanh = R1),
    (n.atan2 = F1),
    (n.cbrt = P1),
    (n.ceil = q1),
    (n.clamp = z1),
    (n.cos = L1),
    (n.cosh = k1),
    (n.div = V1),
    (n.exp = G1),
    (n.floor = H1),
    (n.hypot = Z1),
    (n.ln = J1),
    (n.log = W1),
    (n.log10 = Y1),
    (n.log2 = X1),
    (n.max = Q1),
    (n.min = j1),
    (n.mod = K1),
    (n.mul = eb),
    (n.pow = rb),
    (n.random = tb),
    (n.round = nb),
    (n.sign = ab),
    (n.sin = ib),
    (n.sinh = ob),
    (n.sqrt = sb),
    (n.sub = ub),
    (n.sum = lb),
    (n.tan = cb),
    (n.tanh = fb),
    (n.trunc = mb),
    e === void 0 && (e = {}),
    e && e.defaults !== !0)
  )
    for (
      a = [
        "precision",
        "rounding",
        "toExpNeg",
        "toExpPos",
        "maxE",
        "minE",
        "modulo",
        "crypto",
      ],
        r = 0;
      r < a.length;

    )
      e.hasOwnProperty((t = a[r++])) || (e[t] = this[t]);
  return n.config(e), n;
}
function V1(e, r) {
  return new this(e).div(r);
}
function G1(e) {
  return new this(e).exp();
}
function H1(e) {
  return Ie((e = new this(e)), e.e + 1, 3);
}
function Z1() {
  var e,
    r,
    t = new this(0);
  for (Ve = !1, e = 0; e < arguments.length; )
    if (((r = new this(arguments[e++])), r.d)) t.d && (t = t.plus(r.times(r)));
    else {
      if (r.s) return (Ve = !0), new this(1 / 0);
      t = r;
    }
  return (Ve = !0), t.sqrt();
}
function Wu(e) {
  return e instanceof dn || (e && e.toStringTag === Yp) || !1;
}
function J1(e) {
  return new this(e).ln();
}
function W1(e, r) {
  return new this(e).log(r);
}
function X1(e) {
  return new this(e).log(2);
}
function Y1(e) {
  return new this(e).log(10);
}
function Q1() {
  return ev(this, arguments, "lt");
}
function j1() {
  return ev(this, arguments, "gt");
}
function K1(e, r) {
  return new this(e).mod(r);
}
function eb(e, r) {
  return new this(e).mul(r);
}
function rb(e, r) {
  return new this(e).pow(r);
}
function tb(e) {
  var r,
    t,
    a,
    n,
    i = 0,
    c = new this(1),
    m = [];
  if (
    (e === void 0 ? (e = this.precision) : rt(e, 1, yn),
    (a = Math.ceil(e / qe)),
    this.crypto)
  )
    if (crypto.getRandomValues)
      for (r = crypto.getRandomValues(new Uint32Array(a)); i < a; )
        (n = r[i]),
          n >= 429e7
            ? (r[i] = crypto.getRandomValues(new Uint32Array(1))[0])
            : (m[i++] = n % 1e7);
    else if (crypto.randomBytes) {
      for (r = crypto.randomBytes((a *= 4)); i < a; )
        (n =
          r[i] + (r[i + 1] << 8) + (r[i + 2] << 16) + ((r[i + 3] & 127) << 24)),
          n >= 214e7
            ? crypto.randomBytes(4).copy(r, i)
            : (m.push(n % 1e7), (i += 4));
      i = a / 4;
    } else throw Error(Xp);
  else for (; i < a; ) m[i++] = (Math.random() * 1e7) | 0;
  for (
    a = m[--i],
      e %= qe,
      a && e && ((n = Br(10, qe - e)), (m[i] = ((a / n) | 0) * n));
    m[i] === 0;
    i--
  )
    m.pop();
  if (i < 0) (t = 0), (m = [0]);
  else {
    for (t = -1; m[0] === 0; t -= qe) m.shift();
    for (a = 1, n = m[0]; n >= 10; n /= 10) a++;
    a < qe && (t -= qe - a);
  }
  return (c.e = t), (c.d = m), c;
}
function nb(e) {
  return Ie((e = new this(e)), e.e + 1, this.rounding);
}
function ab(e) {
  return (e = new this(e)), e.d ? (e.d[0] ? e.s : 0 * e.s) : e.s || NaN;
}
function ib(e) {
  return new this(e).sin();
}
function ob(e) {
  return new this(e).sinh();
}
function sb(e) {
  return new this(e).sqrt();
}
function ub(e, r) {
  return new this(e).sub(r);
}
function lb() {
  var e = 0,
    r = arguments,
    t = new this(r[e]);
  for (Ve = !1; t.s && ++e < r.length; ) t = t.plus(r[e]);
  return (Ve = !0), Ie(t, this.precision, this.rounding);
}
function cb(e) {
  return new this(e).tan();
}
function fb(e) {
  return new this(e).tanh();
}
function mb(e) {
  return Ie((e = new this(e)), e.e + 1, 1);
}
ve[Symbol.for("nodejs.util.inspect.custom")] = ve.toString;
ve[Symbol.toStringTag] = "Decimal";
var dn = (ve.constructor = nv(vs));
Bi = new dn(Bi);
_i = new dn(_i);
var pb = "BigNumber",
  vb = ["?on", "config"],
  hb = P(
    pb,
    vb,
    (e) => {
      var { on: r, config: t } = e,
        a = dn.clone({ precision: t.precision, modulo: dn.EUCLID });
      return (
        (a.prototype = Object.create(a.prototype)),
        (a.prototype.type = "BigNumber"),
        (a.prototype.isBigNumber = !0),
        (a.prototype.toJSON = function () {
          return { mathjs: "BigNumber", value: this.toString() };
        }),
        (a.fromJSON = function (n) {
          return new a(n.value);
        }),
        r &&
          r("config", function (n, i) {
            n.precision !== i.precision && a.config({ precision: n.precision });
          }),
        a
      );
    },
    { isClass: !0 }
  ),
  av = { exports: {} };
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/ (function (e, r) {
  (function (t) {
    var a =
        Math.cosh ||
        function (o) {
          return Math.abs(o) < 1e-9
            ? 1 - o
            : (Math.exp(o) + Math.exp(-o)) * 0.5;
        },
      n =
        Math.sinh ||
        function (o) {
          return Math.abs(o) < 1e-9 ? o : (Math.exp(o) - Math.exp(-o)) * 0.5;
        },
      i = function (o) {
        var l = Math.PI / 4;
        if (-l > o || o > l) return Math.cos(o) - 1;
        var p = o * o;
        return (
          p *
          (p *
            (p *
              (p *
                (p *
                  (p *
                    (p * (p / 20922789888e3 - 1 / 87178291200) +
                      1 / 479001600) -
                    1 / 3628800) +
                  1 / 40320) -
                1 / 720) +
              1 / 24) -
            1 / 2)
        );
      },
      c = function (o, l) {
        var p = Math.abs(o),
          v = Math.abs(l);
        return p < 3e3 && v < 3e3
          ? Math.sqrt(p * p + v * v)
          : (p < v ? ((p = v), (v = o / l)) : (v = l / o),
            p * Math.sqrt(1 + v * v));
      },
      m = function () {
        throw SyntaxError("Invalid Param");
      };
    function f(o, l) {
      var p = Math.abs(o),
        v = Math.abs(l);
      return o === 0
        ? Math.log(v)
        : l === 0
        ? Math.log(p)
        : p < 3e3 && v < 3e3
        ? Math.log(o * o + l * l) * 0.5
        : ((o = o / 2), (l = l / 2), 0.5 * Math.log(o * o + l * l) + Math.LN2);
    }
    var u = function (o, l) {
      var p = { re: 0, im: 0 };
      if (o == null) p.re = p.im = 0;
      else if (l !== void 0) (p.re = o), (p.im = l);
      else
        switch (typeof o) {
          case "object":
            if ("im" in o && "re" in o) (p.re = o.re), (p.im = o.im);
            else if ("abs" in o && "arg" in o) {
              if (!Number.isFinite(o.abs) && Number.isFinite(o.arg))
                return s.INFINITY;
              (p.re = o.abs * Math.cos(o.arg)),
                (p.im = o.abs * Math.sin(o.arg));
            } else if ("r" in o && "phi" in o) {
              if (!Number.isFinite(o.r) && Number.isFinite(o.phi))
                return s.INFINITY;
              (p.re = o.r * Math.cos(o.phi)), (p.im = o.r * Math.sin(o.phi));
            } else o.length === 2 ? ((p.re = o[0]), (p.im = o[1])) : m();
            break;
          case "string":
            p.im = p.re = 0;
            var v = o.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),
              h = 1,
              x = 0;
            v === null && m();
            for (var b = 0; b < v.length; b++) {
              var N = v[b];
              N === " " ||
                N === "	" ||
                N ===
                  `
` ||
                (N === "+"
                  ? h++
                  : N === "-"
                  ? x++
                  : N === "i" || N === "I"
                  ? (h + x === 0 && m(),
                    v[b + 1] !== " " && !isNaN(v[b + 1])
                      ? ((p.im += parseFloat((x % 2 ? "-" : "") + v[b + 1])),
                        b++)
                      : (p.im += parseFloat((x % 2 ? "-" : "") + "1")),
                    (h = x = 0))
                  : ((h + x === 0 || isNaN(N)) && m(),
                    v[b + 1] === "i" || v[b + 1] === "I"
                      ? ((p.im += parseFloat((x % 2 ? "-" : "") + N)), b++)
                      : (p.re += parseFloat((x % 2 ? "-" : "") + N)),
                    (h = x = 0)));
            }
            h + x > 0 && m();
            break;
          case "number":
            (p.im = 0), (p.re = o);
            break;
          default:
            m();
        }
      return isNaN(p.re) || isNaN(p.im), p;
    };
    function s(o, l) {
      if (!(this instanceof s)) return new s(o, l);
      var p = u(o, l);
      (this.re = p.re), (this.im = p.im);
    }
    (s.prototype = {
      re: 0,
      im: 0,
      sign: function () {
        var o = this.abs();
        return new s(this.re / o, this.im / o);
      },
      add: function (o, l) {
        var p = new s(o, l);
        return this.isInfinite() && p.isInfinite()
          ? s.NAN
          : this.isInfinite() || p.isInfinite()
          ? s.INFINITY
          : new s(this.re + p.re, this.im + p.im);
      },
      sub: function (o, l) {
        var p = new s(o, l);
        return this.isInfinite() && p.isInfinite()
          ? s.NAN
          : this.isInfinite() || p.isInfinite()
          ? s.INFINITY
          : new s(this.re - p.re, this.im - p.im);
      },
      mul: function (o, l) {
        var p = new s(o, l);
        return (this.isInfinite() && p.isZero()) ||
          (this.isZero() && p.isInfinite())
          ? s.NAN
          : this.isInfinite() || p.isInfinite()
          ? s.INFINITY
          : p.im === 0 && this.im === 0
          ? new s(this.re * p.re, 0)
          : new s(
              this.re * p.re - this.im * p.im,
              this.re * p.im + this.im * p.re
            );
      },
      div: function (o, l) {
        var p = new s(o, l);
        if (
          (this.isZero() && p.isZero()) ||
          (this.isInfinite() && p.isInfinite())
        )
          return s.NAN;
        if (this.isInfinite() || p.isZero()) return s.INFINITY;
        if (this.isZero() || p.isInfinite()) return s.ZERO;
        (o = this.re), (l = this.im);
        var v = p.re,
          h = p.im,
          x,
          b;
        return h === 0
          ? new s(o / v, l / v)
          : Math.abs(v) < Math.abs(h)
          ? ((b = v / h),
            (x = v * b + h),
            new s((o * b + l) / x, (l * b - o) / x))
          : ((b = h / v),
            (x = h * b + v),
            new s((o + l * b) / x, (l - o * b) / x));
      },
      pow: function (o, l) {
        var p = new s(o, l);
        if (((o = this.re), (l = this.im), p.isZero())) return s.ONE;
        if (p.im === 0) {
          if (l === 0 && o > 0) return new s(Math.pow(o, p.re), 0);
          if (o === 0)
            switch (((p.re % 4) + 4) % 4) {
              case 0:
                return new s(Math.pow(l, p.re), 0);
              case 1:
                return new s(0, Math.pow(l, p.re));
              case 2:
                return new s(-Math.pow(l, p.re), 0);
              case 3:
                return new s(0, -Math.pow(l, p.re));
            }
        }
        if (o === 0 && l === 0 && p.re > 0 && p.im >= 0) return s.ZERO;
        var v = Math.atan2(l, o),
          h = f(o, l);
        return (
          (o = Math.exp(p.re * h - p.im * v)),
          (l = p.im * h + p.re * v),
          new s(o * Math.cos(l), o * Math.sin(l))
        );
      },
      sqrt: function () {
        var o = this.re,
          l = this.im,
          p = this.abs(),
          v,
          h;
        if (o >= 0) {
          if (l === 0) return new s(Math.sqrt(o), 0);
          v = 0.5 * Math.sqrt(2 * (p + o));
        } else v = Math.abs(l) / Math.sqrt(2 * (p - o));
        return (
          o <= 0
            ? (h = 0.5 * Math.sqrt(2 * (p - o)))
            : (h = Math.abs(l) / Math.sqrt(2 * (p + o))),
          new s(v, l < 0 ? -h : h)
        );
      },
      exp: function () {
        var o = Math.exp(this.re);
        return this.im, new s(o * Math.cos(this.im), o * Math.sin(this.im));
      },
      expm1: function () {
        var o = this.re,
          l = this.im;
        return new s(
          Math.expm1(o) * Math.cos(l) + i(l),
          Math.exp(o) * Math.sin(l)
        );
      },
      log: function () {
        var o = this.re,
          l = this.im;
        return new s(f(o, l), Math.atan2(l, o));
      },
      abs: function () {
        return c(this.re, this.im);
      },
      arg: function () {
        return Math.atan2(this.im, this.re);
      },
      sin: function () {
        var o = this.re,
          l = this.im;
        return new s(Math.sin(o) * a(l), Math.cos(o) * n(l));
      },
      cos: function () {
        var o = this.re,
          l = this.im;
        return new s(Math.cos(o) * a(l), -Math.sin(o) * n(l));
      },
      tan: function () {
        var o = 2 * this.re,
          l = 2 * this.im,
          p = Math.cos(o) + a(l);
        return new s(Math.sin(o) / p, n(l) / p);
      },
      cot: function () {
        var o = 2 * this.re,
          l = 2 * this.im,
          p = Math.cos(o) - a(l);
        return new s(-Math.sin(o) / p, n(l) / p);
      },
      sec: function () {
        var o = this.re,
          l = this.im,
          p = 0.5 * a(2 * l) + 0.5 * Math.cos(2 * o);
        return new s((Math.cos(o) * a(l)) / p, (Math.sin(o) * n(l)) / p);
      },
      csc: function () {
        var o = this.re,
          l = this.im,
          p = 0.5 * a(2 * l) - 0.5 * Math.cos(2 * o);
        return new s((Math.sin(o) * a(l)) / p, (-Math.cos(o) * n(l)) / p);
      },
      asin: function () {
        var o = this.re,
          l = this.im,
          p = new s(l * l - o * o + 1, -2 * o * l).sqrt(),
          v = new s(p.re - l, p.im + o).log();
        return new s(v.im, -v.re);
      },
      acos: function () {
        var o = this.re,
          l = this.im,
          p = new s(l * l - o * o + 1, -2 * o * l).sqrt(),
          v = new s(p.re - l, p.im + o).log();
        return new s(Math.PI / 2 - v.im, v.re);
      },
      atan: function () {
        var o = this.re,
          l = this.im;
        if (o === 0) {
          if (l === 1) return new s(0, 1 / 0);
          if (l === -1) return new s(0, -1 / 0);
        }
        var p = o * o + (1 - l) * (1 - l),
          v = new s((1 - l * l - o * o) / p, (-2 * o) / p).log();
        return new s(-0.5 * v.im, 0.5 * v.re);
      },
      acot: function () {
        var o = this.re,
          l = this.im;
        if (l === 0) return new s(Math.atan2(1, o), 0);
        var p = o * o + l * l;
        return p !== 0
          ? new s(o / p, -l / p).atan()
          : new s(o !== 0 ? o / 0 : 0, l !== 0 ? -l / 0 : 0).atan();
      },
      asec: function () {
        var o = this.re,
          l = this.im;
        if (o === 0 && l === 0) return new s(0, 1 / 0);
        var p = o * o + l * l;
        return p !== 0
          ? new s(o / p, -l / p).acos()
          : new s(o !== 0 ? o / 0 : 0, l !== 0 ? -l / 0 : 0).acos();
      },
      acsc: function () {
        var o = this.re,
          l = this.im;
        if (o === 0 && l === 0) return new s(Math.PI / 2, 1 / 0);
        var p = o * o + l * l;
        return p !== 0
          ? new s(o / p, -l / p).asin()
          : new s(o !== 0 ? o / 0 : 0, l !== 0 ? -l / 0 : 0).asin();
      },
      sinh: function () {
        var o = this.re,
          l = this.im;
        return new s(n(o) * Math.cos(l), a(o) * Math.sin(l));
      },
      cosh: function () {
        var o = this.re,
          l = this.im;
        return new s(a(o) * Math.cos(l), n(o) * Math.sin(l));
      },
      tanh: function () {
        var o = 2 * this.re,
          l = 2 * this.im,
          p = a(o) + Math.cos(l);
        return new s(n(o) / p, Math.sin(l) / p);
      },
      coth: function () {
        var o = 2 * this.re,
          l = 2 * this.im,
          p = a(o) - Math.cos(l);
        return new s(n(o) / p, -Math.sin(l) / p);
      },
      csch: function () {
        var o = this.re,
          l = this.im,
          p = Math.cos(2 * l) - a(2 * o);
        return new s(
          (-2 * n(o) * Math.cos(l)) / p,
          (2 * a(o) * Math.sin(l)) / p
        );
      },
      sech: function () {
        var o = this.re,
          l = this.im,
          p = Math.cos(2 * l) + a(2 * o);
        return new s(
          (2 * a(o) * Math.cos(l)) / p,
          (-2 * n(o) * Math.sin(l)) / p
        );
      },
      asinh: function () {
        var o = this.im;
        (this.im = -this.re), (this.re = o);
        var l = this.asin();
        return (
          (this.re = -this.im),
          (this.im = o),
          (o = l.re),
          (l.re = -l.im),
          (l.im = o),
          l
        );
      },
      acosh: function () {
        var o = this.acos();
        if (o.im <= 0) {
          var l = o.re;
          (o.re = -o.im), (o.im = l);
        } else {
          var l = o.im;
          (o.im = -o.re), (o.re = l);
        }
        return o;
      },
      atanh: function () {
        var o = this.re,
          l = this.im,
          p = o > 1 && l === 0,
          v = 1 - o,
          h = 1 + o,
          x = v * v + l * l,
          b =
            x !== 0
              ? new s((h * v - l * l) / x, (l * v + h * l) / x)
              : new s(o !== -1 ? o / 0 : 0, l !== 0 ? l / 0 : 0),
          N = b.re;
        return (
          (b.re = f(b.re, b.im) / 2),
          (b.im = Math.atan2(b.im, N) / 2),
          p && (b.im = -b.im),
          b
        );
      },
      acoth: function () {
        var o = this.re,
          l = this.im;
        if (o === 0 && l === 0) return new s(0, Math.PI / 2);
        var p = o * o + l * l;
        return p !== 0
          ? new s(o / p, -l / p).atanh()
          : new s(o !== 0 ? o / 0 : 0, l !== 0 ? -l / 0 : 0).atanh();
      },
      acsch: function () {
        var o = this.re,
          l = this.im;
        if (l === 0)
          return new s(o !== 0 ? Math.log(o + Math.sqrt(o * o + 1)) : 1 / 0, 0);
        var p = o * o + l * l;
        return p !== 0
          ? new s(o / p, -l / p).asinh()
          : new s(o !== 0 ? o / 0 : 0, l !== 0 ? -l / 0 : 0).asinh();
      },
      asech: function () {
        var o = this.re,
          l = this.im;
        if (this.isZero()) return s.INFINITY;
        var p = o * o + l * l;
        return p !== 0
          ? new s(o / p, -l / p).acosh()
          : new s(o !== 0 ? o / 0 : 0, l !== 0 ? -l / 0 : 0).acosh();
      },
      inverse: function () {
        if (this.isZero()) return s.INFINITY;
        if (this.isInfinite()) return s.ZERO;
        var o = this.re,
          l = this.im,
          p = o * o + l * l;
        return new s(o / p, -l / p);
      },
      conjugate: function () {
        return new s(this.re, -this.im);
      },
      neg: function () {
        return new s(-this.re, -this.im);
      },
      ceil: function (o) {
        return (
          (o = Math.pow(10, o || 0)),
          new s(Math.ceil(this.re * o) / o, Math.ceil(this.im * o) / o)
        );
      },
      floor: function (o) {
        return (
          (o = Math.pow(10, o || 0)),
          new s(Math.floor(this.re * o) / o, Math.floor(this.im * o) / o)
        );
      },
      round: function (o) {
        return (
          (o = Math.pow(10, o || 0)),
          new s(Math.round(this.re * o) / o, Math.round(this.im * o) / o)
        );
      },
      equals: function (o, l) {
        var p = new s(o, l);
        return (
          Math.abs(p.re - this.re) <= s.EPSILON &&
          Math.abs(p.im - this.im) <= s.EPSILON
        );
      },
      clone: function () {
        return new s(this.re, this.im);
      },
      toString: function () {
        var o = this.re,
          l = this.im,
          p = "";
        return this.isNaN()
          ? "NaN"
          : this.isInfinite()
          ? "Infinity"
          : (Math.abs(o) < s.EPSILON && (o = 0),
            Math.abs(l) < s.EPSILON && (l = 0),
            l === 0
              ? p + o
              : (o !== 0
                  ? ((p += o),
                    (p += " "),
                    l < 0 ? ((l = -l), (p += "-")) : (p += "+"),
                    (p += " "))
                  : l < 0 && ((l = -l), (p += "-")),
                l !== 1 && (p += l),
                p + "i"));
      },
      toVector: function () {
        return [this.re, this.im];
      },
      valueOf: function () {
        return this.im === 0 ? this.re : null;
      },
      isNaN: function () {
        return isNaN(this.re) || isNaN(this.im);
      },
      isZero: function () {
        return this.im === 0 && this.re === 0;
      },
      isFinite: function () {
        return isFinite(this.re) && isFinite(this.im);
      },
      isInfinite: function () {
        return !(this.isNaN() || this.isFinite());
      },
    }),
      (s.ZERO = new s(0, 0)),
      (s.ONE = new s(1, 0)),
      (s.I = new s(0, 1)),
      (s.PI = new s(Math.PI, 0)),
      (s.E = new s(Math.E, 0)),
      (s.INFINITY = new s(1 / 0, 1 / 0)),
      (s.NAN = new s(NaN, NaN)),
      (s.EPSILON = 1e-15),
      Object.defineProperty(s, "__esModule", { value: !0 }),
      (s.default = s),
      (s.Complex = s),
      (e.exports = s);
  })();
})(av);
var db = av.exports;
const jr = pa(db);
var gb = "Complex",
  yb = [],
  bb = P(
    gb,
    yb,
    () => (
      (jr.prototype.type = "Complex"),
      (jr.prototype.isComplex = !0),
      (jr.prototype.toJSON = function () {
        return { mathjs: "Complex", re: this.re, im: this.im };
      }),
      (jr.prototype.toPolar = function () {
        return { r: this.abs(), phi: this.arg() };
      }),
      (jr.prototype.format = function (e) {
        var r = "",
          t = this.im,
          a = this.re,
          n = Sn(this.re, e),
          i = Sn(this.im, e),
          c = je(e) ? e : e ? e.precision : null;
        if (c !== null) {
          var m = Math.pow(10, -c);
          Math.abs(a / t) < m && (a = 0), Math.abs(t / a) < m && (t = 0);
        }
        return (
          t === 0
            ? (r = n)
            : a === 0
            ? t === 1
              ? (r = "i")
              : t === -1
              ? (r = "-i")
              : (r = i + "i")
            : t < 0
            ? t === -1
              ? (r = n + " - i")
              : (r = n + " - " + i.substring(1) + "i")
            : t === 1
            ? (r = n + " + i")
            : (r = n + " + " + i + "i"),
          r
        );
      }),
      (jr.fromPolar = function (e) {
        switch (arguments.length) {
          case 1: {
            var r = arguments[0];
            if (typeof r == "object") return jr(r);
            throw new TypeError(
              "Input has to be an object with r and phi keys."
            );
          }
          case 2: {
            var t = arguments[0],
              a = arguments[1];
            if (je(t)) {
              if (
                (Ha(a) && a.hasBase("ANGLE") && (a = a.toNumber("rad")), je(a))
              )
                return new jr({ r: t, phi: a });
              throw new TypeError("Phi is not a number nor an angle unit.");
            } else throw new TypeError("Radius r is not a number.");
          }
          default:
            throw new SyntaxError(
              "Wrong number of arguments in function fromPolar"
            );
        }
      }),
      (jr.prototype.valueOf = jr.prototype.toString),
      (jr.fromJSON = function (e) {
        return new jr(e);
      }),
      (jr.compare = function (e, r) {
        return e.re > r.re
          ? 1
          : e.re < r.re
          ? -1
          : e.im > r.im
          ? 1
          : e.im < r.im
          ? -1
          : 0;
      }),
      jr
    ),
    { isClass: !0 }
  ),
  iv = { exports: {} };
/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/ (function (e, r) {
  (function (t) {
    var a = 2e3,
      n = { s: 1, n: 0, d: 1 };
    function i(v, h) {
      if (isNaN((v = parseInt(v, 10)))) throw p.InvalidParameter;
      return v * h;
    }
    function c(v, h) {
      if (h === 0) throw p.DivisionByZero;
      var x = Object.create(p.prototype);
      (x.s = v < 0 ? -1 : 1), (v = v < 0 ? -v : v);
      var b = l(v, h);
      return (x.n = v / b), (x.d = h / b), x;
    }
    function m(v) {
      for (var h = {}, x = v, b = 2, N = 4; N <= x; ) {
        for (; x % b === 0; ) (x /= b), (h[b] = (h[b] || 0) + 1);
        N += 1 + 2 * b++;
      }
      return (
        x !== v ? x > 1 && (h[x] = (h[x] || 0) + 1) : (h[v] = (h[v] || 0) + 1),
        h
      );
    }
    var f = function (v, h) {
      var x = 0,
        b = 1,
        N = 1,
        d = 0,
        y = 0,
        w = 0,
        g = 1,
        S = 1,
        A = 0,
        E = 1,
        M = 1,
        B = 1,
        C = 1e7,
        _;
      if (v != null)
        if (h !== void 0) {
          if (((x = v), (b = h), (N = x * b), x % 1 !== 0 || b % 1 !== 0))
            throw p.NonIntegerParameter;
        } else
          switch (typeof v) {
            case "object": {
              if ("d" in v && "n" in v)
                (x = v.n), (b = v.d), "s" in v && (x *= v.s);
              else if (0 in v) (x = v[0]), 1 in v && (b = v[1]);
              else throw p.InvalidParameter;
              N = x * b;
              break;
            }
            case "number": {
              if ((v < 0 && ((N = v), (v = -v)), v % 1 === 0)) x = v;
              else if (v > 0) {
                for (
                  v >= 1 &&
                  ((S = Math.pow(10, Math.floor(1 + Math.log(v) / Math.LN10))),
                  (v /= S));
                  E <= C && B <= C;

                )
                  if (((_ = (A + M) / (E + B)), v === _)) {
                    E + B <= C
                      ? ((x = A + M), (b = E + B))
                      : B > E
                      ? ((x = M), (b = B))
                      : ((x = A), (b = E));
                    break;
                  } else
                    v > _ ? ((A += M), (E += B)) : ((M += A), (B += E)),
                      E > C ? ((x = M), (b = B)) : ((x = A), (b = E));
                x *= S;
              } else (isNaN(v) || isNaN(h)) && (b = x = NaN);
              break;
            }
            case "string": {
              if (((E = v.match(/\d+|./g)), E === null))
                throw p.InvalidParameter;
              if (
                (E[A] === "-" ? ((N = -1), A++) : E[A] === "+" && A++,
                E.length === A + 1
                  ? (y = i(E[A++], N))
                  : E[A + 1] === "." || E[A] === "."
                  ? (E[A] !== "." && (d = i(E[A++], N)),
                    A++,
                    (A + 1 === E.length ||
                      (E[A + 1] === "(" && E[A + 3] === ")") ||
                      (E[A + 1] === "'" && E[A + 3] === "'")) &&
                      ((y = i(E[A], N)), (g = Math.pow(10, E[A].length)), A++),
                    ((E[A] === "(" && E[A + 2] === ")") ||
                      (E[A] === "'" && E[A + 2] === "'")) &&
                      ((w = i(E[A + 1], N)),
                      (S = Math.pow(10, E[A + 1].length) - 1),
                      (A += 3)))
                  : E[A + 1] === "/" || E[A + 1] === ":"
                  ? ((y = i(E[A], N)), (g = i(E[A + 2], 1)), (A += 3))
                  : E[A + 3] === "/" &&
                    E[A + 1] === " " &&
                    ((d = i(E[A], N)),
                    (y = i(E[A + 2], N)),
                    (g = i(E[A + 4], 1)),
                    (A += 5)),
                E.length <= A)
              ) {
                (b = g * S), (N = x = w + b * d + S * y);
                break;
              }
            }
            default:
              throw p.InvalidParameter;
          }
      if (b === 0) throw p.DivisionByZero;
      (n.s = N < 0 ? -1 : 1), (n.n = Math.abs(x)), (n.d = Math.abs(b));
    };
    function u(v, h, x) {
      for (var b = 1; h > 0; v = (v * v) % x, h >>= 1)
        h & 1 && (b = (b * v) % x);
      return b;
    }
    function s(v, h) {
      for (; h % 2 === 0; h /= 2);
      for (; h % 5 === 0; h /= 5);
      if (h === 1) return 0;
      for (var x = 10 % h, b = 1; x !== 1; b++)
        if (((x = (x * 10) % h), b > a)) return 0;
      return b;
    }
    function o(v, h, x) {
      for (var b = 1, N = u(10, x, h), d = 0; d < 300; d++) {
        if (b === N) return d;
        (b = (b * 10) % h), (N = (N * 10) % h);
      }
      return 0;
    }
    function l(v, h) {
      if (!v) return h;
      if (!h) return v;
      for (;;) {
        if (((v %= h), !v)) return h;
        if (((h %= v), !h)) return v;
      }
    }
    function p(v, h) {
      if ((f(v, h), this instanceof p))
        (v = l(n.d, n.n)),
          (this.s = n.s),
          (this.n = n.n / v),
          (this.d = n.d / v);
      else return c(n.s * n.n, n.d);
    }
    (p.DivisionByZero = new Error("Division by Zero")),
      (p.InvalidParameter = new Error("Invalid argument")),
      (p.NonIntegerParameter = new Error("Parameters must be integer")),
      (p.prototype = {
        s: 1,
        n: 0,
        d: 1,
        abs: function () {
          return c(this.n, this.d);
        },
        neg: function () {
          return c(-this.s * this.n, this.d);
        },
        add: function (v, h) {
          return (
            f(v, h), c(this.s * this.n * n.d + n.s * this.d * n.n, this.d * n.d)
          );
        },
        sub: function (v, h) {
          return (
            f(v, h), c(this.s * this.n * n.d - n.s * this.d * n.n, this.d * n.d)
          );
        },
        mul: function (v, h) {
          return f(v, h), c(this.s * n.s * this.n * n.n, this.d * n.d);
        },
        div: function (v, h) {
          return f(v, h), c(this.s * n.s * this.n * n.d, this.d * n.n);
        },
        clone: function () {
          return c(this.s * this.n, this.d);
        },
        mod: function (v, h) {
          if (isNaN(this.n) || isNaN(this.d)) return new p(NaN);
          if (v === void 0) return c((this.s * this.n) % this.d, 1);
          if ((f(v, h), n.n === 0 && this.d === 0)) throw p.DivisionByZero;
          return c((this.s * (n.d * this.n)) % (n.n * this.d), n.d * this.d);
        },
        gcd: function (v, h) {
          return f(v, h), c(l(n.n, this.n) * l(n.d, this.d), n.d * this.d);
        },
        lcm: function (v, h) {
          return (
            f(v, h),
            n.n === 0 && this.n === 0
              ? c(0, 1)
              : c(n.n * this.n, l(n.n, this.n) * l(n.d, this.d))
          );
        },
        ceil: function (v) {
          return (
            (v = Math.pow(10, v || 0)),
            isNaN(this.n) || isNaN(this.d)
              ? new p(NaN)
              : c(Math.ceil((v * this.s * this.n) / this.d), v)
          );
        },
        floor: function (v) {
          return (
            (v = Math.pow(10, v || 0)),
            isNaN(this.n) || isNaN(this.d)
              ? new p(NaN)
              : c(Math.floor((v * this.s * this.n) / this.d), v)
          );
        },
        round: function (v) {
          return (
            (v = Math.pow(10, v || 0)),
            isNaN(this.n) || isNaN(this.d)
              ? new p(NaN)
              : c(Math.round((v * this.s * this.n) / this.d), v)
          );
        },
        inverse: function () {
          return c(this.s * this.d, this.n);
        },
        pow: function (v, h) {
          if ((f(v, h), n.d === 1))
            return n.s < 0
              ? c(Math.pow(this.s * this.d, n.n), Math.pow(this.n, n.n))
              : c(Math.pow(this.s * this.n, n.n), Math.pow(this.d, n.n));
          if (this.s < 0) return null;
          var x = m(this.n),
            b = m(this.d),
            N = 1,
            d = 1;
          for (var y in x)
            if (y !== "1") {
              if (y === "0") {
                N = 0;
                break;
              }
              if (((x[y] *= n.n), x[y] % n.d === 0)) x[y] /= n.d;
              else return null;
              N *= Math.pow(y, x[y]);
            }
          for (var y in b)
            if (y !== "1") {
              if (((b[y] *= n.n), b[y] % n.d === 0)) b[y] /= n.d;
              else return null;
              d *= Math.pow(y, b[y]);
            }
          return n.s < 0 ? c(d, N) : c(N, d);
        },
        equals: function (v, h) {
          return f(v, h), this.s * this.n * n.d === n.s * n.n * this.d;
        },
        compare: function (v, h) {
          f(v, h);
          var x = this.s * this.n * n.d - n.s * n.n * this.d;
          return (0 < x) - (x < 0);
        },
        simplify: function (v) {
          if (isNaN(this.n) || isNaN(this.d)) return this;
          v = v || 0.001;
          for (
            var h = this.abs(), x = h.toContinued(), b = 1;
            b < x.length;
            b++
          ) {
            for (var N = c(x[b - 1], 1), d = b - 2; d >= 0; d--)
              N = N.inverse().add(x[d]);
            if (N.sub(h).abs().valueOf() < v) return N.mul(this.s);
          }
          return this;
        },
        divisible: function (v, h) {
          return f(v, h), !(!(n.n * this.d) || (this.n * n.d) % (n.n * this.d));
        },
        valueOf: function () {
          return (this.s * this.n) / this.d;
        },
        toFraction: function (v) {
          var h,
            x = "",
            b = this.n,
            N = this.d;
          return (
            this.s < 0 && (x += "-"),
            N === 1
              ? (x += b)
              : (v &&
                  (h = Math.floor(b / N)) > 0 &&
                  ((x += h), (x += " "), (b %= N)),
                (x += b),
                (x += "/"),
                (x += N)),
            x
          );
        },
        toLatex: function (v) {
          var h,
            x = "",
            b = this.n,
            N = this.d;
          return (
            this.s < 0 && (x += "-"),
            N === 1
              ? (x += b)
              : (v && (h = Math.floor(b / N)) > 0 && ((x += h), (b %= N)),
                (x += "\\frac{"),
                (x += b),
                (x += "}{"),
                (x += N),
                (x += "}")),
            x
          );
        },
        toContinued: function () {
          var v,
            h = this.n,
            x = this.d,
            b = [];
          if (isNaN(h) || isNaN(x)) return b;
          do b.push(Math.floor(h / x)), (v = h % x), (h = x), (x = v);
          while (h !== 1);
          return b;
        },
        toString: function (v) {
          var h = this.n,
            x = this.d;
          if (isNaN(h) || isNaN(x)) return "NaN";
          v = v || 15;
          var b = s(h, x),
            N = o(h, x, b),
            d = this.s < 0 ? "-" : "";
          if (((d += (h / x) | 0), (h %= x), (h *= 10), h && (d += "."), b)) {
            for (var y = N; y--; ) (d += (h / x) | 0), (h %= x), (h *= 10);
            d += "(";
            for (var y = b; y--; ) (d += (h / x) | 0), (h %= x), (h *= 10);
            d += ")";
          } else
            for (var y = v; h && y--; ) (d += (h / x) | 0), (h %= x), (h *= 10);
          return d;
        },
      }),
      Object.defineProperty(p, "__esModule", { value: !0 }),
      (p.default = p),
      (p.Fraction = p),
      (e.exports = p);
  })();
})(iv);
var xb = iv.exports;
const Wn = pa(xb);
var wb = "Fraction",
  Nb = [],
  Mb = P(
    wb,
    Nb,
    () => (
      (Wn.prototype.type = "Fraction"),
      (Wn.prototype.isFraction = !0),
      (Wn.prototype.toJSON = function () {
        return { mathjs: "Fraction", n: this.s * this.n, d: this.d };
      }),
      (Wn.fromJSON = function (e) {
        return new Wn(e);
      }),
      Wn
    ),
    { isClass: !0 }
  ),
  Ab = "Range",
  Sb = [],
  Eb = P(
    Ab,
    Sb,
    () => {
      function e(r, t, a) {
        if (!(this instanceof e))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        var n = r != null,
          i = t != null,
          c = a != null;
        if (n) {
          if (Qe(r)) r = r.toNumber();
          else if (typeof r != "number")
            throw new TypeError("Parameter start must be a number");
        }
        if (i) {
          if (Qe(t)) t = t.toNumber();
          else if (typeof t != "number")
            throw new TypeError("Parameter end must be a number");
        }
        if (c) {
          if (Qe(a)) a = a.toNumber();
          else if (typeof a != "number")
            throw new TypeError("Parameter step must be a number");
        }
        (this.start = n ? parseFloat(r) : 0),
          (this.end = i ? parseFloat(t) : 0),
          (this.step = c ? parseFloat(a) : 1);
      }
      return (
        (e.prototype.type = "Range"),
        (e.prototype.isRange = !0),
        (e.parse = function (r) {
          if (typeof r != "string") return null;
          var t = r.split(":"),
            a = t.map(function (i) {
              return parseFloat(i);
            }),
            n = a.some(function (i) {
              return isNaN(i);
            });
          if (n) return null;
          switch (a.length) {
            case 2:
              return new e(a[0], a[1]);
            case 3:
              return new e(a[0], a[2], a[1]);
            default:
              return null;
          }
        }),
        (e.prototype.clone = function () {
          return new e(this.start, this.end, this.step);
        }),
        (e.prototype.size = function () {
          var r = 0,
            t = this.start,
            a = this.step,
            n = this.end,
            i = n - t;
          return (
            mn(a) === mn(i) ? (r = Math.ceil(i / a)) : i === 0 && (r = 0),
            isNaN(r) && (r = 0),
            [r]
          );
        }),
        (e.prototype.min = function () {
          var r = this.size()[0];
          if (r > 0)
            return this.step > 0
              ? this.start
              : this.start + (r - 1) * this.step;
        }),
        (e.prototype.max = function () {
          var r = this.size()[0];
          if (r > 0)
            return this.step > 0
              ? this.start + (r - 1) * this.step
              : this.start;
        }),
        (e.prototype.forEach = function (r) {
          var t = this.start,
            a = this.step,
            n = this.end,
            i = 0;
          if (a > 0) for (; t < n; ) r(t, [i], this), (t += a), i++;
          else if (a < 0) for (; t > n; ) r(t, [i], this), (t += a), i++;
        }),
        (e.prototype.map = function (r) {
          var t = [];
          return (
            this.forEach(function (a, n, i) {
              t[n[0]] = r(a, n, i);
            }),
            t
          );
        }),
        (e.prototype.toArray = function () {
          var r = [];
          return (
            this.forEach(function (t, a) {
              r[a[0]] = t;
            }),
            r
          );
        }),
        (e.prototype.valueOf = function () {
          return this.toArray();
        }),
        (e.prototype.format = function (r) {
          var t = Sn(this.start, r);
          return (
            this.step !== 1 && (t += ":" + Sn(this.step, r)),
            (t += ":" + Sn(this.end, r)),
            t
          );
        }),
        (e.prototype.toString = function () {
          return this.format();
        }),
        (e.prototype.toJSON = function () {
          return {
            mathjs: "Range",
            start: this.start,
            end: this.end,
            step: this.step,
          };
        }),
        (e.fromJSON = function (r) {
          return new e(r.start, r.end, r.step);
        }),
        e
      );
    },
    { isClass: !0 }
  ),
  Cb = "Matrix",
  $b = [],
  Ob = P(
    Cb,
    $b,
    () => {
      function e() {
        if (!(this instanceof e))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
      }
      return (
        (e.prototype.type = "Matrix"),
        (e.prototype.isMatrix = !0),
        (e.prototype.storage = function () {
          throw new Error("Cannot invoke storage on a Matrix interface");
        }),
        (e.prototype.datatype = function () {
          throw new Error("Cannot invoke datatype on a Matrix interface");
        }),
        (e.prototype.create = function (r, t) {
          throw new Error("Cannot invoke create on a Matrix interface");
        }),
        (e.prototype.subset = function (r, t, a) {
          throw new Error("Cannot invoke subset on a Matrix interface");
        }),
        (e.prototype.get = function (r) {
          throw new Error("Cannot invoke get on a Matrix interface");
        }),
        (e.prototype.set = function (r, t, a) {
          throw new Error("Cannot invoke set on a Matrix interface");
        }),
        (e.prototype.resize = function (r, t) {
          throw new Error("Cannot invoke resize on a Matrix interface");
        }),
        (e.prototype.reshape = function (r, t) {
          throw new Error("Cannot invoke reshape on a Matrix interface");
        }),
        (e.prototype.clone = function () {
          throw new Error("Cannot invoke clone on a Matrix interface");
        }),
        (e.prototype.size = function () {
          throw new Error("Cannot invoke size on a Matrix interface");
        }),
        (e.prototype.map = function (r, t) {
          throw new Error("Cannot invoke map on a Matrix interface");
        }),
        (e.prototype.forEach = function (r) {
          throw new Error("Cannot invoke forEach on a Matrix interface");
        }),
        (e.prototype[Symbol.iterator] = function () {
          throw new Error("Cannot iterate a Matrix interface");
        }),
        (e.prototype.toArray = function () {
          throw new Error("Cannot invoke toArray on a Matrix interface");
        }),
        (e.prototype.valueOf = function () {
          throw new Error("Cannot invoke valueOf on a Matrix interface");
        }),
        (e.prototype.format = function (r) {
          throw new Error("Cannot invoke format on a Matrix interface");
        }),
        (e.prototype.toString = function () {
          throw new Error("Cannot invoke toString on a Matrix interface");
        }),
        e
      );
    },
    { isClass: !0 }
  ),
  Tb = "DenseMatrix",
  Db = ["Matrix"],
  Bb = P(
    Tb,
    Db,
    (e) => {
      var { Matrix: r } = e;
      function t(s, o) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (o && !et(o)) throw new Error("Invalid datatype: " + o);
        if (ze(s))
          s.type === "DenseMatrix"
            ? ((this._data = Fe(s._data)),
              (this._size = Fe(s._size)),
              (this._datatype = o || s._datatype))
            : ((this._data = s.toArray()),
              (this._size = s.size()),
              (this._datatype = o || s._datatype));
        else if (s && sr(s.data) && sr(s.size))
          (this._data = s.data),
            (this._size = s.size),
            Vu(this._data, this._size),
            (this._datatype = o || s.datatype);
        else if (sr(s))
          (this._data = u(s)),
            (this._size = Xe(this._data)),
            Vu(this._data, this._size),
            (this._datatype = o);
        else {
          if (s)
            throw new TypeError("Unsupported type of data (" + vr(s) + ")");
          (this._data = []), (this._size = [0]), (this._datatype = o);
        }
      }
      (t.prototype = new r()),
        (t.prototype.createDenseMatrix = function (s, o) {
          return new t(s, o);
        }),
        (t.prototype.type = "DenseMatrix"),
        (t.prototype.isDenseMatrix = !0),
        (t.prototype.getDataType = function () {
          return qa(this._data, vr);
        }),
        (t.prototype.storage = function () {
          return "dense";
        }),
        (t.prototype.datatype = function () {
          return this._datatype;
        }),
        (t.prototype.create = function (s, o) {
          return new t(s, o);
        }),
        (t.prototype.subset = function (s, o, l) {
          switch (arguments.length) {
            case 1:
              return a(this, s);
            case 2:
            case 3:
              return i(this, s, o, l);
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        }),
        (t.prototype.get = function (s) {
          if (!sr(s)) throw new TypeError("Array expected");
          if (s.length !== this._size.length)
            throw new Je(s.length, this._size.length);
          for (var o = 0; o < s.length; o++) cr(s[o], this._size[o]);
          for (var l = this._data, p = 0, v = s.length; p < v; p++) {
            var h = s[p];
            cr(h, l.length), (l = l[h]);
          }
          return l;
        }),
        (t.prototype.set = function (s, o, l) {
          if (!sr(s)) throw new TypeError("Array expected");
          if (s.length < this._size.length)
            throw new Je(s.length, this._size.length, "<");
          var p,
            v,
            h,
            x = s.map(function (N) {
              return N + 1;
            });
          f(this, x, l);
          var b = this._data;
          for (p = 0, v = s.length - 1; p < v; p++)
            (h = s[p]), cr(h, b.length), (b = b[h]);
          return (h = s[s.length - 1]), cr(h, b.length), (b[h] = o), this;
        });
      function a(s, o) {
        if (!Za(o)) throw new TypeError("Invalid index");
        var l = o.isScalar();
        if (l) return s.get(o.min());
        var p = o.size();
        if (p.length !== s._size.length) throw new Je(p.length, s._size.length);
        for (
          var v = o.min(), h = o.max(), x = 0, b = s._size.length;
          x < b;
          x++
        )
          cr(v[x], s._size[x]), cr(h[x], s._size[x]);
        return new t(n(s._data, o, p.length, 0), s._datatype);
      }
      function n(s, o, l, p) {
        var v = p === l - 1,
          h = o.dimension(p);
        return v
          ? h
              .map(function (x) {
                return cr(x, s.length), s[x];
              })
              .valueOf()
          : h
              .map(function (x) {
                cr(x, s.length);
                var b = s[x];
                return n(b, o, l, p + 1);
              })
              .valueOf();
      }
      function i(s, o, l, p) {
        if (!o || o.isIndex !== !0) throw new TypeError("Invalid index");
        var v = o.size(),
          h = o.isScalar(),
          x;
        if ((ze(l) ? ((x = l.size()), (l = l.valueOf())) : (x = Xe(l)), h)) {
          if (x.length !== 0) throw new TypeError("Scalar expected");
          s.set(o.min(), l, p);
        } else {
          if (v.length < s._size.length)
            throw new Je(v.length, s._size.length, "<");
          if (x.length < v.length) {
            for (var b = 0, N = 0; v[b] === 1 && x[b] === 1; ) b++;
            for (; v[b] === 1; ) N++, b++;
            l = kp(l, v.length, N, x);
          }
          if (!Pa(v, x)) throw new Je(v, x, ">");
          var d = o.max().map(function (g) {
            return g + 1;
          });
          f(s, d, p);
          var y = v.length,
            w = 0;
          c(s._data, o, l, y, w);
        }
        return s;
      }
      function c(s, o, l, p, v) {
        var h = v === p - 1,
          x = o.dimension(v);
        h
          ? x.forEach(function (b, N) {
              cr(b), (s[b] = l[N[0]]);
            })
          : x.forEach(function (b, N) {
              cr(b), c(s[b], o, l[N[0]], p, v + 1);
            });
      }
      t.prototype.resize = function (s, o, l) {
        if (!da(s)) throw new TypeError("Array or Matrix expected");
        var p = s
            .valueOf()
            .map((h) => (Array.isArray(h) && h.length === 1 ? h[0] : h)),
          v = l ? this.clone() : this;
        return m(v, p, o);
      };
      function m(s, o, l) {
        if (o.length === 0) {
          for (var p = s._data; sr(p); ) p = p[0];
          return p;
        }
        return (s._size = o.slice(0)), (s._data = oa(s._data, s._size, l)), s;
      }
      t.prototype.reshape = function (s, o) {
        var l = o ? this.clone() : this;
        l._data = zp(l._data, s);
        var p = l._size.reduce((v, h) => v * h);
        return (l._size = ks(s, p)), l;
      };
      function f(s, o, l) {
        for (var p = s._size.slice(0), v = !1; p.length < o.length; )
          p.push(0), (v = !0);
        for (var h = 0, x = o.length; h < x; h++)
          o[h] > p[h] && ((p[h] = o[h]), (v = !0));
        v && m(s, p, l);
      }
      (t.prototype.clone = function () {
        var s = new t({
          data: Fe(this._data),
          size: Fe(this._size),
          datatype: this._datatype,
        });
        return s;
      }),
        (t.prototype.size = function () {
          return this._size.slice(0);
        }),
        (t.prototype.map = function (s) {
          var o = this,
            l = function h(x, b) {
              return sr(x)
                ? x.map(function (N, d) {
                    return h(N, b.concat(d));
                  })
                : s(x, b, o);
            },
            p = l(this._data, []),
            v = this._datatype !== void 0 ? qa(p, vr) : void 0;
          return new t(p, v);
        }),
        (t.prototype.forEach = function (s) {
          var o = this,
            l = function p(v, h) {
              sr(v)
                ? v.forEach(function (x, b) {
                    p(x, h.concat(b));
                  })
                : s(v, h, o);
            };
          l(this._data, []);
        }),
        (t.prototype[Symbol.iterator] = function* () {
          var s = function* o(l, p) {
            if (sr(l))
              for (var v = 0; v < l.length; v++) yield* o(l[v], p.concat(v));
            else yield { value: l, index: p };
          };
          yield* s(this._data, []);
        }),
        (t.prototype.rows = function () {
          var s = [],
            o = this.size();
          if (o.length !== 2)
            throw new TypeError("Rows can only be returned for a 2D matrix.");
          var l = this._data;
          for (var p of l) s.push(new t([p], this._datatype));
          return s;
        }),
        (t.prototype.columns = function () {
          var s = this,
            o = [],
            l = this.size();
          if (l.length !== 2)
            throw new TypeError("Rows can only be returned for a 2D matrix.");
          for (
            var p = this._data,
              v = function (b) {
                var N = p.map((d) => [d[b]]);
                o.push(new t(N, s._datatype));
              },
              h = 0;
            h < l[1];
            h++
          )
            v(h);
          return o;
        }),
        (t.prototype.toArray = function () {
          return Fe(this._data);
        }),
        (t.prototype.valueOf = function () {
          return this._data;
        }),
        (t.prototype.format = function (s) {
          return Ze(this._data, s);
        }),
        (t.prototype.toString = function () {
          return Ze(this._data);
        }),
        (t.prototype.toJSON = function () {
          return {
            mathjs: "DenseMatrix",
            data: this._data,
            size: this._size,
            datatype: this._datatype,
          };
        }),
        (t.prototype.diagonal = function (s) {
          if (s) {
            if ((Qe(s) && (s = s.toNumber()), !je(s) || !Be(s)))
              throw new TypeError("The parameter k must be an integer number");
          } else s = 0;
          for (
            var o = s > 0 ? s : 0,
              l = s < 0 ? -s : 0,
              p = this._size[0],
              v = this._size[1],
              h = Math.min(p - l, v - o),
              x = [],
              b = 0;
            b < h;
            b++
          )
            x[b] = this._data[b + l][b + o];
          return new t({ data: x, size: [h], datatype: this._datatype });
        }),
        (t.diagonal = function (s, o, l, p) {
          if (!sr(s)) throw new TypeError("Array expected, size parameter");
          if (s.length !== 2)
            throw new Error("Only two dimensions matrix are supported");
          if (
            ((s = s.map(function (S) {
              if ((Qe(S) && (S = S.toNumber()), !je(S) || !Be(S) || S < 1))
                throw new Error("Size values must be positive integers");
              return S;
            })),
            l)
          ) {
            if ((Qe(l) && (l = l.toNumber()), !je(l) || !Be(l)))
              throw new TypeError("The parameter k must be an integer number");
          } else l = 0;
          var v = l > 0 ? l : 0,
            h = l < 0 ? -l : 0,
            x = s[0],
            b = s[1],
            N = Math.min(x - h, b - v),
            d;
          if (sr(o)) {
            if (o.length !== N) throw new Error("Invalid value array length");
            d = function (A) {
              return o[A];
            };
          } else if (ze(o)) {
            var y = o.size();
            if (y.length !== 1 || y[0] !== N)
              throw new Error("Invalid matrix length");
            d = function (A) {
              return o.get([A]);
            };
          } else
            d = function () {
              return o;
            };
          p || (p = Qe(d(0)) ? d(0).mul(0) : 0);
          var w = [];
          if (s.length > 0) {
            w = oa(w, s, p);
            for (var g = 0; g < N; g++) w[g + h][g + v] = d(g);
          }
          return new t({ data: w, size: [x, b] });
        }),
        (t.fromJSON = function (s) {
          return new t(s);
        }),
        (t.prototype.swapRows = function (s, o) {
          if (!je(s) || !Be(s) || !je(o) || !Be(o))
            throw new Error("Row index must be positive integers");
          if (this._size.length !== 2)
            throw new Error("Only two dimensional matrix is supported");
          return (
            cr(s, this._size[0]),
            cr(o, this._size[0]),
            t._swapRows(s, o, this._data),
            this
          );
        }),
        (t._swapRows = function (s, o, l) {
          var p = l[s];
          (l[s] = l[o]), (l[o] = p);
        });
      function u(s) {
        for (var o = 0, l = s.length; o < l; o++) {
          var p = s[o];
          sr(p)
            ? (s[o] = u(p))
            : p && p.isMatrix === !0 && (s[o] = u(p.valueOf()));
        }
        return s;
      }
      return t;
    },
    { isClass: !0 }
  ),
  Xu = "clone",
  _b = ["typed"],
  Ib = P(Xu, _b, (e) => {
    var { typed: r } = e;
    return r(Xu, { any: Fe });
  });
function ov(e) {
  var r = e.length,
    t = e[0].length,
    a,
    n,
    i = [];
  for (n = 0; n < t; n++) {
    var c = [];
    for (a = 0; a < r; a++) c.push(e[a][n]);
    i.push(c);
  }
  return i;
}
function ya(e) {
  for (var r = 0; r < e.length; r++) if (da(e[r])) return !0;
  return !1;
}
function Qt(e, r) {
  ze(e) && (e = e.valueOf());
  for (var t = 0, a = e.length; t < a; t++) {
    var n = e[t];
    Array.isArray(n) ? Qt(n, r) : r(n);
  }
}
function Oe(e, r, t) {
  return e && typeof e.map == "function"
    ? e.map(function (a) {
        return Oe(a, r);
      })
    : r(e);
}
function ro(e, r, t) {
  var a = Array.isArray(e) ? Xe(e) : e.size();
  if (r < 0 || r >= a.length) throw new At(r, a.length);
  return ze(e) ? e.create(Ri(e.valueOf(), r, t)) : Ri(e, r, t);
}
function Ri(e, r, t) {
  var a, n, i, c;
  if (r <= 0)
    if (Array.isArray(e[0])) {
      for (c = ov(e), n = [], a = 0; a < c.length; a++)
        n[a] = Ri(c[a], r - 1, t);
      return n;
    } else {
      for (i = e[0], a = 1; a < e.length; a++) i = t(i, e[a]);
      return i;
    }
  else {
    for (n = [], a = 0; a < e.length; a++) n[a] = Ri(e[a], r - 1, t);
    return n;
  }
}
function Yu(e, r, t, a, n, i, c, m, f, u, s) {
  var o = e._values,
    l = e._index,
    p = e._ptr,
    v,
    h,
    x,
    b;
  if (a)
    for (h = p[r], x = p[r + 1], v = h; v < x; v++)
      (b = l[v]),
        t[b] !== i
          ? ((t[b] = i),
            c.push(b),
            u
              ? ((a[b] = f ? m(o[v], s) : m(s, o[v])), (n[b] = i))
              : (a[b] = o[v]))
          : ((a[b] = f ? m(o[v], a[b]) : m(a[b], o[v])), (n[b] = i));
  else
    for (h = p[r], x = p[r + 1], v = h; v < x; v++)
      (b = l[v]), t[b] !== i ? ((t[b] = i), c.push(b)) : (n[b] = i);
}
var Qu = "isInteger",
  Rb = ["typed"],
  Fb = P(Qu, Rb, (e) => {
    var { typed: r } = e;
    return r(Qu, {
      number: Be,
      BigNumber: function (a) {
        return a.isInt();
      },
      Fraction: function (a) {
        return a.d === 1 && isFinite(a.n);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  St = "number",
  Tn = "number, number";
function sv(e) {
  return Math.abs(e);
}
sv.signature = St;
function uv(e, r) {
  return e + r;
}
uv.signature = Tn;
function lv(e, r) {
  return e * r;
}
lv.signature = Tn;
function cv(e) {
  return -e;
}
cv.signature = St;
function fv(e) {
  return e;
}
fv.signature = St;
function _a(e) {
  return U0(e);
}
_a.signature = St;
function mv(e) {
  return e * e * e;
}
mv.signature = St;
function pv(e) {
  return Math.exp(e);
}
pv.signature = St;
function vv(e) {
  return L0(e);
}
vv.signature = St;
function hv(e, r) {
  if (!Be(e) || !Be(r))
    throw new Error("Parameters in function gcd must be integer numbers");
  for (var t; r !== 0; ) (t = e % r), (e = r), (r = t);
  return e < 0 ? -e : e;
}
hv.signature = Tn;
function dv(e, r) {
  if (!Be(e) || !Be(r))
    throw new Error("Parameters in function lcm must be integer numbers");
  if (e === 0 || r === 0) return 0;
  for (var t, a = e * r; r !== 0; ) (t = r), (r = e % t), (e = t);
  return Math.abs(a / e);
}
dv.signature = Tn;
function Pb(e, r) {
  return r ? Math.log(e) / Math.log(r) : Math.log(e);
}
function gv(e) {
  return q0(e);
}
gv.signature = St;
function yv(e) {
  return P0(e);
}
yv.signature = St;
function bv(e, r) {
  if (r > 0) return e - r * Math.floor(e / r);
  if (r === 0) return e;
  throw new Error("Cannot calculate mod for a negative divisor");
}
bv.signature = Tn;
function ju(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2,
    t = r < 0;
  if ((t && (r = -r), r === 0)) throw new Error("Root must be non-zero");
  if (e < 0 && Math.abs(r) % 2 !== 1)
    throw new Error("Root must be odd when a is negative.");
  if (e === 0) return t ? 1 / 0 : 0;
  if (!isFinite(e)) return t ? 0 : e;
  var a = Math.pow(Math.abs(e), 1 / r);
  return (a = e < 0 ? -a : a), t ? 1 / a : a;
}
function ys(e) {
  return mn(e);
}
ys.signature = St;
function xv(e) {
  return e * e;
}
xv.signature = St;
function wv(e, r) {
  var t,
    a,
    n,
    i = 0,
    c = 1,
    m = 1,
    f = 0;
  if (!Be(e) || !Be(r))
    throw new Error("Parameters in function xgcd must be integer numbers");
  for (; r; )
    (a = Math.floor(e / r)),
      (n = e - a * r),
      (t = i),
      (i = c - a * i),
      (c = t),
      (t = m),
      (m = f - a * m),
      (f = t),
      (e = r),
      (r = n);
  var u;
  return e < 0 ? (u = [-e, -c, -f]) : (u = [e, e ? c : 0, f]), u;
}
wv.signature = Tn;
function Nv(e, r) {
  return (e * e < 1 && r === 1 / 0) || (e * e > 1 && r === -1 / 0)
    ? 0
    : Math.pow(e, r);
}
Nv.signature = Tn;
function Ku(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!Be(r) || r < 0 || r > 15)
    throw new Error(
      "Number of decimals in function round must be an integer from 0 to 15 inclusive"
    );
  return parseFloat(Rp(e, r));
}
var qb = "number",
  ba = "number, number";
function Mv(e, r) {
  if (!Be(e) || !Be(r)) throw new Error("Integers expected in function bitAnd");
  return e & r;
}
Mv.signature = ba;
function Av(e) {
  if (!Be(e)) throw new Error("Integer expected in function bitNot");
  return ~e;
}
Av.signature = qb;
function Sv(e, r) {
  if (!Be(e) || !Be(r)) throw new Error("Integers expected in function bitOr");
  return e | r;
}
Sv.signature = ba;
function Ev(e, r) {
  if (!Be(e) || !Be(r)) throw new Error("Integers expected in function bitXor");
  return e ^ r;
}
Ev.signature = ba;
function Cv(e, r) {
  if (!Be(e) || !Be(r))
    throw new Error("Integers expected in function leftShift");
  return e << r;
}
Cv.signature = ba;
function $v(e, r) {
  if (!Be(e) || !Be(r))
    throw new Error("Integers expected in function rightArithShift");
  return e >> r;
}
$v.signature = ba;
function Ov(e, r) {
  if (!Be(e) || !Be(r))
    throw new Error("Integers expected in function rightLogShift");
  return e >>> r;
}
Ov.signature = ba;
function Zt(e, r) {
  if (r < e) return 1;
  if (r === e) return r;
  var t = (r + e) >> 1;
  return Zt(e, t) * Zt(t + 1, r);
}
function Tv(e, r) {
  if (!Be(e) || e < 0)
    throw new TypeError(
      "Positive integer value expected in function combinations"
    );
  if (!Be(r) || r < 0)
    throw new TypeError(
      "Positive integer value expected in function combinations"
    );
  if (r > e) throw new TypeError("k must be less than or equal to n");
  for (
    var t = e - r,
      a = 1,
      n = r < t ? t + 1 : r + 1,
      i = 2,
      c = r < t ? r : t,
      m = n;
    m <= e;
    ++m
  )
    for (a *= m; i <= c && a % i === 0; ) (a /= i), ++i;
  return i <= c && (a /= Zt(i, c)), a;
}
Tv.signature = "number, number";
var zb = Math.PI,
  Ub = 2 * Math.PI,
  Lb = Math.E,
  kb = 1.618033988749895,
  Vb = "number",
  Ws = "number, number";
function Dv(e) {
  return !e;
}
Dv.signature = Vb;
function Bv(e, r) {
  return !!(e || r);
}
Bv.signature = Ws;
function _v(e, r) {
  return !!e != !!r;
}
_v.signature = Ws;
function Iv(e, r) {
  return !!(e && r);
}
Iv.signature = Ws;
function Xs(e) {
  var r;
  if (Be(e))
    return e <= 0
      ? isFinite(e)
        ? 1 / 0
        : NaN
      : e > 171
      ? 1 / 0
      : Zt(1, e - 1);
  if (e < 0.5) return Math.PI / (Math.sin(Math.PI * e) * Xs(1 - e));
  if (e >= 171.35) return 1 / 0;
  if (e > 85) {
    var t = e * e,
      a = t * e,
      n = a * e,
      i = n * e;
    return (
      Math.sqrt((2 * Math.PI) / e) *
      Math.pow(e / Math.E, e) *
      (1 +
        1 / (12 * e) +
        1 / (288 * t) -
        139 / (51840 * a) -
        571 / (2488320 * n) +
        163879 / (209018880 * i) +
        5246819 / (75246796800 * i * e))
    );
  }
  --e, (r = na[0]);
  for (var c = 1; c < na.length; ++c) r += na[c] / (e + c);
  var m = e + Rv + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(m, e + 0.5) * Math.exp(-m) * r;
}
Xs.signature = "number";
var Rv = 4.7421875,
  na = [
    0.9999999999999971, 57.15623566586292, -59.59796035547549,
    14.136097974741746, -0.4919138160976202, 3399464998481189e-20,
    4652362892704858e-20, -9837447530487956e-20, 0.0001580887032249125,
    -0.00021026444172410488, 0.00021743961811521265, -0.0001643181065367639,
    8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22,
  ],
  Fv = 0.9189385332046728,
  Gb = 5,
  Hb = 7,
  el = [
    1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091,
    -1.231739572450155, 0.001208650973866179, -5395239384953e-18,
  ];
function Fi(e) {
  if (e < 0) return NaN;
  if (e === 0) return 1 / 0;
  if (!isFinite(e)) return e;
  if (e < 0.5) return Math.log(Math.PI / Math.sin(Math.PI * e)) - Fi(1 - e);
  e = e - 1;
  for (var r = e + Gb + 0.5, t = el[0], a = Hb - 1; a >= 1; a--)
    t += el[a] / (e + a);
  return Fv + (e + 0.5) * Math.log(r) - r + Math.log(t);
}
Fi.signature = "number";
var Gr = "number";
function Pv(e) {
  return Z0(e);
}
Pv.signature = Gr;
function qv(e) {
  return Math.atan(1 / e);
}
qv.signature = Gr;
function zv(e) {
  return isFinite(e) ? (Math.log((e + 1) / e) + Math.log(e / (e - 1))) / 2 : 0;
}
zv.signature = Gr;
function Uv(e) {
  return Math.asin(1 / e);
}
Uv.signature = Gr;
function Lv(e) {
  var r = 1 / e;
  return Math.log(r + Math.sqrt(r * r + 1));
}
Lv.signature = Gr;
function kv(e) {
  return Math.acos(1 / e);
}
kv.signature = Gr;
function Vv(e) {
  var r = 1 / e,
    t = Math.sqrt(r * r - 1);
  return Math.log(t + r);
}
Vv.signature = Gr;
function Gv(e) {
  return J0(e);
}
Gv.signature = Gr;
function Hv(e) {
  return W0(e);
}
Hv.signature = Gr;
function Zv(e) {
  return 1 / Math.tan(e);
}
Zv.signature = Gr;
function Jv(e) {
  var r = Math.exp(2 * e);
  return (r + 1) / (r - 1);
}
Jv.signature = Gr;
function Wv(e) {
  return 1 / Math.sin(e);
}
Wv.signature = Gr;
function Xv(e) {
  return e === 0
    ? Number.POSITIVE_INFINITY
    : Math.abs(2 / (Math.exp(e) - Math.exp(-e))) * mn(e);
}
Xv.signature = Gr;
function Yv(e) {
  return 1 / Math.cos(e);
}
Yv.signature = Gr;
function Qv(e) {
  return 2 / (Math.exp(e) + Math.exp(-e));
}
Qv.signature = Gr;
function jv(e) {
  return Y0(e);
}
jv.signature = Gr;
var to = "number";
function Kv(e) {
  return e < 0;
}
Kv.signature = to;
function eh(e) {
  return e > 0;
}
eh.signature = to;
function rh(e) {
  return e === 0;
}
rh.signature = to;
function th(e) {
  return Number.isNaN(e);
}
th.signature = to;
var rl = "isNegative",
  Zb = ["typed"],
  Jb = P(rl, Zb, (e) => {
    var { typed: r } = e;
    return r(rl, {
      number: Kv,
      BigNumber: function (a) {
        return a.isNeg() && !a.isZero() && !a.isNaN();
      },
      Fraction: function (a) {
        return a.s < 0;
      },
      Unit: function (a) {
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  tl = "isNumeric",
  Wb = ["typed"],
  Xb = P(tl, Wb, (e) => {
    var { typed: r } = e;
    return r(tl, {
      "number | BigNumber | Fraction | boolean": function () {
        return !0;
      },
      "Complex | Unit | string | null | undefined | Node": function () {
        return !1;
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  nl = "hasNumericValue",
  Yb = ["typed", "isNumeric"],
  Qb = P(nl, Yb, (e) => {
    var { typed: r, isNumeric: t } = e;
    return r(nl, {
      string: function (n) {
        return n.trim().length > 0 && !isNaN(Number(n));
      },
      any: function (n) {
        return t(n);
      },
    });
  }),
  al = "isPositive",
  jb = ["typed"],
  Kb = P(al, jb, (e) => {
    var { typed: r } = e;
    return r(al, {
      number: eh,
      BigNumber: function (a) {
        return !a.isNeg() && !a.isZero() && !a.isNaN();
      },
      Fraction: function (a) {
        return a.s > 0 && a.n > 0;
      },
      Unit: function (a) {
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  il = "isZero",
  ex = ["typed"],
  rx = P(il, ex, (e) => {
    var { typed: r } = e;
    return r(il, {
      number: rh,
      BigNumber: function (a) {
        return a.isZero();
      },
      Complex: function (a) {
        return a.re === 0 && a.im === 0;
      },
      Fraction: function (a) {
        return a.d === 1 && a.n === 0;
      },
      Unit: function (a) {
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  ol = "isNaN",
  tx = ["typed"],
  nx = P(ol, tx, (e) => {
    var { typed: r } = e;
    return r(ol, {
      number: th,
      BigNumber: function (a) {
        return a.isNaN();
      },
      Fraction: function (a) {
        return !1;
      },
      Complex: function (a) {
        return a.isNaN();
      },
      Unit: function (a) {
        return Number.isNaN(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, Number.isNaN);
      },
    });
  }),
  sl = "typeOf",
  ax = ["typed"],
  ix = P(sl, ax, (e) => {
    var { typed: r } = e;
    return r(sl, { any: vr });
  });
function Pt(e, r, t) {
  if (t == null) return e.eq(r);
  if (e.eq(r)) return !0;
  if (e.isNaN() || r.isNaN()) return !1;
  if (e.isFinite() && r.isFinite()) {
    var a = e.minus(r).abs();
    if (a.isZero()) return !0;
    var n = e.constructor.max(e.abs(), r.abs());
    return a.lte(n.times(t));
  }
  return !1;
}
function ox(e, r, t) {
  return nt(e.re, r.re, t) && nt(e.im, r.im, t);
}
var Pi = "equalScalar",
  sx = ["typed", "config"],
  ux = P(Pi, sx, (e) => {
    var { typed: r, config: t } = e;
    return r(Pi, {
      "boolean, boolean": function (n, i) {
        return n === i;
      },
      "number, number": function (n, i) {
        return nt(n, i, t.epsilon);
      },
      "BigNumber, BigNumber": function (n, i) {
        return n.eq(i) || Pt(n, i, t.epsilon);
      },
      "Fraction, Fraction": function (n, i) {
        return n.equals(i);
      },
      "Complex, Complex": function (n, i) {
        return ox(n, i, t.epsilon);
      },
      "Unit, Unit": function (n, i) {
        if (!n.equalBase(i))
          throw new Error("Cannot compare units with different base");
        return this(n.value, i.value);
      },
    });
  });
P(Pi, ["typed", "config"], (e) => {
  var { typed: r, config: t } = e;
  return r(Pi, {
    "number, number": function (n, i) {
      return nt(n, i, t.epsilon);
    },
  });
});
var lx = "SparseMatrix",
  cx = ["typed", "equalScalar", "Matrix"],
  fx = P(
    lx,
    cx,
    (e) => {
      var { typed: r, equalScalar: t, Matrix: a } = e;
      function n(h, x) {
        if (!(this instanceof n))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (x && !et(x)) throw new Error("Invalid datatype: " + x);
        if (ze(h)) i(this, h, x);
        else if (h && sr(h.index) && sr(h.ptr) && sr(h.size))
          (this._values = h.values),
            (this._index = h.index),
            (this._ptr = h.ptr),
            (this._size = h.size),
            (this._datatype = x || h.datatype);
        else if (sr(h)) c(this, h, x);
        else {
          if (h)
            throw new TypeError("Unsupported type of data (" + vr(h) + ")");
          (this._values = []),
            (this._index = []),
            (this._ptr = [0]),
            (this._size = [0, 0]),
            (this._datatype = x);
        }
      }
      function i(h, x, b) {
        x.type === "SparseMatrix"
          ? ((h._values = x._values ? Fe(x._values) : void 0),
            (h._index = Fe(x._index)),
            (h._ptr = Fe(x._ptr)),
            (h._size = Fe(x._size)),
            (h._datatype = b || x._datatype))
          : c(h, x.valueOf(), b || x._datatype);
      }
      function c(h, x, b) {
        (h._values = []), (h._index = []), (h._ptr = []), (h._datatype = b);
        var N = x.length,
          d = 0,
          y = t,
          w = 0;
        if (
          (et(b) && ((y = r.find(t, [b, b]) || t), (w = r.convert(0, b))),
          N > 0)
        ) {
          var g = 0;
          do {
            h._ptr.push(h._index.length);
            for (var S = 0; S < N; S++) {
              var A = x[S];
              if (sr(A)) {
                if ((g === 0 && d < A.length && (d = A.length), g < A.length)) {
                  var E = A[g];
                  y(E, w) || (h._values.push(E), h._index.push(S));
                }
              } else
                g === 0 && d < 1 && (d = 1),
                  y(A, w) || (h._values.push(A), h._index.push(S));
            }
            g++;
          } while (g < d);
        }
        h._ptr.push(h._index.length), (h._size = [N, d]);
      }
      (n.prototype = new a()),
        (n.prototype.createSparseMatrix = function (h, x) {
          return new n(h, x);
        }),
        (n.prototype.type = "SparseMatrix"),
        (n.prototype.isSparseMatrix = !0),
        (n.prototype.getDataType = function () {
          return qa(this._values, vr);
        }),
        (n.prototype.storage = function () {
          return "sparse";
        }),
        (n.prototype.datatype = function () {
          return this._datatype;
        }),
        (n.prototype.create = function (h, x) {
          return new n(h, x);
        }),
        (n.prototype.density = function () {
          var h = this._size[0],
            x = this._size[1];
          return h !== 0 && x !== 0 ? this._index.length / (h * x) : 0;
        }),
        (n.prototype.subset = function (h, x, b) {
          if (!this._values)
            throw new Error("Cannot invoke subset on a Pattern only matrix");
          switch (arguments.length) {
            case 1:
              return m(this, h);
            case 2:
            case 3:
              return f(this, h, x, b);
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        });
      function m(h, x) {
        if (!Za(x)) throw new TypeError("Invalid index");
        var b = x.isScalar();
        if (b) return h.get(x.min());
        var N = x.size();
        if (N.length !== h._size.length) throw new Je(N.length, h._size.length);
        var d,
          y,
          w,
          g,
          S = x.min(),
          A = x.max();
        for (d = 0, y = h._size.length; d < y; d++)
          cr(S[d], h._size[d]), cr(A[d], h._size[d]);
        var E = h._values,
          M = h._index,
          B = h._ptr,
          C = x.dimension(0),
          _ = x.dimension(1),
          z = [],
          I = [];
        C.forEach(function (O, H) {
          (I[O] = H[0]), (z[O] = !0);
        });
        var T = E ? [] : void 0,
          D = [],
          Z = [];
        return (
          _.forEach(function (O) {
            for (Z.push(D.length), w = B[O], g = B[O + 1]; w < g; w++)
              (d = M[w]), z[d] === !0 && (D.push(I[d]), T && T.push(E[w]));
          }),
          Z.push(D.length),
          new n({ values: T, index: D, ptr: Z, size: N, datatype: h._datatype })
        );
      }
      function f(h, x, b, N) {
        if (!x || x.isIndex !== !0) throw new TypeError("Invalid index");
        var d = x.size(),
          y = x.isScalar(),
          w;
        if ((ze(b) ? ((w = b.size()), (b = b.toArray())) : (w = Xe(b)), y)) {
          if (w.length !== 0) throw new TypeError("Scalar expected");
          h.set(x.min(), b, N);
        } else {
          if (d.length !== 1 && d.length !== 2)
            throw new Je(d.length, h._size.length, "<");
          if (w.length < d.length) {
            for (var g = 0, S = 0; d[g] === 1 && w[g] === 1; ) g++;
            for (; d[g] === 1; ) S++, g++;
            b = kp(b, d.length, S, w);
          }
          if (!Pa(d, w)) throw new Je(d, w, ">");
          if (d.length === 1) {
            var A = x.dimension(0);
            A.forEach(function (B, C) {
              cr(B), h.set([B, 0], b[C[0]], N);
            });
          } else {
            var E = x.dimension(0),
              M = x.dimension(1);
            E.forEach(function (B, C) {
              cr(B),
                M.forEach(function (_, z) {
                  cr(_), h.set([B, _], b[C[0]][z[0]], N);
                });
            });
          }
        }
        return h;
      }
      (n.prototype.get = function (h) {
        if (!sr(h)) throw new TypeError("Array expected");
        if (h.length !== this._size.length)
          throw new Je(h.length, this._size.length);
        if (!this._values)
          throw new Error("Cannot invoke get on a Pattern only matrix");
        var x = h[0],
          b = h[1];
        cr(x, this._size[0]), cr(b, this._size[1]);
        var N = u(x, this._ptr[b], this._ptr[b + 1], this._index);
        return N < this._ptr[b + 1] && this._index[N] === x
          ? this._values[N]
          : 0;
      }),
        (n.prototype.set = function (h, x, b) {
          if (!sr(h)) throw new TypeError("Array expected");
          if (h.length !== this._size.length)
            throw new Je(h.length, this._size.length);
          if (!this._values)
            throw new Error("Cannot invoke set on a Pattern only matrix");
          var N = h[0],
            d = h[1],
            y = this._size[0],
            w = this._size[1],
            g = t,
            S = 0;
          et(this._datatype) &&
            ((g = r.find(t, [this._datatype, this._datatype]) || t),
            (S = r.convert(0, this._datatype))),
            (N > y - 1 || d > w - 1) &&
              (l(this, Math.max(N + 1, y), Math.max(d + 1, w), b),
              (y = this._size[0]),
              (w = this._size[1])),
            cr(N, y),
            cr(d, w);
          var A = u(N, this._ptr[d], this._ptr[d + 1], this._index);
          return (
            A < this._ptr[d + 1] && this._index[A] === N
              ? g(x, S)
                ? s(A, d, this._values, this._index, this._ptr)
                : (this._values[A] = x)
              : o(A, N, d, x, this._values, this._index, this._ptr),
            this
          );
        });
      function u(h, x, b, N) {
        if (b - x === 0) return b;
        for (var d = x; d < b; d++) if (N[d] === h) return d;
        return x;
      }
      function s(h, x, b, N, d) {
        b.splice(h, 1), N.splice(h, 1);
        for (var y = x + 1; y < d.length; y++) d[y]--;
      }
      function o(h, x, b, N, d, y, w) {
        d.splice(h, 0, N), y.splice(h, 0, x);
        for (var g = b + 1; g < w.length; g++) w[g]++;
      }
      n.prototype.resize = function (h, x, b) {
        if (!da(h)) throw new TypeError("Array or Matrix expected");
        var N = h
          .valueOf()
          .map((y) => (Array.isArray(y) && y.length === 1 ? y[0] : y));
        if (N.length !== 2)
          throw new Error("Only two dimensions matrix are supported");
        N.forEach(function (y) {
          if (!je(y) || !Be(y) || y < 0)
            throw new TypeError(
              "Invalid size, must contain positive integers (size: " +
                Ze(N) +
                ")"
            );
        });
        var d = b ? this.clone() : this;
        return l(d, N[0], N[1], x);
      };
      function l(h, x, b, N) {
        var d = N || 0,
          y = t,
          w = 0;
        et(h._datatype) &&
          ((y = r.find(t, [h._datatype, h._datatype]) || t),
          (w = r.convert(0, h._datatype)),
          (d = r.convert(d, h._datatype)));
        var g = !y(d, w),
          S = h._size[0],
          A = h._size[1],
          E,
          M,
          B;
        if (b > A) {
          for (M = A; M < b; M++)
            if (((h._ptr[M] = h._values.length), g))
              for (E = 0; E < S; E++) h._values.push(d), h._index.push(E);
          h._ptr[b] = h._values.length;
        } else
          b < A &&
            (h._ptr.splice(b + 1, A - b),
            h._values.splice(h._ptr[b], h._values.length),
            h._index.splice(h._ptr[b], h._index.length));
        if (((A = b), x > S)) {
          if (g) {
            var C = 0;
            for (M = 0; M < A; M++) {
              (h._ptr[M] = h._ptr[M] + C), (B = h._ptr[M + 1] + C);
              var _ = 0;
              for (E = S; E < x; E++, _++)
                h._values.splice(B + _, 0, d),
                  h._index.splice(B + _, 0, E),
                  C++;
            }
            h._ptr[A] = h._values.length;
          }
        } else if (x < S) {
          var z = 0;
          for (M = 0; M < A; M++) {
            h._ptr[M] = h._ptr[M] - z;
            var I = h._ptr[M],
              T = h._ptr[M + 1] - z;
            for (B = I; B < T; B++)
              (E = h._index[B]),
                E > x - 1 &&
                  (h._values.splice(B, 1), h._index.splice(B, 1), z++);
          }
          h._ptr[M] = h._values.length;
        }
        return (h._size[0] = x), (h._size[1] = b), h;
      }
      (n.prototype.reshape = function (h, x) {
        if (!sr(h)) throw new TypeError("Array expected");
        if (h.length !== 2)
          throw new Error(
            "Sparse matrices can only be reshaped in two dimensions"
          );
        h.forEach(function (O) {
          if (!je(O) || !Be(O) || O <= -2 || O === 0)
            throw new TypeError(
              "Invalid size, must contain positive integers or -1 (size: " +
                Ze(h) +
                ")"
            );
        });
        var b = this._size[0] * this._size[1];
        h = ks(h, b);
        var N = h[0] * h[1];
        if (b !== N)
          throw new Error(
            "Reshaping sparse matrix will result in the wrong number of elements"
          );
        var d = x ? this.clone() : this;
        if (this._size[0] === h[0] && this._size[1] === h[1]) return d;
        for (var y = [], w = 0; w < d._ptr.length; w++)
          for (var g = 0; g < d._ptr[w + 1] - d._ptr[w]; g++) y.push(w);
        for (
          var S = d._values.slice(), A = d._index.slice(), E = 0;
          E < d._index.length;
          E++
        ) {
          var M = A[E],
            B = y[E],
            C = M * d._size[1] + B;
          (y[E] = C % h[1]), (A[E] = Math.floor(C / h[1]));
        }
        (d._values.length = 0),
          (d._index.length = 0),
          (d._ptr.length = h[1] + 1),
          (d._size = h.slice());
        for (var _ = 0; _ < d._ptr.length; _++) d._ptr[_] = 0;
        for (var z = 0; z < S.length; z++) {
          var I = A[z],
            T = y[z],
            D = S[z],
            Z = u(I, d._ptr[T], d._ptr[T + 1], d._index);
          o(Z, I, T, D, d._values, d._index, d._ptr);
        }
        return d;
      }),
        (n.prototype.clone = function () {
          var h = new n({
            values: this._values ? Fe(this._values) : void 0,
            index: Fe(this._index),
            ptr: Fe(this._ptr),
            size: Fe(this._size),
            datatype: this._datatype,
          });
          return h;
        }),
        (n.prototype.size = function () {
          return this._size.slice(0);
        }),
        (n.prototype.map = function (h, x) {
          if (!this._values)
            throw new Error("Cannot invoke map on a Pattern only matrix");
          var b = this,
            N = this._size[0],
            d = this._size[1],
            y = function (g, S, A) {
              return h(g, [S, A], b);
            };
          return p(this, 0, N - 1, 0, d - 1, y, x);
        });
      function p(h, x, b, N, d, y, w) {
        var g = [],
          S = [],
          A = [],
          E = t,
          M = 0;
        et(h._datatype) &&
          ((E = r.find(t, [h._datatype, h._datatype]) || t),
          (M = r.convert(0, h._datatype)));
        for (
          var B = function (J, re, oe) {
              (J = y(J, re, oe)), E(J, M) || (g.push(J), S.push(re));
            },
            C = N;
          C <= d;
          C++
        ) {
          A.push(g.length);
          var _ = h._ptr[C],
            z = h._ptr[C + 1];
          if (w)
            for (var I = _; I < z; I++) {
              var T = h._index[I];
              T >= x && T <= b && B(h._values[I], T - x, C - N);
            }
          else {
            for (var D = {}, Z = _; Z < z; Z++) {
              var O = h._index[Z];
              D[O] = h._values[Z];
            }
            for (var H = x; H <= b; H++) {
              var Q = H in D ? D[H] : 0;
              B(Q, H - x, C - N);
            }
          }
        }
        return (
          A.push(g.length),
          new n({ values: g, index: S, ptr: A, size: [b - x + 1, d - N + 1] })
        );
      }
      (n.prototype.forEach = function (h, x) {
        if (!this._values)
          throw new Error("Cannot invoke forEach on a Pattern only matrix");
        for (
          var b = this, N = this._size[0], d = this._size[1], y = 0;
          y < d;
          y++
        ) {
          var w = this._ptr[y],
            g = this._ptr[y + 1];
          if (x)
            for (var S = w; S < g; S++) {
              var A = this._index[S];
              h(this._values[S], [A, y], b);
            }
          else {
            for (var E = {}, M = w; M < g; M++) {
              var B = this._index[M];
              E[B] = this._values[M];
            }
            for (var C = 0; C < N; C++) {
              var _ = C in E ? E[C] : 0;
              h(_, [C, y], b);
            }
          }
        }
      }),
        (n.prototype[Symbol.iterator] = function* () {
          if (!this._values)
            throw new Error("Cannot iterate a Pattern only matrix");
          for (var h = this._size[1], x = 0; x < h; x++)
            for (
              var b = this._ptr[x], N = this._ptr[x + 1], d = b;
              d < N;
              d++
            ) {
              var y = this._index[d];
              yield { value: this._values[d], index: [y, x] };
            }
        }),
        (n.prototype.toArray = function () {
          return v(this._values, this._index, this._ptr, this._size, !0);
        }),
        (n.prototype.valueOf = function () {
          return v(this._values, this._index, this._ptr, this._size, !1);
        });
      function v(h, x, b, N, d) {
        var y = N[0],
          w = N[1],
          g = [],
          S,
          A;
        for (S = 0; S < y; S++) for (g[S] = [], A = 0; A < w; A++) g[S][A] = 0;
        for (A = 0; A < w; A++)
          for (var E = b[A], M = b[A + 1], B = E; B < M; B++)
            (S = x[B]), (g[S][A] = h ? (d ? Fe(h[B]) : h[B]) : 1);
        return g;
      }
      return (
        (n.prototype.format = function (h) {
          for (
            var x = this._size[0],
              b = this._size[1],
              N = this.density(),
              d =
                "Sparse Matrix [" +
                Ze(x, h) +
                " x " +
                Ze(b, h) +
                "] density: " +
                Ze(N, h) +
                `
`,
              y = 0;
            y < b;
            y++
          )
            for (
              var w = this._ptr[y], g = this._ptr[y + 1], S = w;
              S < g;
              S++
            ) {
              var A = this._index[S];
              d +=
                `
    (` +
                Ze(A, h) +
                ", " +
                Ze(y, h) +
                ") ==> " +
                (this._values ? Ze(this._values[S], h) : "X");
            }
          return d;
        }),
        (n.prototype.toString = function () {
          return Ze(this.toArray());
        }),
        (n.prototype.toJSON = function () {
          return {
            mathjs: "SparseMatrix",
            values: this._values,
            index: this._index,
            ptr: this._ptr,
            size: this._size,
            datatype: this._datatype,
          };
        }),
        (n.prototype.diagonal = function (h) {
          if (h) {
            if ((Qe(h) && (h = h.toNumber()), !je(h) || !Be(h)))
              throw new TypeError("The parameter k must be an integer number");
          } else h = 0;
          var x = h > 0 ? h : 0,
            b = h < 0 ? -h : 0,
            N = this._size[0],
            d = this._size[1],
            y = Math.min(N - b, d - x),
            w = [],
            g = [],
            S = [];
          S[0] = 0;
          for (var A = x; A < d && w.length < y; A++)
            for (
              var E = this._ptr[A], M = this._ptr[A + 1], B = E;
              B < M;
              B++
            ) {
              var C = this._index[B];
              if (C === A - x + b) {
                w.push(this._values[B]), (g[w.length - 1] = C - b);
                break;
              }
            }
          return (
            S.push(w.length),
            new n({ values: w, index: g, ptr: S, size: [y, 1] })
          );
        }),
        (n.fromJSON = function (h) {
          return new n(h);
        }),
        (n.diagonal = function (h, x, b, N, d) {
          if (!sr(h)) throw new TypeError("Array expected, size parameter");
          if (h.length !== 2)
            throw new Error("Only two dimensions matrix are supported");
          if (
            ((h = h.map(function (O) {
              if ((Qe(O) && (O = O.toNumber()), !je(O) || !Be(O) || O < 1))
                throw new Error("Size values must be positive integers");
              return O;
            })),
            b)
          ) {
            if ((Qe(b) && (b = b.toNumber()), !je(b) || !Be(b)))
              throw new TypeError("The parameter k must be an integer number");
          } else b = 0;
          var y = t,
            w = 0;
          et(d) && ((y = r.find(t, [d, d]) || t), (w = r.convert(0, d)));
          var g = b > 0 ? b : 0,
            S = b < 0 ? -b : 0,
            A = h[0],
            E = h[1],
            M = Math.min(A - S, E - g),
            B;
          if (sr(x)) {
            if (x.length !== M) throw new Error("Invalid value array length");
            B = function (H) {
              return x[H];
            };
          } else if (ze(x)) {
            var C = x.size();
            if (C.length !== 1 || C[0] !== M)
              throw new Error("Invalid matrix length");
            B = function (H) {
              return x.get([H]);
            };
          } else
            B = function () {
              return x;
            };
          for (var _ = [], z = [], I = [], T = 0; T < E; T++) {
            I.push(_.length);
            var D = T - g;
            if (D >= 0 && D < M) {
              var Z = B(D);
              y(Z, w) || (z.push(D + S), _.push(Z));
            }
          }
          return (
            I.push(_.length),
            new n({ values: _, index: z, ptr: I, size: [A, E] })
          );
        }),
        (n.prototype.swapRows = function (h, x) {
          if (!je(h) || !Be(h) || !je(x) || !Be(x))
            throw new Error("Row index must be positive integers");
          if (this._size.length !== 2)
            throw new Error("Only two dimensional matrix is supported");
          return (
            cr(h, this._size[0]),
            cr(x, this._size[0]),
            n._swapRows(
              h,
              x,
              this._size[1],
              this._values,
              this._index,
              this._ptr
            ),
            this
          );
        }),
        (n._forEachRow = function (h, x, b, N, d) {
          for (var y = N[h], w = N[h + 1], g = y; g < w; g++) d(b[g], x[g]);
        }),
        (n._swapRows = function (h, x, b, N, d, y) {
          for (var w = 0; w < b; w++) {
            var g = y[w],
              S = y[w + 1],
              A = u(h, g, S, d),
              E = u(x, g, S, d);
            if (A < S && E < S && d[A] === h && d[E] === x) {
              if (N) {
                var M = N[A];
                (N[A] = N[E]), (N[E] = M);
              }
              continue;
            }
            if (A < S && d[A] === h && (E >= S || d[E] !== x)) {
              var B = N ? N[A] : void 0;
              d.splice(E, 0, x),
                N && N.splice(E, 0, B),
                d.splice(E <= A ? A + 1 : A, 1),
                N && N.splice(E <= A ? A + 1 : A, 1);
              continue;
            }
            if (E < S && d[E] === x && (A >= S || d[A] !== h)) {
              var C = N ? N[E] : void 0;
              d.splice(A, 0, h),
                N && N.splice(A, 0, C),
                d.splice(A <= E ? E + 1 : E, 1),
                N && N.splice(A <= E ? E + 1 : E, 1);
            }
          }
        }),
        n
      );
    },
    { isClass: !0 }
  ),
  mx = "number",
  px = ["typed"];
function vx(e) {
  var r = e.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (r) {
    var t = { "0b": 2, "0o": 8, "0x": 16 }[r[1]],
      a = r[2],
      n = r[3];
    return { input: e, radix: t, integerPart: a, fractionalPart: n };
  } else return null;
}
function hx(e) {
  for (
    var r = parseInt(e.integerPart, e.radix), t = 0, a = 0;
    a < e.fractionalPart.length;
    a++
  ) {
    var n = parseInt(e.fractionalPart[a], e.radix);
    t += n / Math.pow(e.radix, a + 1);
  }
  var i = r + t;
  if (isNaN(i))
    throw new SyntaxError('String "' + e.input + '" is no valid number');
  return i;
}
var dx = P(mx, px, (e) => {
    var { typed: r } = e,
      t = r("number", {
        "": function () {
          return 0;
        },
        number: function (n) {
          return n;
        },
        string: function (n) {
          if (n === "NaN") return NaN;
          var i = vx(n);
          if (i) return hx(i);
          var c = 0,
            m = n.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
          m && ((c = Number(m[2])), (n = m[1]));
          var f = Number(n);
          if (isNaN(f))
            throw new SyntaxError('String "' + n + '" is no valid number');
          if (m) {
            if (f > 2 ** c - 1)
              throw new SyntaxError('String "'.concat(n, '" is out of range'));
            f >= 2 ** (c - 1) && (f = f - 2 ** c);
          }
          return f;
        },
        BigNumber: function (n) {
          return n.toNumber();
        },
        Fraction: function (n) {
          return n.valueOf();
        },
        Unit: function (n) {
          throw new Error("Second argument with valueless unit expected");
        },
        null: function (n) {
          return 0;
        },
        "Unit, string | Unit": function (n, i) {
          return n.toNumber(i);
        },
        "Array | Matrix": function (n) {
          return Oe(n, this);
        },
      });
    return (
      (t.fromJSON = function (a) {
        return parseFloat(a.value);
      }),
      t
    );
  }),
  ul = "string",
  gx = ["typed"],
  yx = P(ul, gx, (e) => {
    var { typed: r } = e;
    return r(ul, {
      "": function () {
        return "";
      },
      number: Sn,
      null: function (a) {
        return "null";
      },
      boolean: function (a) {
        return a + "";
      },
      string: function (a) {
        return a;
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
      any: function (a) {
        return String(a);
      },
    });
  }),
  ll = "boolean",
  bx = ["typed"],
  xx = P(ll, bx, (e) => {
    var { typed: r } = e;
    return r(ll, {
      "": function () {
        return !1;
      },
      boolean: function (a) {
        return a;
      },
      number: function (a) {
        return !!a;
      },
      null: function (a) {
        return !1;
      },
      BigNumber: function (a) {
        return !a.isZero();
      },
      string: function (a) {
        var n = a.toLowerCase();
        if (n === "true") return !0;
        if (n === "false") return !1;
        var i = Number(a);
        if (a !== "" && !isNaN(i)) return !!i;
        throw new Error('Cannot convert "' + a + '" to a boolean');
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  wx = "bignumber",
  Nx = ["typed", "BigNumber"],
  Mx = P(wx, Nx, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r("bignumber", {
      "": function () {
        return new t(0);
      },
      number: function (n) {
        return new t(n + "");
      },
      string: function (n) {
        var i = n.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (i) {
          var c = i[2],
            m = t(i[1]),
            f = new t(2).pow(Number(c));
          if (m.gt(f.sub(1)))
            throw new SyntaxError('String "'.concat(n, '" is out of range'));
          var u = new t(2).pow(Number(c) - 1);
          return m.gte(u) ? m.sub(f) : m;
        }
        return new t(n);
      },
      BigNumber: function (n) {
        return n;
      },
      Fraction: function (n) {
        return new t(n.n).div(n.d).times(n.s);
      },
      null: function (n) {
        return new t(0);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  Ax = "complex",
  Sx = ["typed", "Complex"],
  Ex = P(Ax, Sx, (e) => {
    var { typed: r, Complex: t } = e;
    return r("complex", {
      "": function () {
        return t.ZERO;
      },
      number: function (n) {
        return new t(n, 0);
      },
      "number, number": function (n, i) {
        return new t(n, i);
      },
      "BigNumber, BigNumber": function (n, i) {
        return new t(n.toNumber(), i.toNumber());
      },
      Fraction: function (n) {
        return new t(n.valueOf(), 0);
      },
      Complex: function (n) {
        return n.clone();
      },
      string: function (n) {
        return t(n);
      },
      null: function (n) {
        return t(0);
      },
      Object: function (n) {
        if ("re" in n && "im" in n) return new t(n.re, n.im);
        if (("r" in n && "phi" in n) || ("abs" in n && "arg" in n))
          return new t(n);
        throw new Error(
          "Expected object with properties (re and im) or (r and phi) or (abs and arg)"
        );
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  Cx = "fraction",
  $x = ["typed", "Fraction"],
  Ox = P(Cx, $x, (e) => {
    var { typed: r, Fraction: t } = e;
    return r("fraction", {
      number: function (n) {
        if (!isFinite(n) || isNaN(n))
          throw new Error(n + " cannot be represented as a fraction");
        return new t(n);
      },
      string: function (n) {
        return new t(n);
      },
      "number, number": function (n, i) {
        return new t(n, i);
      },
      null: function (n) {
        return new t(0);
      },
      BigNumber: function (n) {
        return new t(n.toString());
      },
      Fraction: function (n) {
        return n;
      },
      Object: function (n) {
        return new t(n);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  cl = "matrix",
  Tx = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"],
  Dx = P(cl, Tx, (e) => {
    var { typed: r, Matrix: t, DenseMatrix: a, SparseMatrix: n } = e;
    return r(cl, {
      "": function () {
        return i([]);
      },
      string: function (m) {
        return i([], m);
      },
      "string, string": function (m, f) {
        return i([], m, f);
      },
      Array: function (m) {
        return i(m);
      },
      Matrix: function (m) {
        return i(m, m.storage());
      },
      "Array | Matrix, string": i,
      "Array | Matrix, string, string": i,
    });
    function i(c, m, f) {
      if (m === "dense" || m === "default" || m === void 0) return new a(c, f);
      if (m === "sparse") return new n(c, f);
      throw new TypeError("Unknown matrix type " + JSON.stringify(m) + ".");
    }
  }),
  fl = "matrixFromFunction",
  Bx = ["typed", "matrix", "isZero"],
  _x = P(fl, Bx, (e) => {
    var { typed: r, matrix: t, isZero: a } = e;
    return r(fl, {
      "Array | Matrix, function, string, string": function (c, m, f, u) {
        return n(c, m, f, u);
      },
      "Array | Matrix, function, string": function (c, m, f) {
        return n(c, m, f);
      },
      "Matrix, function": function (c, m) {
        return n(c, m, "dense");
      },
      "Array, function": function (c, m) {
        return n(c, m, "dense").toArray();
      },
      "Array | Matrix, string, function": function (c, m, f) {
        return n(c, f, m);
      },
      "Array | Matrix, string, string, function": function (c, m, f, u) {
        return n(c, u, m, f);
      },
    });
    function n(i, c, m, f) {
      var u;
      return (
        f !== void 0 ? (u = t(m, f)) : (u = t(m)),
        u.resize(i),
        u.forEach(function (s, o) {
          var l = c(o);
          a(l) || u.set(o, l);
        }),
        u
      );
    }
  }),
  ml = "matrixFromRows",
  Ix = ["typed", "matrix", "flatten", "size"],
  Rx = P(ml, Ix, (e) => {
    var { typed: r, matrix: t, flatten: a, size: n } = e;
    return r(ml, {
      "...Array": function (f) {
        return i(f);
      },
      "...Matrix": function (f) {
        return t(i(f.map((u) => u.toArray())));
      },
    });
    function i(m) {
      if (m.length === 0)
        throw new TypeError(
          "At least one row is needed to construct a matrix."
        );
      var f = c(m[0]),
        u = [];
      for (var s of m) {
        var o = c(s);
        if (o !== f)
          throw new TypeError(
            "The vectors had different length: " + (f | 0) + " ≠ " + (o | 0)
          );
        u.push(a(s));
      }
      return u;
    }
    function c(m) {
      var f = n(m);
      if (f.length === 1) return f[0];
      if (f.length === 2) {
        if (f[0] === 1) return f[1];
        if (f[1] === 1) return f[0];
        throw new TypeError("At least one of the arguments is not a vector.");
      } else
        throw new TypeError(
          "Only one- or two-dimensional vectors are supported."
        );
    }
  }),
  pl = "matrixFromColumns",
  Fx = ["typed", "matrix", "flatten", "size"],
  Px = P(pl, Fx, (e) => {
    var { typed: r, matrix: t, flatten: a, size: n } = e;
    return r(pl, {
      "...Array": function (f) {
        return i(f);
      },
      "...Matrix": function (f) {
        return t(i(f.map((u) => u.toArray())));
      },
    });
    function i(m) {
      if (m.length === 0)
        throw new TypeError(
          "At least one column is needed to construct a matrix."
        );
      for (var f = c(m[0]), u = [], s = 0; s < f; s++) u[s] = [];
      for (var o of m) {
        var l = c(o);
        if (l !== f)
          throw new TypeError(
            "The vectors had different length: " + (f | 0) + " ≠ " + (l | 0)
          );
        for (var p = a(o), v = 0; v < f; v++) u[v].push(p[v]);
      }
      return u;
    }
    function c(m) {
      var f = n(m);
      if (f.length === 1) return f[0];
      if (f.length === 2) {
        if (f[0] === 1) return f[1];
        if (f[1] === 1) return f[0];
        throw new TypeError("At least one of the arguments is not a vector.");
      } else
        throw new TypeError(
          "Only one- or two-dimensional vectors are supported."
        );
    }
  }),
  vl = "splitUnit",
  qx = ["typed"],
  zx = P(vl, qx, (e) => {
    var { typed: r } = e;
    return r(vl, {
      "Unit, Array": function (a, n) {
        return a.splitUnit(n);
      },
    });
  }),
  hl = "unaryMinus",
  Ux = ["typed"],
  Lx = P(hl, Ux, (e) => {
    var { typed: r } = e;
    return r(hl, {
      number: cv,
      Complex: function (a) {
        return a.neg();
      },
      BigNumber: function (a) {
        return a.neg();
      },
      Fraction: function (a) {
        return a.neg();
      },
      Unit: function (a) {
        var n = a.clone();
        return (n.value = this(a.value)), n;
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  dl = "unaryPlus",
  kx = ["typed", "config", "BigNumber"],
  Vx = P(dl, kx, (e) => {
    var { typed: r, config: t, BigNumber: a } = e;
    return r(dl, {
      number: fv,
      Complex: function (i) {
        return i;
      },
      BigNumber: function (i) {
        return i;
      },
      Fraction: function (i) {
        return i;
      },
      Unit: function (i) {
        return i.clone();
      },
      "Array | Matrix": function (i) {
        return Oe(i, this);
      },
      "boolean | string": function (i) {
        return t.number === "BigNumber" ? new a(+i) : +i;
      },
    });
  }),
  gl = "abs",
  Gx = ["typed"],
  Hx = P(gl, Gx, (e) => {
    var { typed: r } = e;
    return r(gl, {
      number: sv,
      Complex: function (a) {
        return a.abs();
      },
      BigNumber: function (a) {
        return a.abs();
      },
      Fraction: function (a) {
        return a.abs();
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
      Unit: function (a) {
        return a.abs();
      },
    });
  }),
  yl = "apply",
  Zx = ["typed", "isInteger"],
  nh = P(yl, Zx, (e) => {
    var { typed: r, isInteger: t } = e;
    return r(yl, {
      "Array | Matrix, number | BigNumber, function": function (n, i, c) {
        if (!t(i)) throw new TypeError("Integer number expected for dimension");
        var m = Array.isArray(n) ? Xe(n) : n.size();
        if (i < 0 || i >= m.length) throw new At(i, m.length);
        return ze(n) ? n.create(qi(n.valueOf(), i, c)) : qi(n, i, c);
      },
    });
  });
function qi(e, r, t) {
  var a, n, i;
  if (r <= 0)
    if (Array.isArray(e[0])) {
      for (i = Jx(e), n = [], a = 0; a < i.length; a++)
        n[a] = qi(i[a], r - 1, t);
      return n;
    } else return t(e);
  else {
    for (n = [], a = 0; a < e.length; a++) n[a] = qi(e[a], r - 1, t);
    return n;
  }
}
function Jx(e) {
  var r = e.length,
    t = e[0].length,
    a,
    n,
    i = [];
  for (n = 0; n < t; n++) {
    var c = [];
    for (a = 0; a < r; a++) c.push(e[a][n]);
    i.push(c);
  }
  return i;
}
var bl = "addScalar",
  Wx = ["typed"],
  Xx = P(bl, Wx, (e) => {
    var { typed: r } = e;
    return r(bl, {
      "number, number": uv,
      "Complex, Complex": function (a, n) {
        return a.add(n);
      },
      "BigNumber, BigNumber": function (a, n) {
        return a.plus(n);
      },
      "Fraction, Fraction": function (a, n) {
        return a.add(n);
      },
      "Unit, Unit": function (a, n) {
        if (a.value === null || a.value === void 0)
          throw new Error("Parameter x contains a unit with undefined value");
        if (n.value === null || n.value === void 0)
          throw new Error("Parameter y contains a unit with undefined value");
        if (!a.equalBase(n)) throw new Error("Units do not match");
        var i = a.clone();
        return (i.value = this(i.value, n.value)), (i.fixPrefix = !1), i;
      },
    });
  }),
  xl = "cbrt",
  Yx = [
    "config",
    "typed",
    "isNegative",
    "unaryMinus",
    "matrix",
    "Complex",
    "BigNumber",
    "Fraction",
  ],
  Qx = P(xl, Yx, (e) => {
    var {
      config: r,
      typed: t,
      isNegative: a,
      unaryMinus: n,
      matrix: i,
      Complex: c,
      BigNumber: m,
      Fraction: f,
    } = e;
    return t(xl, {
      number: _a,
      Complex: u,
      "Complex, boolean": u,
      BigNumber: function (l) {
        return l.cbrt();
      },
      Unit: s,
      "Array | Matrix": function (l) {
        return Oe(l, this);
      },
    });
    function u(o, l) {
      var p = o.arg() / 3,
        v = o.abs(),
        h = new c(_a(v), 0).mul(new c(0, p).exp());
      if (l) {
        var x = [
          h,
          new c(_a(v), 0).mul(new c(0, p + (Math.PI * 2) / 3).exp()),
          new c(_a(v), 0).mul(new c(0, p - (Math.PI * 2) / 3).exp()),
        ];
        return r.matrix === "Array" ? x : i(x);
      } else return h;
    }
    function s(o) {
      if (o.value && Wt(o.value)) {
        var l = o.clone();
        return (l.value = 1), (l = l.pow(1 / 3)), (l.value = u(o.value)), l;
      } else {
        var p = a(o.value);
        p && (o.value = n(o.value));
        var v;
        Qe(o.value)
          ? (v = new m(1).div(3))
          : ha(o.value)
          ? (v = new f(1, 3))
          : (v = 1 / 3);
        var h = o.pow(v);
        return p && (h.value = n(h.value)), h;
      }
    }
  }),
  jx = "algorithm11",
  Kx = ["typed", "equalScalar"],
  Ur = P(jx, Kx, (e) => {
    var { typed: r, equalScalar: t } = e;
    return function (n, i, c, m) {
      var f = n._values,
        u = n._index,
        s = n._ptr,
        o = n._size,
        l = n._datatype;
      if (!f)
        throw new Error(
          "Cannot perform operation on Pattern Sparse Matrix and Scalar value"
        );
      var p = o[0],
        v = o[1],
        h,
        x = t,
        b = 0,
        N = c;
      typeof l == "string" &&
        ((h = l),
        (x = r.find(t, [h, h])),
        (b = r.convert(0, h)),
        (i = r.convert(i, h)),
        (N = r.find(c, [h, h])));
      for (var d = [], y = [], w = [], g = 0; g < v; g++) {
        w[g] = y.length;
        for (var S = s[g], A = s[g + 1], E = S; E < A; E++) {
          var M = u[E],
            B = m ? N(i, f[E]) : N(f[E], i);
          x(B, b) || (y.push(M), d.push(B));
        }
      }
      return (
        (w[v] = y.length),
        n.createSparseMatrix({
          values: d,
          index: y,
          ptr: w,
          size: [p, v],
          datatype: h,
        })
      );
    };
  }),
  ew = "algorithm12",
  rw = ["typed", "DenseMatrix"],
  Ir = P(ew, rw, (e) => {
    var { typed: r, DenseMatrix: t } = e;
    return function (n, i, c, m) {
      var f = n._values,
        u = n._index,
        s = n._ptr,
        o = n._size,
        l = n._datatype;
      if (!f)
        throw new Error(
          "Cannot perform operation on Pattern Sparse Matrix and Scalar value"
        );
      var p = o[0],
        v = o[1],
        h,
        x = c;
      typeof l == "string" &&
        ((h = l), (i = r.convert(i, h)), (x = r.find(c, [h, h])));
      for (var b = [], N = [], d = [], y = 0; y < v; y++) {
        for (var w = y + 1, g = s[y], S = s[y + 1], A = g; A < S; A++) {
          var E = u[A];
          (N[E] = f[A]), (d[E] = w);
        }
        for (var M = 0; M < p; M++)
          y === 0 && (b[M] = []),
            d[M] === w
              ? (b[M][y] = m ? x(i, N[M]) : x(N[M], i))
              : (b[M][y] = m ? x(i, 0) : x(0, i));
      }
      return new t({ data: b, size: [p, v], datatype: h });
    };
  }),
  tw = "algorithm14",
  nw = ["typed"],
  ar = P(tw, nw, (e) => {
    var { typed: r } = e;
    return function (n, i, c, m) {
      var f = n._data,
        u = n._size,
        s = n._datatype,
        o,
        l = c;
      typeof s == "string" &&
        ((o = s), (i = r.convert(i, o)), (l = r.find(c, [o, o])));
      var p = u.length > 0 ? t(l, 0, u, u[0], f, i, m) : [];
      return n.createDenseMatrix({ data: p, size: Fe(u), datatype: o });
    };
    function t(a, n, i, c, m, f, u) {
      var s = [];
      if (n === i.length - 1)
        for (var o = 0; o < c; o++) s[o] = u ? a(f, m[o]) : a(m[o], f);
      else
        for (var l = 0; l < c; l++) s[l] = t(a, n + 1, i, i[n + 1], m[l], f, u);
      return s;
    }
  }),
  bs = "ceil",
  aw = [
    "typed",
    "config",
    "round",
    "matrix",
    "equalScalar",
    "zeros",
    "DenseMatrix",
  ],
  iw = P(bs, ["typed", "config", "round"], (e) => {
    var { typed: r, config: t, round: a } = e;
    return r(bs, {
      number: function (i) {
        return nt(i, a(i), t.epsilon) ? a(i) : Math.ceil(i);
      },
      "number, number": function (i, c) {
        if (nt(i, a(i, c), t.epsilon)) return a(i, c);
        var [m, f] = "".concat(i, "e").split("e"),
          u = Math.ceil(Number("".concat(m, "e").concat(Number(f) + c)));
        return (
          ([m, f] = "".concat(u, "e").split("e")),
          Number("".concat(m, "e").concat(Number(f) - c))
        );
      },
    });
  }),
  ow = P(bs, aw, (e) => {
    var {
        typed: r,
        config: t,
        round: a,
        matrix: n,
        equalScalar: i,
        zeros: c,
        DenseMatrix: m,
      } = e,
      f = Ur({ typed: r, equalScalar: i }),
      u = Ir({ typed: r, DenseMatrix: m }),
      s = ar({ typed: r }),
      o = iw({ typed: r, config: t, round: a });
    return r("ceil", {
      number: o.signatures.number,
      "number,number": o.signatures["number,number"],
      Complex: function (p) {
        return p.ceil();
      },
      "Complex, number": function (p, v) {
        return p.ceil(v);
      },
      "Complex, BigNumber": function (p, v) {
        return p.ceil(v.toNumber());
      },
      BigNumber: function (p) {
        return Pt(p, a(p), t.epsilon) ? a(p) : p.ceil();
      },
      "BigNumber, BigNumber": function (p, v) {
        return Pt(p, a(p, v), t.epsilon)
          ? a(p, v)
          : p.toDecimalPlaces(v.toNumber(), dn.ROUND_CEIL);
      },
      Fraction: function (p) {
        return p.ceil();
      },
      "Fraction, number": function (p, v) {
        return p.ceil(v);
      },
      "Fraction, BigNumber": function (p, v) {
        return p.ceil(v.toNumber());
      },
      "Array | Matrix": function (p) {
        return Oe(p, this);
      },
      "Array, number | BigNumber": function (p, v) {
        return Oe(p, (h) => this(h, v));
      },
      "SparseMatrix, number | BigNumber": function (p, v) {
        return f(p, v, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (p, v) {
        return s(p, v, this, !1);
      },
      "number | Complex | Fraction | BigNumber, Array": function (p, v) {
        return s(n(v), p, this, !0).valueOf();
      },
      "number | Complex | Fraction | BigNumber, Matrix": function (p, v) {
        return i(p, 0)
          ? c(v.size(), v.storage())
          : v.storage() === "dense"
          ? s(v, p, this, !0)
          : u(v, p, this, !0);
      },
    });
  }),
  wl = "cube",
  sw = ["typed"],
  uw = P(wl, sw, (e) => {
    var { typed: r } = e;
    return r(wl, {
      number: mv,
      Complex: function (a) {
        return a.mul(a).mul(a);
      },
      BigNumber: function (a) {
        return a.times(a).times(a);
      },
      Fraction: function (a) {
        return a.pow(3);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
      Unit: function (a) {
        return a.pow(3);
      },
    });
  }),
  Nl = "exp",
  lw = ["typed"],
  cw = P(Nl, lw, (e) => {
    var { typed: r } = e;
    return r(Nl, {
      number: pv,
      Complex: function (a) {
        return a.exp();
      },
      BigNumber: function (a) {
        return a.exp();
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Ml = "expm1",
  fw = ["typed", "Complex"],
  mw = P(Ml, fw, (e) => {
    var { typed: r, Complex: t } = e;
    return r(Ml, {
      number: vv,
      Complex: function (n) {
        var i = Math.exp(n.re);
        return new t(i * Math.cos(n.im) - 1, i * Math.sin(n.im));
      },
      BigNumber: function (n) {
        return n.exp().minus(1);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  xs = "fix",
  pw = [
    "typed",
    "Complex",
    "matrix",
    "ceil",
    "floor",
    "equalScalar",
    "zeros",
    "DenseMatrix",
  ],
  vw = P(xs, ["typed", "ceil", "floor"], (e) => {
    var { typed: r, ceil: t, floor: a } = e;
    return r(xs, {
      number: function (i) {
        return i > 0 ? a(i) : t(i);
      },
      "number, number": function (i, c) {
        return i > 0 ? a(i, c) : t(i, c);
      },
    });
  }),
  hw = P(xs, pw, (e) => {
    var {
        typed: r,
        Complex: t,
        matrix: a,
        ceil: n,
        floor: i,
        equalScalar: c,
        zeros: m,
        DenseMatrix: f,
      } = e,
      u = Ir({ typed: r, DenseMatrix: f }),
      s = ar({ typed: r }),
      o = vw({ typed: r, ceil: n, floor: i });
    return r("fix", {
      number: o.signatures.number,
      "number, number | BigNumber": o.signatures["number,number"],
      Complex: function (p) {
        return new t(
          p.re > 0 ? Math.floor(p.re) : Math.ceil(p.re),
          p.im > 0 ? Math.floor(p.im) : Math.ceil(p.im)
        );
      },
      "Complex, number": function (p, v) {
        return new t(
          p.re > 0 ? i(p.re, v) : n(p.re, v),
          p.im > 0 ? i(p.im, v) : n(p.im, v)
        );
      },
      "Complex, BigNumber": function (p, v) {
        var h = v.toNumber();
        return new t(
          p.re > 0 ? i(p.re, h) : n(p.re, h),
          p.im > 0 ? i(p.im, h) : n(p.im, h)
        );
      },
      BigNumber: function (p) {
        return p.isNegative() ? n(p) : i(p);
      },
      "BigNumber, number | BigNumber": function (p, v) {
        return p.isNegative() ? n(p, v) : i(p, v);
      },
      Fraction: function (p) {
        return p.s < 0 ? p.ceil() : p.floor();
      },
      "Fraction, number | BigNumber": function (p, v) {
        return p.s < 0 ? n(p, v) : i(p, v);
      },
      "Array | Matrix": function (p) {
        return Oe(p, this);
      },
      "Array | Matrix, number | BigNumber": function (p, v) {
        return Oe(p, (h) => this(h, v));
      },
      "number | Complex | Fraction | BigNumber, Array": function (p, v) {
        return s(a(v), p, this, !0).valueOf();
      },
      "number | Complex | Fraction | BigNumber, Matrix": function (p, v) {
        return c(p, 0)
          ? m(v.size(), v.storage())
          : v.storage() === "dense"
          ? s(v, p, this, !0)
          : u(v, p, this, !0);
      },
    });
  }),
  ws = "floor",
  dw = [
    "typed",
    "config",
    "round",
    "matrix",
    "equalScalar",
    "zeros",
    "DenseMatrix",
  ],
  gw = P(ws, ["typed", "config", "round"], (e) => {
    var { typed: r, config: t, round: a } = e;
    return r(ws, {
      number: function (i) {
        return nt(i, a(i), t.epsilon) ? a(i) : Math.floor(i);
      },
      "number, number": function (i, c) {
        if (nt(i, a(i, c), t.epsilon)) return a(i, c);
        var [m, f] = "".concat(i, "e").split("e"),
          u = Math.floor(Number("".concat(m, "e").concat(Number(f) + c)));
        return (
          ([m, f] = "".concat(u, "e").split("e")),
          Number("".concat(m, "e").concat(Number(f) - c))
        );
      },
    });
  }),
  yw = P(ws, dw, (e) => {
    var {
        typed: r,
        config: t,
        round: a,
        matrix: n,
        equalScalar: i,
        zeros: c,
        DenseMatrix: m,
      } = e,
      f = Ur({ typed: r, equalScalar: i }),
      u = Ir({ typed: r, DenseMatrix: m }),
      s = ar({ typed: r }),
      o = gw({ typed: r, config: t, round: a });
    return r("floor", {
      number: o.signatures.number,
      "number,number": o.signatures["number,number"],
      Complex: function (p) {
        return p.floor();
      },
      "Complex, number": function (p, v) {
        return p.floor(v);
      },
      "Complex, BigNumber": function (p, v) {
        return p.floor(v.toNumber());
      },
      BigNumber: function (p) {
        return Pt(p, a(p), t.epsilon) ? a(p) : p.floor();
      },
      "BigNumber, BigNumber": function (p, v) {
        return Pt(p, a(p, v), t.epsilon)
          ? a(p, v)
          : p.toDecimalPlaces(v.toNumber(), dn.ROUND_FLOOR);
      },
      Fraction: function (p) {
        return p.floor();
      },
      "Fraction, number": function (p, v) {
        return p.floor(v);
      },
      "Fraction, BigNumber": function (p, v) {
        return p.floor(v.toNumber());
      },
      "Array | Matrix": function (p) {
        return Oe(p, this);
      },
      "Array, number | BigNumber": function (p, v) {
        return Oe(p, (h) => this(h, v));
      },
      "SparseMatrix, number | BigNumber": function (p, v) {
        return f(p, v, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (p, v) {
        return s(p, v, this, !1);
      },
      "number | Complex | Fraction | BigNumber, Array": function (p, v) {
        return s(n(v), p, this, !0).valueOf();
      },
      "number | Complex | Fraction | BigNumber, Matrix": function (p, v) {
        return i(p, 0)
          ? c(v.size(), v.storage())
          : v.storage() === "dense"
          ? s(v, p, this, !0)
          : u(v, p, this, !0);
      },
    });
  }),
  bw = "algorithm01",
  xw = ["typed"],
  bn = P(bw, xw, (e) => {
    var { typed: r } = e;
    return function (a, n, i, c) {
      var m = a._data,
        f = a._size,
        u = a._datatype,
        s = n._values,
        o = n._index,
        l = n._ptr,
        p = n._size,
        v = n._datatype;
      if (f.length !== p.length) throw new Je(f.length, p.length);
      if (f[0] !== p[0] || f[1] !== p[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            f +
            ") must match Matrix B (" +
            p +
            ")"
        );
      if (!s)
        throw new Error(
          "Cannot perform operation on Dense Matrix and Pattern Sparse Matrix"
        );
      var h = f[0],
        x = f[1],
        b = typeof u == "string" && u === v ? u : void 0,
        N = b ? r.find(i, [b, b]) : i,
        d,
        y,
        w = [];
      for (d = 0; d < h; d++) w[d] = [];
      var g = [],
        S = [];
      for (y = 0; y < x; y++) {
        for (var A = y + 1, E = l[y], M = l[y + 1], B = E; B < M; B++)
          (d = o[B]),
            (g[d] = c ? N(s[B], m[d][y]) : N(m[d][y], s[B])),
            (S[d] = A);
        for (d = 0; d < h; d++)
          S[d] === A ? (w[d][y] = g[d]) : (w[d][y] = m[d][y]);
      }
      return a.createDenseMatrix({ data: w, size: [h, x], datatype: b });
    };
  }),
  ww = "algorithm04",
  Nw = ["typed", "equalScalar"],
  Ys = P(ww, Nw, (e) => {
    var { typed: r, equalScalar: t } = e;
    return function (n, i, c) {
      var m = n._values,
        f = n._index,
        u = n._ptr,
        s = n._size,
        o = n._datatype,
        l = i._values,
        p = i._index,
        v = i._ptr,
        h = i._size,
        x = i._datatype;
      if (s.length !== h.length) throw new Je(s.length, h.length);
      if (s[0] !== h[0] || s[1] !== h[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            s +
            ") must match Matrix B (" +
            h +
            ")"
        );
      var b = s[0],
        N = s[1],
        d,
        y = t,
        w = 0,
        g = c;
      typeof o == "string" &&
        o === x &&
        ((d = o),
        (y = r.find(t, [d, d])),
        (w = r.convert(0, d)),
        (g = r.find(c, [d, d])));
      var S = m && l ? [] : void 0,
        A = [],
        E = [],
        M = m && l ? [] : void 0,
        B = m && l ? [] : void 0,
        C = [],
        _ = [],
        z,
        I,
        T,
        D,
        Z;
      for (I = 0; I < N; I++) {
        E[I] = A.length;
        var O = I + 1;
        for (D = u[I], Z = u[I + 1], T = D; T < Z; T++)
          (z = f[T]), A.push(z), (C[z] = O), M && (M[z] = m[T]);
        for (D = v[I], Z = v[I + 1], T = D; T < Z; T++)
          if (((z = p[T]), C[z] === O)) {
            if (M) {
              var H = g(M[z], l[T]);
              y(H, w) ? (C[z] = null) : (M[z] = H);
            }
          } else A.push(z), (_[z] = O), B && (B[z] = l[T]);
        if (M && B)
          for (T = E[I]; T < A.length; )
            (z = A[T]),
              C[z] === O
                ? ((S[T] = M[z]), T++)
                : _[z] === O
                ? ((S[T] = B[z]), T++)
                : A.splice(T, 1);
      }
      return (
        (E[N] = A.length),
        n.createSparseMatrix({
          values: S,
          index: A,
          ptr: E,
          size: [b, N],
          datatype: d,
        })
      );
    };
  }),
  Mw = "algorithm10",
  Aw = ["typed", "DenseMatrix"],
  Dn = P(Mw, Aw, (e) => {
    var { typed: r, DenseMatrix: t } = e;
    return function (n, i, c, m) {
      var f = n._values,
        u = n._index,
        s = n._ptr,
        o = n._size,
        l = n._datatype;
      if (!f)
        throw new Error(
          "Cannot perform operation on Pattern Sparse Matrix and Scalar value"
        );
      var p = o[0],
        v = o[1],
        h,
        x = c;
      typeof l == "string" &&
        ((h = l), (i = r.convert(i, h)), (x = r.find(c, [h, h])));
      for (var b = [], N = [], d = [], y = 0; y < v; y++) {
        for (var w = y + 1, g = s[y], S = s[y + 1], A = g; A < S; A++) {
          var E = u[A];
          (N[E] = f[A]), (d[E] = w);
        }
        for (var M = 0; M < p; M++)
          y === 0 && (b[M] = []),
            d[M] === w
              ? (b[M][y] = m ? x(i, N[M]) : x(N[M], i))
              : (b[M][y] = i);
      }
      return new t({ data: b, size: [p, v], datatype: h });
    };
  }),
  Sw = "algorithm13",
  Ew = ["typed"],
  hr = P(Sw, Ew, (e) => {
    var { typed: r } = e;
    return function (n, i, c) {
      var m = n._data,
        f = n._size,
        u = n._datatype,
        s = i._data,
        o = i._size,
        l = i._datatype,
        p = [];
      if (f.length !== o.length) throw new Je(f.length, o.length);
      for (var v = 0; v < f.length; v++) {
        if (f[v] !== o[v])
          throw new RangeError(
            "Dimension mismatch. Matrix A (" +
              f +
              ") must match Matrix B (" +
              o +
              ")"
          );
        p[v] = f[v];
      }
      var h,
        x = c;
      typeof u == "string" && u === l && ((h = u), (x = r.find(c, [h, h])));
      var b = p.length > 0 ? t(x, 0, p, p[0], m, s) : [];
      return n.createDenseMatrix({ data: b, size: p, datatype: h });
    };
    function t(a, n, i, c, m, f) {
      var u = [];
      if (n === i.length - 1) for (var s = 0; s < c; s++) u[s] = a(m[s], f[s]);
      else
        for (var o = 0; o < c; o++) u[o] = t(a, n + 1, i, i[n + 1], m[o], f[o]);
      return u;
    }
  }),
  Al = "gcd",
  Cw = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"],
  $w = P(Al, Cw, (e) => {
    var {
        typed: r,
        matrix: t,
        equalScalar: a,
        BigNumber: n,
        DenseMatrix: i,
      } = e,
      c = bn({ typed: r }),
      m = Ys({ typed: r, equalScalar: a }),
      f = Dn({ typed: r, DenseMatrix: i }),
      u = hr({ typed: r }),
      s = ar({ typed: r });
    return r(Al, {
      "number, number": hv,
      "BigNumber, BigNumber": o,
      "Fraction, Fraction": function (p, v) {
        return p.gcd(v);
      },
      "SparseMatrix, SparseMatrix": function (p, v) {
        return m(p, v, this);
      },
      "SparseMatrix, DenseMatrix": function (p, v) {
        return c(v, p, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (p, v) {
        return c(p, v, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (p, v) {
        return u(p, v, this);
      },
      "Array, Array": function (p, v) {
        return this(t(p), t(v)).valueOf();
      },
      "Array, Matrix": function (p, v) {
        return this(t(p), v);
      },
      "Matrix, Array": function (p, v) {
        return this(p, t(v));
      },
      "SparseMatrix, number | BigNumber": function (p, v) {
        return f(p, v, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (p, v) {
        return s(p, v, this, !1);
      },
      "number | BigNumber, SparseMatrix": function (p, v) {
        return f(v, p, this, !0);
      },
      "number | BigNumber, DenseMatrix": function (p, v) {
        return s(v, p, this, !0);
      },
      "Array, number | BigNumber": function (p, v) {
        return s(t(p), v, this, !1).valueOf();
      },
      "number | BigNumber, Array": function (p, v) {
        return s(t(v), p, this, !0).valueOf();
      },
      "Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber":
        function (p, v, h) {
          for (var x = this(p, v), b = 0; b < h.length; b++) x = this(x, h[b]);
          return x;
        },
    });
    function o(l, p) {
      if (!l.isInt() || !p.isInt())
        throw new Error("Parameters in function gcd must be integer numbers");
      for (var v = new n(0); !p.isZero(); ) {
        var h = l.mod(p);
        (l = p), (p = h);
      }
      return l.lt(v) ? l.neg() : l;
    }
  }),
  Ow = "algorithm02",
  Tw = ["typed", "equalScalar"],
  Et = P(Ow, Tw, (e) => {
    var { typed: r, equalScalar: t } = e;
    return function (n, i, c, m) {
      var f = n._data,
        u = n._size,
        s = n._datatype,
        o = i._values,
        l = i._index,
        p = i._ptr,
        v = i._size,
        h = i._datatype;
      if (u.length !== v.length) throw new Je(u.length, v.length);
      if (u[0] !== v[0] || u[1] !== v[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            u +
            ") must match Matrix B (" +
            v +
            ")"
        );
      if (!o)
        throw new Error(
          "Cannot perform operation on Dense Matrix and Pattern Sparse Matrix"
        );
      var x = u[0],
        b = u[1],
        N,
        d = t,
        y = 0,
        w = c;
      typeof s == "string" &&
        s === h &&
        ((N = s),
        (d = r.find(t, [N, N])),
        (y = r.convert(0, N)),
        (w = r.find(c, [N, N])));
      for (var g = [], S = [], A = [], E = 0; E < b; E++) {
        A[E] = S.length;
        for (var M = p[E], B = p[E + 1], C = M; C < B; C++) {
          var _ = l[C],
            z = m ? w(o[C], f[_][E]) : w(f[_][E], o[C]);
          d(z, y) || (S.push(_), g.push(z));
        }
      }
      return (
        (A[b] = S.length),
        i.createSparseMatrix({
          values: g,
          index: S,
          ptr: A,
          size: [x, b],
          datatype: N,
        })
      );
    };
  }),
  Dw = "algorithm06",
  Bw = ["typed", "equalScalar"],
  no = P(Dw, Bw, (e) => {
    var { typed: r, equalScalar: t } = e;
    return function (n, i, c) {
      var m = n._values,
        f = n._size,
        u = n._datatype,
        s = i._values,
        o = i._size,
        l = i._datatype;
      if (f.length !== o.length) throw new Je(f.length, o.length);
      if (f[0] !== o[0] || f[1] !== o[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            f +
            ") must match Matrix B (" +
            o +
            ")"
        );
      var p = f[0],
        v = f[1],
        h,
        x = t,
        b = 0,
        N = c;
      typeof u == "string" &&
        u === l &&
        ((h = u),
        (x = r.find(t, [h, h])),
        (b = r.convert(0, h)),
        (N = r.find(c, [h, h])));
      for (
        var d = m && s ? [] : void 0,
          y = [],
          w = [],
          g = d ? [] : void 0,
          S = [],
          A = [],
          E = 0;
        E < v;
        E++
      ) {
        w[E] = y.length;
        var M = E + 1;
        if ((Yu(n, E, S, g, A, M, y, N), Yu(i, E, S, g, A, M, y, N), g))
          for (var B = w[E]; B < y.length; ) {
            var C = y[B];
            if (A[C] === M) {
              var _ = g[C];
              x(_, b) ? y.splice(B, 1) : (d.push(_), B++);
            } else y.splice(B, 1);
          }
        else
          for (var z = w[E]; z < y.length; ) {
            var I = y[z];
            A[I] !== M ? y.splice(z, 1) : z++;
          }
      }
      return (
        (w[v] = y.length),
        n.createSparseMatrix({
          values: d,
          index: y,
          ptr: w,
          size: [p, v],
          datatype: h,
        })
      );
    };
  }),
  Sl = "lcm",
  _w = ["typed", "matrix", "equalScalar"],
  Iw = P(Sl, _w, (e) => {
    var { typed: r, matrix: t, equalScalar: a } = e,
      n = Et({ typed: r, equalScalar: a }),
      i = no({ typed: r, equalScalar: a }),
      c = Ur({ typed: r, equalScalar: a }),
      m = hr({ typed: r }),
      f = ar({ typed: r });
    return r(Sl, {
      "number, number": dv,
      "BigNumber, BigNumber": u,
      "Fraction, Fraction": function (o, l) {
        return o.lcm(l);
      },
      "SparseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, this);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return n(l, o, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return n(o, l, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return m(o, l, this);
      },
      "Array, Array": function (o, l) {
        return this(t(o), t(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(t(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, t(l));
      },
      "SparseMatrix, number | BigNumber": function (o, l) {
        return c(o, l, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (o, l) {
        return f(o, l, this, !1);
      },
      "number | BigNumber, SparseMatrix": function (o, l) {
        return c(l, o, this, !0);
      },
      "number | BigNumber, DenseMatrix": function (o, l) {
        return f(l, o, this, !0);
      },
      "Array, number | BigNumber": function (o, l) {
        return f(t(o), l, this, !1).valueOf();
      },
      "number | BigNumber, Array": function (o, l) {
        return f(t(l), o, this, !0).valueOf();
      },
      "Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber":
        function (o, l, p) {
          for (var v = this(o, l), h = 0; h < p.length; h++) v = this(v, p[h]);
          return v;
        },
    });
    function u(s, o) {
      if (!s.isInt() || !o.isInt())
        throw new Error("Parameters in function lcm must be integer numbers");
      if (s.isZero()) return s;
      if (o.isZero()) return o;
      for (var l = s.times(o); !o.isZero(); ) {
        var p = o;
        (o = s.mod(p)), (s = p);
      }
      return l.div(s).abs();
    }
  }),
  El = "log10",
  Rw = ["typed", "config", "Complex"],
  Fw = P(El, Rw, (e) => {
    var { typed: r, config: t, Complex: a } = e;
    return r(El, {
      number: function (i) {
        return i >= 0 || t.predictable
          ? gv(i)
          : new a(i, 0).log().div(Math.LN10);
      },
      Complex: function (i) {
        return new a(i).log().div(Math.LN10);
      },
      BigNumber: function (i) {
        return !i.isNegative() || t.predictable
          ? i.log()
          : new a(i.toNumber(), 0).log().div(Math.LN10);
      },
      "Array | Matrix": function (i) {
        return Oe(i, this);
      },
    });
  }),
  Cl = "log2",
  Pw = ["typed", "config", "Complex"],
  qw = P(Cl, Pw, (e) => {
    var { typed: r, config: t, Complex: a } = e;
    return r(Cl, {
      number: function (c) {
        return c >= 0 || t.predictable ? yv(c) : n(new a(c, 0));
      },
      Complex: n,
      BigNumber: function (c) {
        return !c.isNegative() || t.predictable
          ? c.log(2)
          : n(new a(c.toNumber(), 0));
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
    });
    function n(i) {
      var c = Math.sqrt(i.re * i.re + i.im * i.im);
      return new a(
        Math.log2 ? Math.log2(c) : Math.log(c) / Math.LN2,
        Math.atan2(i.im, i.re) / Math.LN2
      );
    }
  }),
  zw = "algorithm03",
  Uw = ["typed"],
  Yr = P(zw, Uw, (e) => {
    var { typed: r } = e;
    return function (a, n, i, c) {
      var m = a._data,
        f = a._size,
        u = a._datatype,
        s = n._values,
        o = n._index,
        l = n._ptr,
        p = n._size,
        v = n._datatype;
      if (f.length !== p.length) throw new Je(f.length, p.length);
      if (f[0] !== p[0] || f[1] !== p[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            f +
            ") must match Matrix B (" +
            p +
            ")"
        );
      if (!s)
        throw new Error(
          "Cannot perform operation on Dense Matrix and Pattern Sparse Matrix"
        );
      var h = f[0],
        x = f[1],
        b,
        N = 0,
        d = i;
      typeof u == "string" &&
        u === v &&
        ((b = u), (N = r.convert(0, b)), (d = r.find(i, [b, b])));
      for (var y = [], w = 0; w < h; w++) y[w] = [];
      for (var g = [], S = [], A = 0; A < x; A++) {
        for (var E = A + 1, M = l[A], B = l[A + 1], C = M; C < B; C++) {
          var _ = o[C];
          (g[_] = c ? d(s[C], m[_][A]) : d(m[_][A], s[C])), (S[_] = E);
        }
        for (var z = 0; z < h; z++)
          S[z] === E
            ? (y[z][A] = g[z])
            : (y[z][A] = c ? d(N, m[z][A]) : d(m[z][A], N));
      }
      return a.createDenseMatrix({ data: y, size: [h, x], datatype: b });
    };
  }),
  Lw = "algorithm05",
  kw = ["typed", "equalScalar"],
  ao = P(Lw, kw, (e) => {
    var { typed: r, equalScalar: t } = e;
    return function (n, i, c) {
      var m = n._values,
        f = n._index,
        u = n._ptr,
        s = n._size,
        o = n._datatype,
        l = i._values,
        p = i._index,
        v = i._ptr,
        h = i._size,
        x = i._datatype;
      if (s.length !== h.length) throw new Je(s.length, h.length);
      if (s[0] !== h[0] || s[1] !== h[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            s +
            ") must match Matrix B (" +
            h +
            ")"
        );
      var b = s[0],
        N = s[1],
        d,
        y = t,
        w = 0,
        g = c;
      typeof o == "string" &&
        o === x &&
        ((d = o),
        (y = r.find(t, [d, d])),
        (w = r.convert(0, d)),
        (g = r.find(c, [d, d])));
      var S = m && l ? [] : void 0,
        A = [],
        E = [],
        M = S ? [] : void 0,
        B = S ? [] : void 0,
        C = [],
        _ = [],
        z,
        I,
        T,
        D;
      for (I = 0; I < N; I++) {
        E[I] = A.length;
        var Z = I + 1;
        for (T = u[I], D = u[I + 1]; T < D; T++)
          (z = f[T]), A.push(z), (C[z] = Z), M && (M[z] = m[T]);
        for (T = v[I], D = v[I + 1]; T < D; T++)
          (z = p[T]), C[z] !== Z && A.push(z), (_[z] = Z), B && (B[z] = l[T]);
        if (S)
          for (T = E[I]; T < A.length; ) {
            z = A[T];
            var O = C[z],
              H = _[z];
            if (O === Z || H === Z) {
              var Q = O === Z ? M[z] : w,
                te = H === Z ? B[z] : w,
                J = g(Q, te);
              y(J, w) ? A.splice(T, 1) : (S.push(J), T++);
            }
          }
      }
      return (
        (E[N] = A.length),
        n.createSparseMatrix({
          values: S,
          index: A,
          ptr: E,
          size: [b, N],
          datatype: d,
        })
      );
    };
  }),
  $l = "mod",
  Vw = ["typed", "matrix", "equalScalar", "DenseMatrix"],
  Gw = P($l, Vw, (e) => {
    var { typed: r, matrix: t, equalScalar: a, DenseMatrix: n } = e,
      i = Et({ typed: r, equalScalar: a }),
      c = Yr({ typed: r }),
      m = ao({ typed: r, equalScalar: a }),
      f = Ur({ typed: r, equalScalar: a }),
      u = Ir({ typed: r, DenseMatrix: n }),
      s = hr({ typed: r }),
      o = ar({ typed: r });
    return r($l, {
      "number, number": bv,
      "BigNumber, BigNumber": function (p, v) {
        if (v.isNeg())
          throw new Error("Cannot calculate mod for a negative divisor");
        return v.isZero() ? p : p.mod(v);
      },
      "Fraction, Fraction": function (p, v) {
        if (v.compare(0) < 0)
          throw new Error("Cannot calculate mod for a negative divisor");
        return p.compare(0) >= 0 ? p.mod(v) : p.mod(v).add(v).mod(v);
      },
      "SparseMatrix, SparseMatrix": function (p, v) {
        return m(p, v, this, !1);
      },
      "SparseMatrix, DenseMatrix": function (p, v) {
        return i(v, p, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (p, v) {
        return c(p, v, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (p, v) {
        return s(p, v, this);
      },
      "Array, Array": function (p, v) {
        return this(t(p), t(v)).valueOf();
      },
      "Array, Matrix": function (p, v) {
        return this(t(p), v);
      },
      "Matrix, Array": function (p, v) {
        return this(p, t(v));
      },
      "SparseMatrix, any": function (p, v) {
        return f(p, v, this, !1);
      },
      "DenseMatrix, any": function (p, v) {
        return o(p, v, this, !1);
      },
      "any, SparseMatrix": function (p, v) {
        return u(v, p, this, !0);
      },
      "any, DenseMatrix": function (p, v) {
        return o(v, p, this, !0);
      },
      "Array, any": function (p, v) {
        return o(t(p), v, this, !1).valueOf();
      },
      "any, Array": function (p, v) {
        return o(t(v), p, this, !0).valueOf();
      },
    });
  }),
  Hw = "multiplyScalar",
  Zw = ["typed"],
  Jw = P(Hw, Zw, (e) => {
    var { typed: r } = e;
    return r("multiplyScalar", {
      "number, number": lv,
      "Complex, Complex": function (a, n) {
        return a.mul(n);
      },
      "BigNumber, BigNumber": function (a, n) {
        return a.times(n);
      },
      "Fraction, Fraction": function (a, n) {
        return a.mul(n);
      },
      "number | Fraction | BigNumber | Complex, Unit": function (a, n) {
        var i = n.clone();
        return (
          (i.value = i.value === null ? i._normalize(a) : this(i.value, a)), i
        );
      },
      "Unit, number | Fraction | BigNumber | Complex": function (a, n) {
        var i = a.clone();
        return (
          (i.value = i.value === null ? i._normalize(n) : this(i.value, n)), i
        );
      },
      "Unit, Unit": function (a, n) {
        return a.multiply(n);
      },
    });
  }),
  Ol = "multiply",
  Ww = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"],
  Xw = P(Ol, Ww, (e) => {
    var {
        typed: r,
        matrix: t,
        addScalar: a,
        multiplyScalar: n,
        equalScalar: i,
        dot: c,
      } = e,
      m = Ur({ typed: r, equalScalar: i }),
      f = ar({ typed: r });
    function u(w, g) {
      switch (w.length) {
        case 1:
          switch (g.length) {
            case 1:
              if (w[0] !== g[0])
                throw new RangeError(
                  "Dimension mismatch in multiplication. Vectors must have the same length"
                );
              break;
            case 2:
              if (w[0] !== g[0])
                throw new RangeError(
                  "Dimension mismatch in multiplication. Vector length (" +
                    w[0] +
                    ") must match Matrix rows (" +
                    g[0] +
                    ")"
                );
              break;
            default:
              throw new Error(
                "Can only multiply a 1 or 2 dimensional matrix (Matrix B has " +
                  g.length +
                  " dimensions)"
              );
          }
          break;
        case 2:
          switch (g.length) {
            case 1:
              if (w[1] !== g[0])
                throw new RangeError(
                  "Dimension mismatch in multiplication. Matrix columns (" +
                    w[1] +
                    ") must match Vector length (" +
                    g[0] +
                    ")"
                );
              break;
            case 2:
              if (w[1] !== g[0])
                throw new RangeError(
                  "Dimension mismatch in multiplication. Matrix A columns (" +
                    w[1] +
                    ") must match Matrix B rows (" +
                    g[0] +
                    ")"
                );
              break;
            default:
              throw new Error(
                "Can only multiply a 1 or 2 dimensional matrix (Matrix B has " +
                  g.length +
                  " dimensions)"
              );
          }
          break;
        default:
          throw new Error(
            "Can only multiply a 1 or 2 dimensional matrix (Matrix A has " +
              w.length +
              " dimensions)"
          );
      }
    }
    function s(w, g, S) {
      if (S === 0) throw new Error("Cannot multiply two empty vectors");
      return c(w, g);
    }
    function o(w, g) {
      if (g.storage() !== "dense")
        throw new Error("Support for SparseMatrix not implemented");
      return l(w, g);
    }
    function l(w, g) {
      var S = w._data,
        A = w._size,
        E = w._datatype,
        M = g._data,
        B = g._size,
        C = g._datatype,
        _ = A[0],
        z = B[1],
        I,
        T = a,
        D = n;
      E &&
        C &&
        E === C &&
        typeof E == "string" &&
        ((I = E), (T = r.find(a, [I, I])), (D = r.find(n, [I, I])));
      for (var Z = [], O = 0; O < z; O++) {
        for (var H = D(S[0], M[0][O]), Q = 1; Q < _; Q++)
          H = T(H, D(S[Q], M[Q][O]));
        Z[O] = H;
      }
      return w.createDenseMatrix({ data: Z, size: [z], datatype: I });
    }
    var p = r("_multiplyMatrixVector", {
        "DenseMatrix, any": h,
        "SparseMatrix, any": N,
      }),
      v = r("_multiplyMatrixMatrix", {
        "DenseMatrix, DenseMatrix": x,
        "DenseMatrix, SparseMatrix": b,
        "SparseMatrix, DenseMatrix": d,
        "SparseMatrix, SparseMatrix": y,
      });
    function h(w, g) {
      var S = w._data,
        A = w._size,
        E = w._datatype,
        M = g._data,
        B = g._datatype,
        C = A[0],
        _ = A[1],
        z,
        I = a,
        T = n;
      E &&
        B &&
        E === B &&
        typeof E == "string" &&
        ((z = E), (I = r.find(a, [z, z])), (T = r.find(n, [z, z])));
      for (var D = [], Z = 0; Z < C; Z++) {
        for (var O = S[Z], H = T(O[0], M[0]), Q = 1; Q < _; Q++)
          H = I(H, T(O[Q], M[Q]));
        D[Z] = H;
      }
      return w.createDenseMatrix({ data: D, size: [C], datatype: z });
    }
    function x(w, g) {
      var S = w._data,
        A = w._size,
        E = w._datatype,
        M = g._data,
        B = g._size,
        C = g._datatype,
        _ = A[0],
        z = A[1],
        I = B[1],
        T,
        D = a,
        Z = n;
      E &&
        C &&
        E === C &&
        typeof E == "string" &&
        ((T = E), (D = r.find(a, [T, T])), (Z = r.find(n, [T, T])));
      for (var O = [], H = 0; H < _; H++) {
        var Q = S[H];
        O[H] = [];
        for (var te = 0; te < I; te++) {
          for (var J = Z(Q[0], M[0][te]), re = 1; re < z; re++)
            J = D(J, Z(Q[re], M[re][te]));
          O[H][te] = J;
        }
      }
      return w.createDenseMatrix({ data: O, size: [_, I], datatype: T });
    }
    function b(w, g) {
      var S = w._data,
        A = w._size,
        E = w._datatype,
        M = g._values,
        B = g._index,
        C = g._ptr,
        _ = g._size,
        z = g._datatype;
      if (!M)
        throw new Error(
          "Cannot multiply Dense Matrix times Pattern only Matrix"
        );
      var I = A[0],
        T = _[1],
        D,
        Z = a,
        O = n,
        H = i,
        Q = 0;
      E &&
        z &&
        E === z &&
        typeof E == "string" &&
        ((D = E),
        (Z = r.find(a, [D, D])),
        (O = r.find(n, [D, D])),
        (H = r.find(i, [D, D])),
        (Q = r.convert(0, D)));
      for (
        var te = [],
          J = [],
          re = [],
          oe = g.createSparseMatrix({
            values: te,
            index: J,
            ptr: re,
            size: [I, T],
            datatype: D,
          }),
          ae = 0;
        ae < T;
        ae++
      ) {
        re[ae] = J.length;
        var ce = C[ae],
          se = C[ae + 1];
        if (se > ce)
          for (var pe = 0, ne = 0; ne < I; ne++) {
            for (var Ae = ne + 1, Ce = void 0, ge = ce; ge < se; ge++) {
              var Se = B[ge];
              pe !== Ae
                ? ((Ce = O(S[ne][Se], M[ge])), (pe = Ae))
                : (Ce = Z(Ce, O(S[ne][Se], M[ge])));
            }
            pe === Ae && !H(Ce, Q) && (J.push(ne), te.push(Ce));
          }
      }
      return (re[T] = J.length), oe;
    }
    function N(w, g) {
      var S = w._values,
        A = w._index,
        E = w._ptr,
        M = w._datatype;
      if (!S)
        throw new Error(
          "Cannot multiply Pattern only Matrix times Dense Matrix"
        );
      var B = g._data,
        C = g._datatype,
        _ = w._size[0],
        z = g._size[0],
        I = [],
        T = [],
        D = [],
        Z,
        O = a,
        H = n,
        Q = i,
        te = 0;
      M &&
        C &&
        M === C &&
        typeof M == "string" &&
        ((Z = M),
        (O = r.find(a, [Z, Z])),
        (H = r.find(n, [Z, Z])),
        (Q = r.find(i, [Z, Z])),
        (te = r.convert(0, Z)));
      var J = [],
        re = [];
      D[0] = 0;
      for (var oe = 0; oe < z; oe++) {
        var ae = B[oe];
        if (!Q(ae, te))
          for (var ce = E[oe], se = E[oe + 1], pe = ce; pe < se; pe++) {
            var ne = A[pe];
            re[ne]
              ? (J[ne] = O(J[ne], H(ae, S[pe])))
              : ((re[ne] = !0), T.push(ne), (J[ne] = H(ae, S[pe])));
          }
      }
      for (var Ae = T.length, Ce = 0; Ce < Ae; Ce++) {
        var ge = T[Ce];
        I[Ce] = J[ge];
      }
      return (
        (D[1] = T.length),
        w.createSparseMatrix({
          values: I,
          index: T,
          ptr: D,
          size: [_, 1],
          datatype: Z,
        })
      );
    }
    function d(w, g) {
      var S = w._values,
        A = w._index,
        E = w._ptr,
        M = w._datatype;
      if (!S)
        throw new Error(
          "Cannot multiply Pattern only Matrix times Dense Matrix"
        );
      var B = g._data,
        C = g._datatype,
        _ = w._size[0],
        z = g._size[0],
        I = g._size[1],
        T,
        D = a,
        Z = n,
        O = i,
        H = 0;
      M &&
        C &&
        M === C &&
        typeof M == "string" &&
        ((T = M),
        (D = r.find(a, [T, T])),
        (Z = r.find(n, [T, T])),
        (O = r.find(i, [T, T])),
        (H = r.convert(0, T)));
      for (
        var Q = [],
          te = [],
          J = [],
          re = w.createSparseMatrix({
            values: Q,
            index: te,
            ptr: J,
            size: [_, I],
            datatype: T,
          }),
          oe = [],
          ae = [],
          ce = 0;
        ce < I;
        ce++
      ) {
        J[ce] = te.length;
        for (var se = ce + 1, pe = 0; pe < z; pe++) {
          var ne = B[pe][ce];
          if (!O(ne, H))
            for (var Ae = E[pe], Ce = E[pe + 1], ge = Ae; ge < Ce; ge++) {
              var Se = A[ge];
              ae[Se] !== se
                ? ((ae[Se] = se), te.push(Se), (oe[Se] = Z(ne, S[ge])))
                : (oe[Se] = D(oe[Se], Z(ne, S[ge])));
            }
        }
        for (var q = J[ce], Y = te.length, V = q; V < Y; V++) {
          var L = te[V];
          Q[V] = oe[L];
        }
      }
      return (J[I] = te.length), re;
    }
    function y(w, g) {
      var S = w._values,
        A = w._index,
        E = w._ptr,
        M = w._datatype,
        B = g._values,
        C = g._index,
        _ = g._ptr,
        z = g._datatype,
        I = w._size[0],
        T = g._size[1],
        D = S && B,
        Z,
        O = a,
        H = n;
      M &&
        z &&
        M === z &&
        typeof M == "string" &&
        ((Z = M), (O = r.find(a, [Z, Z])), (H = r.find(n, [Z, Z])));
      for (
        var Q = D ? [] : void 0,
          te = [],
          J = [],
          re = w.createSparseMatrix({
            values: Q,
            index: te,
            ptr: J,
            size: [I, T],
            datatype: Z,
          }),
          oe = D ? [] : void 0,
          ae = [],
          ce,
          se,
          pe,
          ne,
          Ae,
          Ce,
          ge,
          Se,
          q = 0;
        q < T;
        q++
      ) {
        J[q] = te.length;
        var Y = q + 1;
        for (Ae = _[q], Ce = _[q + 1], ne = Ae; ne < Ce; ne++)
          if (((Se = C[ne]), D))
            for (se = E[Se], pe = E[Se + 1], ce = se; ce < pe; ce++)
              (ge = A[ce]),
                ae[ge] !== Y
                  ? ((ae[ge] = Y), te.push(ge), (oe[ge] = H(B[ne], S[ce])))
                  : (oe[ge] = O(oe[ge], H(B[ne], S[ce])));
          else
            for (se = E[Se], pe = E[Se + 1], ce = se; ce < pe; ce++)
              (ge = A[ce]), ae[ge] !== Y && ((ae[ge] = Y), te.push(ge));
        if (D)
          for (var V = J[q], L = te.length, j = V; j < L; j++) {
            var F = te[j];
            Q[j] = oe[F];
          }
      }
      return (J[T] = te.length), re;
    }
    return r(
      Ol,
      Ls(
        {
          "Array, Array": function (g, S) {
            u(Xe(g), Xe(S));
            var A = this(t(g), t(S));
            return ze(A) ? A.valueOf() : A;
          },
          "Matrix, Matrix": function (g, S) {
            var A = g.size(),
              E = S.size();
            return (
              u(A, E),
              A.length === 1
                ? E.length === 1
                  ? s(g, S, A[0])
                  : o(g, S)
                : E.length === 1
                ? p(g, S)
                : v(g, S)
            );
          },
          "Matrix, Array": function (g, S) {
            return this(g, t(S));
          },
          "Array, Matrix": function (g, S) {
            return this(t(g, S.storage()), S);
          },
          "SparseMatrix, any": function (g, S) {
            return m(g, S, n, !1);
          },
          "DenseMatrix, any": function (g, S) {
            return f(g, S, n, !1);
          },
          "any, SparseMatrix": function (g, S) {
            return m(S, g, n, !0);
          },
          "any, DenseMatrix": function (g, S) {
            return f(S, g, n, !0);
          },
          "Array, any": function (g, S) {
            return f(t(g), S, n, !1).valueOf();
          },
          "any, Array": function (g, S) {
            return f(t(S), g, n, !0).valueOf();
          },
          "any, any": n,
          "any, any, ...any": function (g, S, A) {
            for (var E = this(g, S), M = 0; M < A.length; M++)
              E = this(E, A[M]);
            return E;
          },
        },
        n.signatures
      )
    );
  }),
  Tl = "nthRoot",
  Yw = ["typed", "matrix", "equalScalar", "BigNumber"],
  Qw = P(Tl, Yw, (e) => {
    var { typed: r, matrix: t, equalScalar: a, BigNumber: n } = e,
      i = bn({ typed: r }),
      c = Et({ typed: r, equalScalar: a }),
      m = no({ typed: r, equalScalar: a }),
      f = Ur({ typed: r, equalScalar: a }),
      u = hr({ typed: r }),
      s = ar({ typed: r }),
      o =
        "Complex number not supported in function nthRoot. Use nthRoots instead.";
    return r(Tl, {
      number: ju,
      "number, number": ju,
      BigNumber: function (v) {
        return l(v, new n(2));
      },
      Complex: function (v) {
        throw new Error(o);
      },
      "Complex, number": function (v, h) {
        throw new Error(o);
      },
      "BigNumber, BigNumber": l,
      "Array | Matrix": function (v) {
        return this(v, 2);
      },
      "SparseMatrix, SparseMatrix": function (v, h) {
        if (h.density() === 1) return m(v, h, this);
        throw new Error("Root must be non-zero");
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return c(h, v, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        if (h.density() === 1) return i(v, h, this, !1);
        throw new Error("Root must be non-zero");
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return u(v, h, this);
      },
      "Array, Array": function (v, h) {
        return this(t(v), t(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(t(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, t(h));
      },
      "SparseMatrix, number | BigNumber": function (v, h) {
        return f(v, h, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (v, h) {
        return s(v, h, this, !1);
      },
      "number | BigNumber, SparseMatrix": function (v, h) {
        if (h.density() === 1) return f(h, v, this, !0);
        throw new Error("Root must be non-zero");
      },
      "number | BigNumber, DenseMatrix": function (v, h) {
        return s(h, v, this, !0);
      },
      "Array, number | BigNumber": function (v, h) {
        return this(t(v), h).valueOf();
      },
      "number | BigNumber, Array": function (v, h) {
        return this(v, t(h)).valueOf();
      },
    });
    function l(p, v) {
      var h = n.precision,
        x = n.clone({ precision: h + 2 }),
        b = new n(0),
        N = new x(1),
        d = v.isNegative();
      if ((d && (v = v.neg()), v.isZero()))
        throw new Error("Root must be non-zero");
      if (p.isNegative() && !v.abs().mod(2).equals(1))
        throw new Error("Root must be odd when a is negative.");
      if (p.isZero()) return d ? new x(1 / 0) : 0;
      if (!p.isFinite()) return d ? b : p;
      var y = p.abs().pow(N.div(v));
      return (
        (y = p.isNeg() ? y.neg() : y), new n((d ? N.div(y) : y).toPrecision(h))
      );
    }
  }),
  Dl = "sign",
  jw = ["typed", "BigNumber", "Fraction", "complex"],
  Kw = P(Dl, jw, (e) => {
    var { typed: r, BigNumber: t, complex: a, Fraction: n } = e;
    return r(Dl, {
      number: ys,
      Complex: function (c) {
        return c.im === 0 ? a(ys(c.re)) : c.sign();
      },
      BigNumber: function (c) {
        return new t(c.cmp(0));
      },
      Fraction: function (c) {
        return new n(c.s, 1);
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
      Unit: function (c) {
        if (!c._isDerived() && c.units[0].unit.offset !== 0)
          throw new TypeError("sign is ambiguous for units with offset");
        return this(c.value);
      },
    });
  }),
  eN = "sqrt",
  rN = ["config", "typed", "Complex"],
  tN = P(eN, rN, (e) => {
    var { config: r, typed: t, Complex: a } = e;
    return t("sqrt", {
      number: n,
      Complex: function (c) {
        return c.sqrt();
      },
      BigNumber: function (c) {
        return !c.isNegative() || r.predictable ? c.sqrt() : n(c.toNumber());
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
      Unit: function (c) {
        return c.pow(0.5);
      },
    });
    function n(i) {
      return isNaN(i)
        ? NaN
        : i >= 0 || r.predictable
        ? Math.sqrt(i)
        : new a(i, 0).sqrt();
    }
  }),
  Bl = "square",
  nN = ["typed"],
  aN = P(Bl, nN, (e) => {
    var { typed: r } = e;
    return r(Bl, {
      number: xv,
      Complex: function (a) {
        return a.mul(a);
      },
      BigNumber: function (a) {
        return a.times(a);
      },
      Fraction: function (a) {
        return a.mul(a);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
      Unit: function (a) {
        return a.pow(2);
      },
    });
  }),
  _l = "subtract",
  iN = [
    "typed",
    "matrix",
    "equalScalar",
    "addScalar",
    "unaryMinus",
    "DenseMatrix",
  ],
  oN = P(_l, iN, (e) => {
    var {
        typed: r,
        matrix: t,
        equalScalar: a,
        addScalar: n,
        unaryMinus: i,
        DenseMatrix: c,
      } = e,
      m = bn({ typed: r }),
      f = Yr({ typed: r }),
      u = ao({ typed: r, equalScalar: a }),
      s = Dn({ typed: r, DenseMatrix: c }),
      o = hr({ typed: r }),
      l = ar({ typed: r });
    return r(_l, {
      "number, number": function (v, h) {
        return v - h;
      },
      "Complex, Complex": function (v, h) {
        return v.sub(h);
      },
      "BigNumber, BigNumber": function (v, h) {
        return v.minus(h);
      },
      "Fraction, Fraction": function (v, h) {
        return v.sub(h);
      },
      "Unit, Unit": function (v, h) {
        if (v.value === null)
          throw new Error("Parameter x contains a unit with undefined value");
        if (h.value === null)
          throw new Error("Parameter y contains a unit with undefined value");
        if (!v.equalBase(h)) throw new Error("Units do not match");
        var x = v.clone();
        return (x.value = this(x.value, h.value)), (x.fixPrefix = !1), x;
      },
      "SparseMatrix, SparseMatrix": function (v, h) {
        return gi(v, h), u(v, h, this);
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return gi(v, h), f(h, v, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        return gi(v, h), m(v, h, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return gi(v, h), o(v, h, this);
      },
      "Array, Array": function (v, h) {
        return this(t(v), t(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(t(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, t(h));
      },
      "SparseMatrix, any": function (v, h) {
        return s(v, i(h), n);
      },
      "DenseMatrix, any": function (v, h) {
        return l(v, h, this);
      },
      "any, SparseMatrix": function (v, h) {
        return s(h, v, this, !0);
      },
      "any, DenseMatrix": function (v, h) {
        return l(h, v, this, !0);
      },
      "Array, any": function (v, h) {
        return l(t(v), h, this, !1).valueOf();
      },
      "any, Array": function (v, h) {
        return l(t(h), v, this, !0).valueOf();
      },
    });
  });
function gi(e, r) {
  var t = e.size(),
    a = r.size();
  if (t.length !== a.length) throw new Je(t.length, a.length);
}
var Il = "xgcd",
  sN = ["typed", "config", "matrix", "BigNumber"],
  uN = P(Il, sN, (e) => {
    var { typed: r, config: t, matrix: a, BigNumber: n } = e;
    return r(Il, {
      "number, number": function (m, f) {
        var u = wv(m, f);
        return t.matrix === "Array" ? u : a(u);
      },
      "BigNumber, BigNumber": i,
    });
    function i(c, m) {
      var f,
        u,
        s,
        o = new n(0),
        l = new n(1),
        p = o,
        v = l,
        h = l,
        x = o;
      if (!c.isInt() || !m.isInt())
        throw new Error("Parameters in function xgcd must be integer numbers");
      for (; !m.isZero(); )
        (u = c.div(m).floor()),
          (s = c.mod(m)),
          (f = p),
          (p = v.minus(u.times(p))),
          (v = f),
          (f = h),
          (h = x.minus(u.times(h))),
          (x = f),
          (c = m),
          (m = s);
      var b;
      return (
        c.lt(o)
          ? (b = [c.neg(), v.neg(), x.neg()])
          : (b = [c, c.isZero() ? 0 : v, x]),
        t.matrix === "Array" ? b : a(b)
      );
    }
  }),
  Rl = "invmod",
  lN = [
    "typed",
    "config",
    "BigNumber",
    "xgcd",
    "equal",
    "smaller",
    "mod",
    "add",
    "isInteger",
  ],
  cN = P(Rl, lN, (e) => {
    var {
      typed: r,
      config: t,
      BigNumber: a,
      xgcd: n,
      equal: i,
      smaller: c,
      mod: m,
      add: f,
      isInteger: u,
    } = e;
    return r(Rl, { "number, number": s, "BigNumber, BigNumber": s });
    function s(o, l) {
      if (!u(o) || !u(l))
        throw new Error(
          "Parameters in function invmod must be integer numbers"
        );
      if (((o = m(o, l)), i(l, 0))) throw new Error("Divisor must be non zero");
      var p = n(o, l);
      p = p.valueOf();
      var [v, h] = p;
      return i(v, a(1)) ? ((h = m(h, l)), c(h, a(0)) && (h = f(h, l)), h) : NaN;
    }
  }),
  fN = "algorithm09",
  mN = ["typed", "equalScalar"],
  ah = P(fN, mN, (e) => {
    var { typed: r, equalScalar: t } = e;
    return function (n, i, c) {
      var m = n._values,
        f = n._index,
        u = n._ptr,
        s = n._size,
        o = n._datatype,
        l = i._values,
        p = i._index,
        v = i._ptr,
        h = i._size,
        x = i._datatype;
      if (s.length !== h.length) throw new Je(s.length, h.length);
      if (s[0] !== h[0] || s[1] !== h[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            s +
            ") must match Matrix B (" +
            h +
            ")"
        );
      var b = s[0],
        N = s[1],
        d,
        y = t,
        w = 0,
        g = c;
      typeof o == "string" &&
        o === x &&
        ((d = o),
        (y = r.find(t, [d, d])),
        (w = r.convert(0, d)),
        (g = r.find(c, [d, d])));
      var S = m && l ? [] : void 0,
        A = [],
        E = [],
        M = S ? [] : void 0,
        B = [],
        C,
        _,
        z,
        I,
        T;
      for (_ = 0; _ < N; _++) {
        E[_] = A.length;
        var D = _ + 1;
        if (M)
          for (I = v[_], T = v[_ + 1], z = I; z < T; z++)
            (C = p[z]), (B[C] = D), (M[C] = l[z]);
        for (I = u[_], T = u[_ + 1], z = I; z < T; z++)
          if (((C = f[z]), M)) {
            var Z = B[C] === D ? M[C] : w,
              O = g(m[z], Z);
            y(O, w) || (A.push(C), S.push(O));
          } else A.push(C);
      }
      return (
        (E[N] = A.length),
        n.createSparseMatrix({
          values: S,
          index: A,
          ptr: E,
          size: [b, N],
          datatype: d,
        })
      );
    };
  }),
  Fl = "dotMultiply",
  pN = ["typed", "matrix", "equalScalar", "multiplyScalar"],
  vN = P(Fl, pN, (e) => {
    var { typed: r, matrix: t, equalScalar: a, multiplyScalar: n } = e,
      i = Et({ typed: r, equalScalar: a }),
      c = ah({ typed: r, equalScalar: a }),
      m = Ur({ typed: r, equalScalar: a }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(Fl, {
      "any, any": n,
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, n, !1);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, n, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, n, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, n);
      },
      "Array, Array": function (o, l) {
        return this(t(o), t(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(t(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, t(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, n, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, n, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, n, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, n, !0);
      },
      "Array, any": function (o, l) {
        return u(t(o), l, n, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(t(l), o, n, !0).valueOf();
      },
    });
  });
function hN(e, r) {
  if ((e.isFinite() && !e.isInteger()) || (r.isFinite() && !r.isInteger()))
    throw new Error("Integers expected in function bitAnd");
  var t = e.constructor;
  if (e.isNaN() || r.isNaN()) return new t(NaN);
  if (e.isZero() || r.eq(-1) || e.eq(r)) return e;
  if (r.isZero() || e.eq(-1)) return r;
  if (!e.isFinite() || !r.isFinite()) {
    if (!e.isFinite() && !r.isFinite())
      return e.isNegative() === r.isNegative() ? e : new t(0);
    if (!e.isFinite())
      return r.isNegative() ? e : e.isNegative() ? new t(0) : r;
    if (!r.isFinite())
      return e.isNegative() ? r : r.isNegative() ? new t(0) : e;
  }
  return Qs(e, r, function (a, n) {
    return a & n;
  });
}
function Ua(e) {
  if (e.isFinite() && !e.isInteger())
    throw new Error("Integer expected in function bitNot");
  var r = e.constructor,
    t = r.precision;
  r.config({ precision: 1e9 });
  var a = e.plus(new r(1));
  return (a.s = -a.s || null), r.config({ precision: t }), a;
}
function dN(e, r) {
  if ((e.isFinite() && !e.isInteger()) || (r.isFinite() && !r.isInteger()))
    throw new Error("Integers expected in function bitOr");
  var t = e.constructor;
  if (e.isNaN() || r.isNaN()) return new t(NaN);
  var a = new t(-1);
  return e.isZero() || r.eq(a) || e.eq(r)
    ? r
    : r.isZero() || e.eq(a)
    ? e
    : !e.isFinite() || !r.isFinite()
    ? (!e.isFinite() && !e.isNegative() && r.isNegative()) ||
      (e.isNegative() && !r.isNegative() && !r.isFinite())
      ? a
      : e.isNegative() && r.isNegative()
      ? e.isFinite()
        ? e
        : r
      : e.isFinite()
      ? r
      : e
    : Qs(e, r, function (n, i) {
        return n | i;
      });
}
function Qs(e, r, t) {
  var a = e.constructor,
    n,
    i,
    c = +(e.s < 0),
    m = +(r.s < 0);
  if (c) {
    n = yi(Ua(e));
    for (var f = 0; f < n.length; ++f) n[f] ^= 1;
  } else n = yi(e);
  if (m) {
    i = yi(Ua(r));
    for (var u = 0; u < i.length; ++u) i[u] ^= 1;
  } else i = yi(r);
  var s, o, l;
  n.length <= i.length
    ? ((s = n), (o = i), (l = c))
    : ((s = i), (o = n), (l = m));
  var p = s.length,
    v = o.length,
    h = t(c, m) ^ 1,
    x = new a(h ^ 1),
    b = new a(1),
    N = new a(2),
    d = a.precision;
  for (a.config({ precision: 1e9 }); p > 0; )
    t(s[--p], o[--v]) === h && (x = x.plus(b)), (b = b.times(N));
  for (; v > 0; ) t(l, o[--v]) === h && (x = x.plus(b)), (b = b.times(N));
  return a.config({ precision: d }), h === 0 && (x.s = -x.s), x;
}
function yi(e) {
  for (var r = e.d, t = r[0] + "", a = 1; a < r.length; ++a) {
    for (var n = r[a] + "", i = 7 - n.length; i--; ) n = "0" + n;
    t += n;
  }
  for (var c = t.length; t.charAt(c) === "0"; ) c--;
  var m = e.e,
    f = t.slice(0, c + 1 || 1),
    u = f.length;
  if (m > 0)
    if (++m > u) for (m -= u; m--; ) f += "0";
    else m < u && (f = f.slice(0, m) + "." + f.slice(m));
  for (var s = [0], o = 0; o < f.length; ) {
    for (var l = s.length; l--; ) s[l] *= 10;
    s[0] += parseInt(f.charAt(o++));
    for (var p = 0; p < s.length; ++p)
      s[p] > 1 &&
        ((s[p + 1] === null || s[p + 1] === void 0) && (s[p + 1] = 0),
        (s[p + 1] += s[p] >> 1),
        (s[p] &= 1));
  }
  return s.reverse();
}
function gN(e, r) {
  if ((e.isFinite() && !e.isInteger()) || (r.isFinite() && !r.isInteger()))
    throw new Error("Integers expected in function bitXor");
  var t = e.constructor;
  if (e.isNaN() || r.isNaN()) return new t(NaN);
  if (e.isZero()) return r;
  if (r.isZero()) return e;
  if (e.eq(r)) return new t(0);
  var a = new t(-1);
  return e.eq(a)
    ? Ua(r)
    : r.eq(a)
    ? Ua(e)
    : !e.isFinite() || !r.isFinite()
    ? !e.isFinite() && !r.isFinite()
      ? a
      : new t(e.isNegative() === r.isNegative() ? 1 / 0 : -1 / 0)
    : Qs(e, r, function (n, i) {
        return n ^ i;
      });
}
function yN(e, r) {
  if ((e.isFinite() && !e.isInteger()) || (r.isFinite() && !r.isInteger()))
    throw new Error("Integers expected in function leftShift");
  var t = e.constructor;
  return e.isNaN() || r.isNaN() || (r.isNegative() && !r.isZero())
    ? new t(NaN)
    : e.isZero() || r.isZero()
    ? e
    : !e.isFinite() && !r.isFinite()
    ? new t(NaN)
    : r.lt(55)
    ? e.times(Math.pow(2, r.toNumber()) + "")
    : e.times(new t(2).pow(r));
}
function bN(e, r) {
  if ((e.isFinite() && !e.isInteger()) || (r.isFinite() && !r.isInteger()))
    throw new Error("Integers expected in function rightArithShift");
  var t = e.constructor;
  return e.isNaN() || r.isNaN() || (r.isNegative() && !r.isZero())
    ? new t(NaN)
    : e.isZero() || r.isZero()
    ? e
    : r.isFinite()
    ? r.lt(55)
      ? e.div(Math.pow(2, r.toNumber()) + "").floor()
      : e.div(new t(2).pow(r)).floor()
    : e.isNegative()
    ? new t(-1)
    : e.isFinite()
    ? new t(0)
    : new t(NaN);
}
var Pl = "bitAnd",
  xN = ["typed", "matrix", "equalScalar"],
  wN = P(Pl, xN, (e) => {
    var { typed: r, matrix: t, equalScalar: a } = e,
      n = Et({ typed: r, equalScalar: a }),
      i = no({ typed: r, equalScalar: a }),
      c = Ur({ typed: r, equalScalar: a }),
      m = hr({ typed: r }),
      f = ar({ typed: r });
    return r(Pl, {
      "number, number": Mv,
      "BigNumber, BigNumber": hN,
      "SparseMatrix, SparseMatrix": function (s, o) {
        return i(s, o, this, !1);
      },
      "SparseMatrix, DenseMatrix": function (s, o) {
        return n(o, s, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (s, o) {
        return n(s, o, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (s, o) {
        return m(s, o, this);
      },
      "Array, Array": function (s, o) {
        return this(t(s), t(o)).valueOf();
      },
      "Array, Matrix": function (s, o) {
        return this(t(s), o);
      },
      "Matrix, Array": function (s, o) {
        return this(s, t(o));
      },
      "SparseMatrix, any": function (s, o) {
        return c(s, o, this, !1);
      },
      "DenseMatrix, any": function (s, o) {
        return f(s, o, this, !1);
      },
      "any, SparseMatrix": function (s, o) {
        return c(o, s, this, !0);
      },
      "any, DenseMatrix": function (s, o) {
        return f(o, s, this, !0);
      },
      "Array, any": function (s, o) {
        return f(t(s), o, this, !1).valueOf();
      },
      "any, Array": function (s, o) {
        return f(t(o), s, this, !0).valueOf();
      },
    });
  }),
  ql = "bitNot",
  NN = ["typed"],
  MN = P(ql, NN, (e) => {
    var { typed: r } = e;
    return r(ql, {
      number: Av,
      BigNumber: Ua,
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  zl = "bitOr",
  AN = ["typed", "matrix", "equalScalar", "DenseMatrix"],
  SN = P(zl, AN, (e) => {
    var { typed: r, matrix: t, equalScalar: a, DenseMatrix: n } = e,
      i = bn({ typed: r }),
      c = Ys({ typed: r, equalScalar: a }),
      m = Dn({ typed: r, DenseMatrix: n }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(zl, {
      "number, number": Sv,
      "BigNumber, BigNumber": dN,
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, this);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, this);
      },
      "Array, Array": function (o, l) {
        return this(t(o), t(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(t(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, t(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, this, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, this, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, this, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, this, !0);
      },
      "Array, any": function (o, l) {
        return u(t(o), l, this, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(t(l), o, this, !0).valueOf();
      },
    });
  }),
  EN = "algorithm07",
  CN = ["typed", "DenseMatrix"],
  qt = P(EN, CN, (e) => {
    var { typed: r, DenseMatrix: t } = e;
    return function (i, c, m) {
      var f = i._size,
        u = i._datatype,
        s = c._size,
        o = c._datatype;
      if (f.length !== s.length) throw new Je(f.length, s.length);
      if (f[0] !== s[0] || f[1] !== s[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            f +
            ") must match Matrix B (" +
            s +
            ")"
        );
      var l = f[0],
        p = f[1],
        v,
        h = 0,
        x = m;
      typeof u == "string" &&
        u === o &&
        ((v = u), (h = r.convert(0, v)), (x = r.find(m, [v, v])));
      var b,
        N,
        d = [];
      for (b = 0; b < l; b++) d[b] = [];
      var y = [],
        w = [],
        g = [],
        S = [];
      for (N = 0; N < p; N++) {
        var A = N + 1;
        for (a(i, N, g, y, A), a(c, N, S, w, A), b = 0; b < l; b++) {
          var E = g[b] === A ? y[b] : h,
            M = S[b] === A ? w[b] : h;
          d[b][N] = x(E, M);
        }
      }
      return new t({ data: d, size: [l, p], datatype: v });
    };
    function a(n, i, c, m, f) {
      for (
        var u = n._values, s = n._index, o = n._ptr, l = o[i], p = o[i + 1];
        l < p;
        l++
      ) {
        var v = s[l];
        (c[v] = f), (m[v] = u[l]);
      }
    }
  }),
  Ul = "bitXor",
  $N = ["typed", "matrix", "DenseMatrix"],
  ON = P(Ul, $N, (e) => {
    var { typed: r, matrix: t, DenseMatrix: a } = e,
      n = Yr({ typed: r }),
      i = qt({ typed: r, DenseMatrix: a }),
      c = Ir({ typed: r, DenseMatrix: a }),
      m = hr({ typed: r }),
      f = ar({ typed: r });
    return r(Ul, {
      "number, number": Ev,
      "BigNumber, BigNumber": gN,
      "SparseMatrix, SparseMatrix": function (s, o) {
        return i(s, o, this);
      },
      "SparseMatrix, DenseMatrix": function (s, o) {
        return n(o, s, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (s, o) {
        return n(s, o, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (s, o) {
        return m(s, o, this);
      },
      "Array, Array": function (s, o) {
        return this(t(s), t(o)).valueOf();
      },
      "Array, Matrix": function (s, o) {
        return this(t(s), o);
      },
      "Matrix, Array": function (s, o) {
        return this(s, t(o));
      },
      "SparseMatrix, any": function (s, o) {
        return c(s, o, this, !1);
      },
      "DenseMatrix, any": function (s, o) {
        return f(s, o, this, !1);
      },
      "any, SparseMatrix": function (s, o) {
        return c(o, s, this, !0);
      },
      "any, DenseMatrix": function (s, o) {
        return f(o, s, this, !0);
      },
      "Array, any": function (s, o) {
        return f(t(s), o, this, !1).valueOf();
      },
      "any, Array": function (s, o) {
        return f(t(o), s, this, !0).valueOf();
      },
    });
  }),
  Ll = "arg",
  TN = ["typed"],
  DN = P(Ll, TN, (e) => {
    var { typed: r } = e;
    return r(Ll, {
      number: function (a) {
        return Math.atan2(0, a);
      },
      BigNumber: function (a) {
        return a.constructor.atan2(0, a);
      },
      Complex: function (a) {
        return a.arg();
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  kl = "conj",
  BN = ["typed"],
  _N = P(kl, BN, (e) => {
    var { typed: r } = e;
    return r(kl, {
      number: function (a) {
        return a;
      },
      BigNumber: function (a) {
        return a;
      },
      Complex: function (a) {
        return a.conjugate();
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Vl = "im",
  IN = ["typed"],
  RN = P(Vl, IN, (e) => {
    var { typed: r } = e;
    return r(Vl, {
      number: function (a) {
        return 0;
      },
      BigNumber: function (a) {
        return a.mul(0);
      },
      Fraction: function (a) {
        return a.mul(0);
      },
      Complex: function (a) {
        return a.im;
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Gl = "re",
  FN = ["typed"],
  PN = P(Gl, FN, (e) => {
    var { typed: r } = e;
    return r(Gl, {
      number: function (a) {
        return a;
      },
      BigNumber: function (a) {
        return a;
      },
      Fraction: function (a) {
        return a;
      },
      Complex: function (a) {
        return a.re;
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Hl = "not",
  qN = ["typed"],
  zN = P(Hl, qN, (e) => {
    var { typed: r } = e;
    return r(Hl, {
      number: Dv,
      Complex: function (a) {
        return a.re === 0 && a.im === 0;
      },
      BigNumber: function (a) {
        return a.isZero() || a.isNaN();
      },
      Unit: function (a) {
        return a.value !== null ? this(a.value) : !0;
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Zl = "or",
  UN = ["typed", "matrix", "equalScalar", "DenseMatrix"],
  LN = P(Zl, UN, (e) => {
    var { typed: r, matrix: t, equalScalar: a, DenseMatrix: n } = e,
      i = Yr({ typed: r }),
      c = ao({ typed: r, equalScalar: a }),
      m = Ir({ typed: r, DenseMatrix: n }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(Zl, {
      "number, number": Bv,
      "Complex, Complex": function (o, l) {
        return o.re !== 0 || o.im !== 0 || l.re !== 0 || l.im !== 0;
      },
      "BigNumber, BigNumber": function (o, l) {
        return (!o.isZero() && !o.isNaN()) || (!l.isZero() && !l.isNaN());
      },
      "Unit, Unit": function (o, l) {
        return this(o.value || 0, l.value || 0);
      },
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, this);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, this);
      },
      "Array, Array": function (o, l) {
        return this(t(o), t(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(t(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, t(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, this, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, this, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, this, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, this, !0);
      },
      "Array, any": function (o, l) {
        return u(t(o), l, this, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(t(l), o, this, !0).valueOf();
      },
    });
  }),
  Jl = "xor",
  kN = ["typed", "matrix", "DenseMatrix"],
  VN = P(Jl, kN, (e) => {
    var { typed: r, matrix: t, DenseMatrix: a } = e,
      n = Yr({ typed: r }),
      i = qt({ typed: r, DenseMatrix: a }),
      c = Ir({ typed: r, DenseMatrix: a }),
      m = hr({ typed: r }),
      f = ar({ typed: r });
    return r(Jl, {
      "number, number": _v,
      "Complex, Complex": function (s, o) {
        return (s.re !== 0 || s.im !== 0) != (o.re !== 0 || o.im !== 0);
      },
      "BigNumber, BigNumber": function (s, o) {
        return (!s.isZero() && !s.isNaN()) != (!o.isZero() && !o.isNaN());
      },
      "Unit, Unit": function (s, o) {
        return this(s.value || 0, o.value || 0);
      },
      "SparseMatrix, SparseMatrix": function (s, o) {
        return i(s, o, this);
      },
      "SparseMatrix, DenseMatrix": function (s, o) {
        return n(o, s, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (s, o) {
        return n(s, o, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (s, o) {
        return m(s, o, this);
      },
      "Array, Array": function (s, o) {
        return this(t(s), t(o)).valueOf();
      },
      "Array, Matrix": function (s, o) {
        return this(t(s), o);
      },
      "Matrix, Array": function (s, o) {
        return this(s, t(o));
      },
      "SparseMatrix, any": function (s, o) {
        return c(s, o, this, !1);
      },
      "DenseMatrix, any": function (s, o) {
        return f(s, o, this, !1);
      },
      "any, SparseMatrix": function (s, o) {
        return c(o, s, this, !0);
      },
      "any, DenseMatrix": function (s, o) {
        return f(o, s, this, !0);
      },
      "Array, any": function (s, o) {
        return f(t(s), o, this, !1).valueOf();
      },
      "any, Array": function (s, o) {
        return f(t(o), s, this, !0).valueOf();
      },
    });
  }),
  Wl = "concat",
  GN = ["typed", "matrix", "isInteger"],
  ih = P(Wl, GN, (e) => {
    var { typed: r, matrix: t, isInteger: a } = e;
    return r(Wl, {
      "...Array | Matrix | number | BigNumber": function (i) {
        var c,
          m = i.length,
          f = -1,
          u,
          s = !1,
          o = [];
        for (c = 0; c < m; c++) {
          var l = i[c];
          if ((ze(l) && (s = !0), je(l) || Qe(l))) {
            if (c !== m - 1)
              throw new Error("Dimension must be specified as last argument");
            if (((u = f), (f = l.valueOf()), !a(f)))
              throw new TypeError("Integer number expected for dimension");
            if (f < 0 || (c > 0 && f > u)) throw new At(f, u + 1);
          } else {
            var p = Fe(l).valueOf(),
              v = Xe(p);
            if (((o[c] = p), (u = f), (f = v.length - 1), c > 0 && f !== u))
              throw new Je(u + 1, f + 1);
          }
        }
        if (o.length === 0)
          throw new SyntaxError("At least one matrix expected");
        for (var h = o.shift(); o.length; ) h = oh(h, o.shift(), f, 0);
        return s ? t(h) : h;
      },
      "...string": function (i) {
        return i.join("");
      },
    });
  });
function oh(e, r, t, a) {
  if (a < t) {
    if (e.length !== r.length) throw new Je(e.length, r.length);
    for (var n = [], i = 0; i < e.length; i++) n[i] = oh(e[i], r[i], t, a + 1);
    return n;
  } else return e.concat(r);
}
var Xl = "column",
  HN = ["typed", "Index", "matrix", "range"],
  sh = P(Xl, HN, (e) => {
    var { typed: r, Index: t, matrix: a, range: n } = e;
    return r(Xl, {
      "Matrix, number": i,
      "Array, number": function (m, f) {
        return i(a(Fe(m)), f).valueOf();
      },
    });
    function i(c, m) {
      if (c.size().length !== 2)
        throw new Error("Only two dimensional matrix is supported");
      cr(m, c.size()[1]);
      var f = n(0, c.size()[0]),
        u = new t(f, m);
      return c.subset(u);
    }
  }),
  Yl = "count",
  ZN = ["typed", "size", "prod"],
  JN = P(Yl, ZN, (e) => {
    var { typed: r, size: t, prod: a } = e;
    return r(Yl, {
      string: function (i) {
        return i.length;
      },
      "Matrix | Array": function (i) {
        return a(t(i));
      },
    });
  }),
  Ql = "cross",
  WN = ["typed", "matrix", "subtract", "multiply"],
  XN = P(Ql, WN, (e) => {
    var { typed: r, matrix: t, subtract: a, multiply: n } = e;
    return r(Ql, {
      "Matrix, Matrix": function (m, f) {
        return t(i(m.toArray(), f.toArray()));
      },
      "Matrix, Array": function (m, f) {
        return t(i(m.toArray(), f));
      },
      "Array, Matrix": function (m, f) {
        return t(i(m, f.toArray()));
      },
      "Array, Array": i,
    });
    function i(c, m) {
      var f = Math.max(Xe(c).length, Xe(m).length);
      (c = Oi(c)), (m = Oi(m));
      var u = Xe(c),
        s = Xe(m);
      if (u.length !== 1 || s.length !== 1 || u[0] !== 3 || s[0] !== 3)
        throw new RangeError(
          "Vectors with length 3 expected (Size A = [" +
            u.join(", ") +
            "], B = [" +
            s.join(", ") +
            "])"
        );
      var o = [
        a(n(c[1], m[2]), n(c[2], m[1])),
        a(n(c[2], m[0]), n(c[0], m[2])),
        a(n(c[0], m[1]), n(c[1], m[0])),
      ];
      return f > 1 ? [o] : o;
    }
  }),
  jl = "diag",
  YN = ["typed", "matrix", "DenseMatrix", "SparseMatrix"],
  QN = P(jl, YN, (e) => {
    var { typed: r, matrix: t, DenseMatrix: a, SparseMatrix: n } = e;
    return r(jl, {
      Array: function (u) {
        return i(u, 0, Xe(u), null);
      },
      "Array, number": function (u, s) {
        return i(u, s, Xe(u), null);
      },
      "Array, BigNumber": function (u, s) {
        return i(u, s.toNumber(), Xe(u), null);
      },
      "Array, string": function (u, s) {
        return i(u, 0, Xe(u), s);
      },
      "Array, number, string": function (u, s, o) {
        return i(u, s, Xe(u), o);
      },
      "Array, BigNumber, string": function (u, s, o) {
        return i(u, s.toNumber(), Xe(u), o);
      },
      Matrix: function (u) {
        return i(u, 0, u.size(), u.storage());
      },
      "Matrix, number": function (u, s) {
        return i(u, s, u.size(), u.storage());
      },
      "Matrix, BigNumber": function (u, s) {
        return i(u, s.toNumber(), u.size(), u.storage());
      },
      "Matrix, string": function (u, s) {
        return i(u, 0, u.size(), s);
      },
      "Matrix, number, string": function (u, s, o) {
        return i(u, s, u.size(), o);
      },
      "Matrix, BigNumber, string": function (u, s, o) {
        return i(u, s.toNumber(), u.size(), o);
      },
    });
    function i(f, u, s, o) {
      if (!Be(u))
        throw new TypeError(
          "Second parameter in function diag must be an integer"
        );
      var l = u > 0 ? u : 0,
        p = u < 0 ? -u : 0;
      switch (s.length) {
        case 1:
          return c(f, u, o, s[0], p, l);
        case 2:
          return m(f, u, o, s, p, l);
      }
      throw new RangeError("Matrix for function diag must be 2 dimensional");
    }
    function c(f, u, s, o, l, p) {
      var v = [o + l, o + p];
      if (s && s !== "sparse" && s !== "dense")
        throw new TypeError("Unknown matrix type ".concat(s, '"'));
      var h = s === "sparse" ? n.diagonal(v, f, u) : a.diagonal(v, f, u);
      return s !== null ? h : h.valueOf();
    }
    function m(f, u, s, o, l, p) {
      if (ze(f)) {
        var v = f.diagonal(u);
        return s !== null ? (s !== v.storage() ? t(v, s) : v) : v.valueOf();
      }
      for (var h = Math.min(o[0] - l, o[1] - p), x = [], b = 0; b < h; b++)
        x[b] = f[b + l][b + p];
      return s !== null ? t(x) : x;
    }
  });
function jN(e) {
  var r = 0,
    t = 1,
    a = Object.create(null),
    n = Object.create(null),
    i = 0,
    c = function (f) {
      var u = n[f];
      if (u && (delete a[u], delete n[f], --r, t === u)) {
        if (!r) {
          (i = 0), (t = 1);
          return;
        }
        for (; !hasOwnProperty.call(a, ++t); );
      }
    };
  return (
    (e = Math.abs(e)),
    {
      hit: function (f) {
        var u = n[f],
          s = ++i;
        if (((a[s] = f), (n[f] = s), !u))
          return ++r, r <= e ? void 0 : ((f = a[t]), c(f), f);
        if ((delete a[u], t === u)) for (; !hasOwnProperty.call(a, ++t); );
      },
      delete: c,
      clear: function () {
        (r = i = 0),
          (t = 1),
          (a = Object.create(null)),
          (n = Object.create(null));
      },
    }
  );
}
function Xa(e) {
  var { hasher: r, limit: t } =
    arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return (
    (t = t ?? Number.POSITIVE_INFINITY),
    (r = r ?? JSON.stringify),
    function a() {
      typeof a.cache != "object" &&
        (a.cache = {
          values: new Map(),
          lru: jN(t || Number.POSITIVE_INFINITY),
        });
      for (var n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
      var c = r(n);
      if (a.cache.values.has(c))
        return a.cache.lru.hit(c), a.cache.values.get(c);
      var m = e.apply(e, n);
      return (
        a.cache.values.set(c, m), a.cache.values.delete(a.cache.lru.hit(c)), m
      );
    }
  );
}
function xa(e) {
  return Object.keys(e.signatures || {}).reduce(function (r, t) {
    var a = (t.match(/,/g) || []).length + 1;
    return Math.max(r, a);
  }, -1);
}
var KN = "filter",
  eM = ["typed"],
  rM = P(KN, eM, (e) => {
    var { typed: r } = e;
    return r("filter", {
      "Array, function": Kl,
      "Matrix, function": function (a, n) {
        return a.create(Kl(a.toArray(), n));
      },
      "Array, RegExp": Ti,
      "Matrix, RegExp": function (a, n) {
        return a.create(Ti(a.toArray(), n));
      },
    });
  });
function Kl(e, r) {
  var t = xa(r);
  return Gp(e, function (a, n, i) {
    return t === 1 ? r(a) : t === 2 ? r(a, [n]) : r(a, [n], i);
  });
}
var ec = "flatten",
  tM = ["typed", "matrix"],
  nM = P(ec, tM, (e) => {
    var { typed: r, matrix: t } = e;
    return r(ec, {
      Array: function (n) {
        return Ke(Fe(n));
      },
      Matrix: function (n) {
        var i = Ke(Fe(n.toArray()));
        return t(i);
      },
    });
  }),
  rc = "forEach",
  aM = ["typed"],
  iM = P(rc, aM, (e) => {
    var { typed: r } = e;
    return r(rc, {
      "Array, function": oM,
      "Matrix, function": function (a, n) {
        return a.forEach(n);
      },
    });
  });
function oM(e, r) {
  var t = xa(r),
    a = function n(i, c) {
      Array.isArray(i)
        ? Yi(i, function (m, f) {
            n(m, c.concat(f));
          })
        : t === 1
        ? r(i)
        : t === 2
        ? r(i, c)
        : r(i, c, e);
    };
  a(e, []);
}
var tc = "getMatrixDataType",
  sM = ["typed"],
  uM = P(tc, sM, (e) => {
    var { typed: r } = e;
    return r(tc, {
      Array: function (a) {
        return qa(a, vr);
      },
      Matrix: function (a) {
        return a.getDataType();
      },
    });
  }),
  nc = "identity",
  lM = [
    "typed",
    "config",
    "matrix",
    "BigNumber",
    "DenseMatrix",
    "SparseMatrix",
  ],
  cM = P(nc, lM, (e) => {
    var {
      typed: r,
      config: t,
      matrix: a,
      BigNumber: n,
      DenseMatrix: i,
      SparseMatrix: c,
    } = e;
    return r(nc, {
      "": function () {
        return t.matrix === "Matrix" ? a([]) : [];
      },
      string: function (s) {
        return a(s);
      },
      "number | BigNumber": function (s) {
        return f(s, s, t.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, string": function (s, o) {
        return f(s, s, o);
      },
      "number | BigNumber, number | BigNumber": function (s, o) {
        return f(s, o, t.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, number | BigNumber, string": function (s, o, l) {
        return f(s, o, l);
      },
      Array: function (s) {
        return m(s);
      },
      "Array, string": function (s, o) {
        return m(s, o);
      },
      Matrix: function (s) {
        return m(s.valueOf(), s.storage());
      },
      "Matrix, string": function (s, o) {
        return m(s.valueOf(), o);
      },
    });
    function m(u, s) {
      switch (u.length) {
        case 0:
          return s ? a(s) : [];
        case 1:
          return f(u[0], u[0], s);
        case 2:
          return f(u[0], u[1], s);
        default:
          throw new Error("Vector containing two values expected");
      }
    }
    function f(u, s, o) {
      var l = Qe(u) || Qe(s) ? n : null;
      if (
        (Qe(u) && (u = u.toNumber()),
        Qe(s) && (s = s.toNumber()),
        !Be(u) || u < 1)
      )
        throw new Error(
          "Parameters in function identity must be positive integers"
        );
      if (!Be(s) || s < 1)
        throw new Error(
          "Parameters in function identity must be positive integers"
        );
      var p = l ? new n(1) : 1,
        v = l ? new l(0) : 0,
        h = [u, s];
      if (o) {
        if (o === "sparse") return c.diagonal(h, p, 0, v);
        if (o === "dense") return i.diagonal(h, p, 0, v);
        throw new TypeError('Unknown matrix type "'.concat(o, '"'));
      }
      for (var x = oa([], h, v), b = u < s ? u : s, N = 0; N < b; N++)
        x[N][N] = p;
      return x;
    }
  }),
  ac = "kron",
  fM = ["typed", "matrix", "multiplyScalar"],
  mM = P(ac, fM, (e) => {
    var { typed: r, matrix: t, multiplyScalar: a } = e;
    return r(ac, {
      "Matrix, Matrix": function (c, m) {
        return t(n(c.toArray(), m.toArray()));
      },
      "Matrix, Array": function (c, m) {
        return t(n(c.toArray(), m));
      },
      "Array, Matrix": function (c, m) {
        return t(n(c, m.toArray()));
      },
      "Array, Array": n,
    });
    function n(i, c) {
      if (
        (Xe(i).length === 1 && (i = [i]),
        Xe(c).length === 1 && (c = [c]),
        Xe(i).length > 2 || Xe(c).length > 2)
      )
        throw new RangeError(
          "Vectors with dimensions greater then 2 are not supported expected (Size x = " +
            JSON.stringify(i.length) +
            ", y = " +
            JSON.stringify(c.length) +
            ")"
        );
      var m = [],
        f = [];
      return (
        i.map(function (u) {
          return c.map(function (s) {
            return (
              (f = []),
              m.push(f),
              u.map(function (o) {
                return s.map(function (l) {
                  return f.push(a(o, l));
                });
              })
            );
          });
        }) && m
      );
    }
  }),
  ic = "map",
  pM = ["typed"],
  vM = P(ic, pM, (e) => {
    var { typed: r } = e;
    return r(ic, {
      "Array, function": hM,
      "Matrix, function": function (a, n) {
        return a.map(n);
      },
    });
  });
function hM(e, r) {
  var t = xa(r),
    a = function n(i, c) {
      if (Array.isArray(i))
        return i.map(function (u, s) {
          return n(u, c.concat(s));
        });
      try {
        return t === 1 ? r(i) : t === 2 ? r(i, c) : r(i, c, e);
      } catch (u) {
        if (
          u instanceof TypeError &&
          "data" in u &&
          u.data.category === "wrongType"
        ) {
          var m = "map attempted to call '".concat(u.data.fn, "(").concat(i),
            f = JSON.stringify(c);
          throw (
            (t === 2
              ? (m += "," + f)
              : t !== 1 && (m += ",".concat(f, ",").concat(e)),
            (m += ")' but argument ".concat(u.data.index + 1, " of type ")),
            (m += "".concat(u.data.actual, " does not match expected type ")),
            (m += u.data.expected.join(" or ")),
            new TypeError(m))
          );
        }
        throw u;
      }
    };
  return a(e, []);
}
var oc = "diff",
  dM = ["typed", "matrix", "subtract", "number"],
  uh = P(oc, dM, (e) => {
    var { typed: r, matrix: t, subtract: a, number: n } = e;
    return r(oc, {
      "Array | Matrix": function (s) {
        return ze(s) ? t(c(s.toArray())) : c(s);
      },
      "Array | Matrix, number": function (s, o) {
        if (!Be(o)) throw new RangeError("Dimension must be a whole number");
        return ze(s) ? t(i(s.toArray(), o)) : i(s, o);
      },
      "Array | Matrix, BigNumber": function (s, o) {
        return this(s, n(o));
      },
    });
    function i(u, s) {
      if ((ze(u) && (u = u.toArray()), !Array.isArray(u)))
        throw RangeError("Array/Matrix does not have that many dimensions");
      if (s > 0) {
        var o = [];
        return (
          u.forEach((l) => {
            o.push(i(l, s - 1));
          }),
          o
        );
      } else {
        if (s === 0) return c(u);
        throw RangeError("Cannot have negative dimension");
      }
    }
    function c(u) {
      var s = [],
        o = u.length;
      if (o < 2) return u;
      for (var l = 1; l < o; l++) s.push(m(u[l - 1], u[l]));
      return s;
    }
    function m(u, s) {
      ze(u) && (u = u.toArray()), ze(s) && (s = s.toArray());
      var o = Array.isArray(u),
        l = Array.isArray(s);
      if (o && l) return f(u, s);
      if (!o && !l) return a(s, u);
      throw TypeError(
        "Cannot calculate difference between 1 array and 1 non-array"
      );
    }
    function f(u, s) {
      if (u.length !== s.length)
        throw RangeError("Not all sub-arrays have the same length");
      for (var o = [], l = u.length, p = 0; p < l; p++) o.push(m(u[p], s[p]));
      return o;
    }
  }),
  gM = "ones",
  yM = ["typed", "config", "matrix", "BigNumber"],
  bM = P(gM, yM, (e) => {
    var { typed: r, config: t, matrix: a, BigNumber: n } = e;
    return r("ones", {
      "": function () {
        return t.matrix === "Array" ? i([]) : i([], "default");
      },
      "...number | BigNumber | string": function (u) {
        var s = u[u.length - 1];
        if (typeof s == "string") {
          var o = u.pop();
          return i(u, o);
        } else return t.matrix === "Array" ? i(u) : i(u, "default");
      },
      Array: i,
      Matrix: function (u) {
        var s = u.storage();
        return i(u.valueOf(), s);
      },
      "Array | Matrix, string": function (u, s) {
        return i(u.valueOf(), s);
      },
    });
    function i(f, u) {
      var s = c(f),
        o = s ? new n(1) : 1;
      if ((m(f), u)) {
        var l = a(u);
        return f.length > 0 ? l.resize(f, o) : l;
      } else {
        var p = [];
        return f.length > 0 ? oa(p, f, o) : p;
      }
    }
    function c(f) {
      var u = !1;
      return (
        f.forEach(function (s, o, l) {
          Qe(s) && ((u = !0), (l[o] = s.toNumber()));
        }),
        u
      );
    }
    function m(f) {
      f.forEach(function (u) {
        if (typeof u != "number" || !Be(u) || u < 0)
          throw new Error(
            "Parameters in function ones must be positive integers"
          );
      });
    }
  });
function js() {
  throw new Error('No "bignumber" implementation available');
}
function lh() {
  throw new Error('No "fraction" implementation available');
}
function ch() {
  throw new Error('No "matrix" implementation available');
}
var sc = "range",
  xM = [
    "typed",
    "config",
    "?matrix",
    "?bignumber",
    "smaller",
    "smallerEq",
    "larger",
    "largerEq",
  ],
  fh = P(sc, xM, (e) => {
    var {
      typed: r,
      config: t,
      matrix: a,
      bignumber: n,
      smaller: i,
      smallerEq: c,
      larger: m,
      largerEq: f,
    } = e;
    return r(sc, {
      string: s,
      "string, boolean": s,
      "number, number": function (b, N) {
        return u(o(b, N, 1));
      },
      "number, number, number": function (b, N, d) {
        return u(o(b, N, d));
      },
      "number, number, boolean": function (b, N, d) {
        return u(d ? l(b, N, 1) : o(b, N, 1));
      },
      "number, number, number, boolean": function (b, N, d, y) {
        return u(y ? l(b, N, d) : o(b, N, d));
      },
      "BigNumber, BigNumber": function (b, N) {
        var d = b.constructor;
        return u(p(b, N, new d(1)));
      },
      "BigNumber, BigNumber, BigNumber": function (b, N, d) {
        return u(p(b, N, d));
      },
      "BigNumber, BigNumber, boolean": function (b, N, d) {
        var y = b.constructor;
        return u(d ? v(b, N, new y(1)) : p(b, N, new y(1)));
      },
      "BigNumber, BigNumber, BigNumber, boolean": function (b, N, d, y) {
        return u(y ? v(b, N, d) : p(b, N, d));
      },
    });
    function u(x) {
      return t.matrix === "Matrix" ? (a ? a(x) : ch()) : x;
    }
    function s(x, b) {
      var N = h(x);
      if (!N) throw new SyntaxError('String "' + x + '" is no valid range');
      var d;
      return t.number === "BigNumber"
        ? (n === void 0 && js(),
          (d = b ? v : p),
          u(d(n(N.start), n(N.end), n(N.step))))
        : ((d = b ? l : o), u(d(N.start, N.end, N.step)));
    }
    function o(x, b, N) {
      var d = [],
        y = x;
      if (N > 0) for (; i(y, b); ) d.push(y), (y += N);
      else if (N < 0) for (; m(y, b); ) d.push(y), (y += N);
      return d;
    }
    function l(x, b, N) {
      var d = [],
        y = x;
      if (N > 0) for (; c(y, b); ) d.push(y), (y += N);
      else if (N < 0) for (; f(y, b); ) d.push(y), (y += N);
      return d;
    }
    function p(x, b, N) {
      var d = n(0),
        y = [],
        w = x;
      if (N.gt(d)) for (; i(w, b); ) y.push(w), (w = w.plus(N));
      else if (N.lt(d)) for (; m(w, b); ) y.push(w), (w = w.plus(N));
      return y;
    }
    function v(x, b, N) {
      var d = n(0),
        y = [],
        w = x;
      if (N.gt(d)) for (; c(w, b); ) y.push(w), (w = w.plus(N));
      else if (N.lt(d)) for (; f(w, b); ) y.push(w), (w = w.plus(N));
      return y;
    }
    function h(x) {
      var b = x.split(":"),
        N = b.map(function (y) {
          return Number(y);
        }),
        d = N.some(function (y) {
          return isNaN(y);
        });
      if (d) return null;
      switch (N.length) {
        case 2:
          return { start: N[0], end: N[1], step: 1 };
        case 3:
          return { start: N[0], end: N[2], step: N[1] };
        default:
          return null;
      }
    }
  }),
  uc = "reshape",
  wM = ["typed", "isInteger", "matrix"],
  NM = P(uc, wM, (e) => {
    var { typed: r, isInteger: t } = e;
    return r(uc, {
      "Matrix, Array": function (n, i) {
        return n.reshape(i);
      },
      "Array, Array": function (n, i) {
        return (
          i.forEach(function (c) {
            if (!t(c)) throw new TypeError("Invalid size for dimension: " + c);
          }),
          zp(n, i)
        );
      },
    });
  });
function wa(e, r, t, a) {
  if (!(this instanceof wa))
    throw new SyntaxError("Constructor must be called with the new operator");
  (this.fn = e),
    (this.count = r),
    (this.min = t),
    (this.max = a),
    (this.message =
      "Wrong number of arguments in function " +
      e +
      " (" +
      r +
      " provided, " +
      t +
      (a != null ? "-" + a : "") +
      " expected)"),
    (this.stack = new Error().stack);
}
wa.prototype = new Error();
wa.prototype.constructor = Error;
wa.prototype.name = "ArgumentsError";
wa.prototype.isArgumentsError = !0;
var MM = "resize",
  AM = ["config", "matrix"],
  SM = P(MM, AM, (e) => {
    var { config: r, matrix: t } = e;
    return function (i, c, m) {
      if (arguments.length !== 2 && arguments.length !== 3)
        throw new wa("resize", arguments.length, 2, 3);
      if (
        (ze(c) && (c = c.valueOf()),
        Qe(c[0]) &&
          (c = c.map(function (s) {
            return Qe(s) ? s.toNumber() : s;
          })),
        ze(i))
      )
        return i.resize(c, m, !0);
      if (typeof i == "string") return a(i, c, m);
      var f = Array.isArray(i) ? !1 : r.matrix !== "Array";
      if (c.length === 0) {
        for (; Array.isArray(i); ) i = i[0];
        return Fe(i);
      } else {
        Array.isArray(i) || (i = [i]), (i = Fe(i));
        var u = oa(i, c, m);
        return f ? t(u) : u;
      }
    };
    function a(n, i, c) {
      if (c !== void 0) {
        if (typeof c != "string" || c.length !== 1)
          throw new TypeError("Single character expected as defaultValue");
      } else c = " ";
      if (i.length !== 1) throw new Je(i.length, 1);
      var m = i[0];
      if (typeof m != "number" || !Be(m))
        throw new TypeError(
          "Invalid size, must contain positive integers (size: " + Ze(i) + ")"
        );
      if (n.length > m) return n.substring(0, m);
      if (n.length < m) {
        for (var f = n, u = 0, s = m - n.length; u < s; u++) f += c;
        return f;
      } else return n;
    }
  }),
  lc = "rotate",
  EM = ["typed", "multiply", "rotationMatrix"],
  CM = P(lc, EM, (e) => {
    var { typed: r, multiply: t, rotationMatrix: a } = e;
    return r(lc, {
      "Array , number | BigNumber | Complex | Unit": function (c, m) {
        n(c, 2);
        var f = t(a(m), c);
        return f.toArray();
      },
      "Matrix , number | BigNumber | Complex | Unit": function (c, m) {
        return n(c, 2), t(a(m), c);
      },
      "Array, number | BigNumber | Complex | Unit, Array | Matrix": function (
        c,
        m,
        f
      ) {
        n(c, 3);
        var u = t(a(m, f), c);
        return u;
      },
      "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function (
        c,
        m,
        f
      ) {
        return n(c, 3), t(a(m, f), c);
      },
    });
    function n(i, c) {
      var m = Array.isArray(i) ? Xe(i) : i.size();
      if (m.length > 2)
        throw new RangeError("Vector must be of dimensions 1x".concat(c));
      if (m.length === 2 && m[1] !== 1)
        throw new RangeError("Vector must be of dimensions 1x".concat(c));
      if (m[0] !== c)
        throw new RangeError("Vector must be of dimensions 1x".concat(c));
    }
  }),
  cc = "rotationMatrix",
  $M = [
    "typed",
    "config",
    "multiplyScalar",
    "addScalar",
    "unaryMinus",
    "norm",
    "matrix",
    "BigNumber",
    "DenseMatrix",
    "SparseMatrix",
    "cos",
    "sin",
  ],
  OM = P(cc, $M, (e) => {
    var {
      typed: r,
      config: t,
      multiplyScalar: a,
      addScalar: n,
      unaryMinus: i,
      norm: c,
      BigNumber: m,
      matrix: f,
      DenseMatrix: u,
      SparseMatrix: s,
      cos: o,
      sin: l,
    } = e;
    return r(cc, {
      "": function () {
        return t.matrix === "Matrix" ? f([]) : [];
      },
      string: function (d) {
        return f(d);
      },
      "number | BigNumber | Complex | Unit": function (d) {
        return p(d, t.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber | Complex | Unit, string": function (d, y) {
        return p(d, y);
      },
      "number | BigNumber | Complex | Unit, Array": function (d, y) {
        var w = f(y);
        return v(w), b(d, w, void 0);
      },
      "number | BigNumber | Complex | Unit, Matrix": function (d, y) {
        v(y);
        var w = y.storage() || (t.matrix === "Matrix" ? "dense" : void 0);
        return b(d, y, w);
      },
      "number | BigNumber | Complex | Unit, Array, string": function (d, y, w) {
        var g = f(y);
        return v(g), b(d, g, w);
      },
      "number | BigNumber | Complex | Unit, Matrix, string": function (
        d,
        y,
        w
      ) {
        return v(y), b(d, y, w);
      },
    });
    function p(N, d) {
      var y = Qe(N),
        w = y ? new m(-1) : -1,
        g = o(N),
        S = l(N),
        A = [
          [g, a(w, S)],
          [S, g],
        ];
      return x(A, d);
    }
    function v(N) {
      var d = N.size();
      if (d.length < 1 || d[0] !== 3)
        throw new RangeError("Vector must be of dimensions 1x3");
    }
    function h(N) {
      return N.reduce((d, y) => a(d, y));
    }
    function x(N, d) {
      if (d) {
        if (d === "sparse") return new s(N);
        if (d === "dense") return new u(N);
        throw new TypeError('Unknown matrix type "'.concat(d, '"'));
      }
      return N;
    }
    function b(N, d, y) {
      var w = c(d);
      if (w === 0) throw new RangeError("Rotation around zero vector");
      var g = Qe(N) ? m : null,
        S = g ? new g(1) : 1,
        A = g ? new g(-1) : -1,
        E = g ? new g(d.get([0]) / w) : d.get([0]) / w,
        M = g ? new g(d.get([1]) / w) : d.get([1]) / w,
        B = g ? new g(d.get([2]) / w) : d.get([2]) / w,
        C = o(N),
        _ = n(S, i(C)),
        z = l(N),
        I = n(C, h([E, E, _])),
        T = n(h([E, M, _]), h([A, B, z])),
        D = n(h([E, B, _]), h([M, z])),
        Z = n(h([E, M, _]), h([B, z])),
        O = n(C, h([M, M, _])),
        H = n(h([M, B, _]), h([A, E, z])),
        Q = n(h([E, B, _]), h([A, M, z])),
        te = n(h([M, B, _]), h([E, z])),
        J = n(C, h([B, B, _])),
        re = [
          [I, T, D],
          [Z, O, H],
          [Q, te, J],
        ];
      return x(re, y);
    }
  }),
  fc = "row",
  TM = ["typed", "Index", "matrix", "range"],
  mh = P(fc, TM, (e) => {
    var { typed: r, Index: t, matrix: a, range: n } = e;
    return r(fc, {
      "Matrix, number": i,
      "Array, number": function (m, f) {
        return i(a(Fe(m)), f).valueOf();
      },
    });
    function i(c, m) {
      if (c.size().length !== 2)
        throw new Error("Only two dimensional matrix is supported");
      cr(m, c.size()[0]);
      var f = n(0, c.size()[1]),
        u = new t(m, f);
      return c.subset(u);
    }
  }),
  mc = "size",
  DM = ["typed", "config", "?matrix"],
  BM = P(mc, DM, (e) => {
    var { typed: r, config: t, matrix: a } = e;
    return r(mc, {
      Matrix: function (i) {
        return i.create(i.size());
      },
      Array: Xe,
      string: function (i) {
        return t.matrix === "Array" ? [i.length] : a([i.length]);
      },
      "number | Complex | BigNumber | Unit | boolean | null": function (i) {
        return t.matrix === "Array" ? [] : a ? a([]) : ch();
      },
    });
  }),
  pc = "squeeze",
  _M = ["typed", "matrix"],
  IM = P(pc, _M, (e) => {
    var { typed: r, matrix: t } = e;
    return r(pc, {
      Array: function (n) {
        return Oi(Fe(n));
      },
      Matrix: function (n) {
        var i = Oi(n.toArray());
        return Array.isArray(i) ? t(i) : i;
      },
      any: function (n) {
        return Fe(n);
      },
    });
  }),
  vc = "subset",
  RM = ["typed", "matrix"],
  ph = P(vc, RM, (e) => {
    var { typed: r, matrix: t } = e;
    return r(vc, {
      "Array, Index": function (n, i) {
        var c = t(n),
          m = c.subset(i);
        return i.isScalar() ? m : m.valueOf();
      },
      "Matrix, Index": function (n, i) {
        return n.subset(i);
      },
      "Object, Index": PM,
      "string, Index": FM,
      "Array, Index, any": function (n, i, c) {
        return t(Fe(n))
          .subset(i, c, void 0)
          .valueOf();
      },
      "Array, Index, any, any": function (n, i, c, m) {
        return t(Fe(n)).subset(i, c, m).valueOf();
      },
      "Matrix, Index, any": function (n, i, c) {
        return n.clone().subset(i, c);
      },
      "Matrix, Index, any, any": function (n, i, c, m) {
        return n.clone().subset(i, c, m);
      },
      "string, Index, string": hc,
      "string, Index, string, string": hc,
      "Object, Index, any": qM,
    });
  });
function FM(e, r) {
  if (!Za(r)) throw new TypeError("Index expected");
  if (r.size().length !== 1) throw new Je(r.size().length, 1);
  var t = e.length;
  cr(r.min()[0], t), cr(r.max()[0], t);
  var a = r.dimension(0),
    n = "";
  return (
    a.forEach(function (i) {
      n += e.charAt(i);
    }),
    n
  );
}
function hc(e, r, t, a) {
  if (!r || r.isIndex !== !0) throw new TypeError("Index expected");
  if (r.size().length !== 1) throw new Je(r.size().length, 1);
  if (a !== void 0) {
    if (typeof a != "string" || a.length !== 1)
      throw new TypeError("Single character expected as defaultValue");
  } else a = " ";
  var n = r.dimension(0),
    i = n.size()[0];
  if (i !== t.length) throw new Je(n.size()[0], t.length);
  var c = e.length;
  cr(r.min()[0]), cr(r.max()[0]);
  for (var m = [], f = 0; f < c; f++) m[f] = e.charAt(f);
  if (
    (n.forEach(function (o, l) {
      m[o] = t.charAt(l[0]);
    }),
    m.length > c)
  )
    for (var u = c - 1, s = m.length; u < s; u++) m[u] || (m[u] = a);
  return m.join("");
}
function PM(e, r) {
  if (r.size().length !== 1) throw new Je(r.size(), 1);
  var t = r.dimension(0);
  if (typeof t != "string")
    throw new TypeError(
      "String expected as index to retrieve an object property"
    );
  return ct(e, t);
}
function qM(e, r, t) {
  if (r.size().length !== 1) throw new Je(r.size(), 1);
  var a = r.dimension(0);
  if (typeof a != "string")
    throw new TypeError(
      "String expected as index to retrieve an object property"
    );
  var n = Fe(e);
  return ua(n, a, t), n;
}
var zM = "transpose",
  UM = ["typed", "matrix"],
  LM = P(zM, UM, (e) => {
    var { typed: r, matrix: t } = e;
    return r("transpose", {
      Array: function (c) {
        return this(t(c)).valueOf();
      },
      Matrix: function (c) {
        var m = c.size(),
          f;
        switch (m.length) {
          case 1:
            f = c.clone();
            break;
          case 2:
            {
              var u = m[0],
                s = m[1];
              if (s === 0)
                throw new RangeError(
                  "Cannot transpose a 2D matrix with no columns (size: " +
                    Ze(m) +
                    ")"
                );
              switch (c.storage()) {
                case "dense":
                  f = a(c, u, s);
                  break;
                case "sparse":
                  f = n(c, u, s);
                  break;
              }
            }
            break;
          default:
            throw new RangeError(
              "Matrix must be a vector or two dimensional (size: " +
                Ze(this._size) +
                ")"
            );
        }
        return f;
      },
      any: function (c) {
        return Fe(c);
      },
    });
    function a(i, c, m) {
      for (var f = i._data, u = [], s, o = 0; o < m; o++) {
        s = u[o] = [];
        for (var l = 0; l < c; l++) s[l] = Fe(f[l][o]);
      }
      return i.createDenseMatrix({
        data: u,
        size: [m, c],
        datatype: i._datatype,
      });
    }
    function n(i, c, m) {
      for (
        var f = i._values,
          u = i._index,
          s = i._ptr,
          o = f ? [] : void 0,
          l = [],
          p = [],
          v = [],
          h = 0;
        h < c;
        h++
      )
        v[h] = 0;
      var x, b, N;
      for (x = 0, b = u.length; x < b; x++) v[u[x]]++;
      for (var d = 0, y = 0; y < c; y++) p.push(d), (d += v[y]), (v[y] = p[y]);
      for (p.push(d), N = 0; N < m; N++)
        for (var w = s[N], g = s[N + 1], S = w; S < g; S++) {
          var A = v[u[S]]++;
          (l[A] = N), f && (o[A] = Fe(f[S]));
        }
      return i.createSparseMatrix({
        values: o,
        index: l,
        ptr: p,
        size: [m, c],
        datatype: i._datatype,
      });
    }
  }),
  dc = "ctranspose",
  kM = ["typed", "transpose", "conj"],
  VM = P(dc, kM, (e) => {
    var { typed: r, transpose: t, conj: a } = e;
    return r(dc, {
      any: function (i) {
        return a(t(i));
      },
    });
  }),
  gc = "zeros",
  GM = ["typed", "config", "matrix", "BigNumber"],
  HM = P(gc, GM, (e) => {
    var { typed: r, config: t, matrix: a, BigNumber: n } = e;
    return r(gc, {
      "": function () {
        return t.matrix === "Array" ? i([]) : i([], "default");
      },
      "...number | BigNumber | string": function (u) {
        var s = u[u.length - 1];
        if (typeof s == "string") {
          var o = u.pop();
          return i(u, o);
        } else return t.matrix === "Array" ? i(u) : i(u, "default");
      },
      Array: i,
      Matrix: function (u) {
        var s = u.storage();
        return i(u.valueOf(), s);
      },
      "Array | Matrix, string": function (u, s) {
        return i(u.valueOf(), s);
      },
    });
    function i(f, u) {
      var s = c(f),
        o = s ? new n(0) : 0;
      if ((m(f), u)) {
        var l = a(u);
        return f.length > 0 ? l.resize(f, o) : l;
      } else {
        var p = [];
        return f.length > 0 ? oa(p, f, o) : p;
      }
    }
    function c(f) {
      var u = !1;
      return (
        f.forEach(function (s, o, l) {
          Qe(s) && ((u = !0), (l[o] = s.toNumber()));
        }),
        u
      );
    }
    function m(f) {
      f.forEach(function (u) {
        if (typeof u != "number" || !Be(u) || u < 0)
          throw new Error(
            "Parameters in function zeros must be positive integers"
          );
      });
    }
  }),
  yc = "fft",
  ZM = [
    "typed",
    "matrix",
    "addScalar",
    "multiplyScalar",
    "divideScalar",
    "exp",
    "tau",
    "i",
  ],
  JM = P(yc, ZM, (e) => {
    var {
      typed: r,
      matrix: t,
      addScalar: a,
      multiplyScalar: n,
      divideScalar: i,
      exp: c,
      tau: m,
      i: f,
    } = e;
    return r(yc, {
      Array: u,
      Matrix: function (p) {
        return p.create(u(p.toArray()));
      },
    });
    function u(l) {
      var p = Xe(l);
      return p.length === 1
        ? o(l, p[0])
        : s(
            l.map((v) => u(v, p.slice(1))),
            0
          );
    }
    function s(l, p) {
      var v = Xe(l);
      if (p !== 0) return new Array(v[0]).fill(0).map((x, b) => s(l[b], p - 1));
      if (v.length === 1) return o(l);
      function h(x) {
        var b = Xe(x);
        return new Array(b[1])
          .fill(0)
          .map((N, d) => new Array(b[0]).fill(0).map((y, w) => x[w][d]));
      }
      return h(s(h(l), 1));
    }
    function o(l) {
      var p = l.length;
      if (p === 1) return [l[0]];
      if (p % 2 === 0) {
        for (
          var v = [
              ...o(l.filter((N, d) => d % 2 === 0)),
              ...o(l.filter((N, d) => d % 2 === 1)),
            ],
            h = 0;
          h < p / 2;
          h++
        ) {
          var x = v[h],
            b = n(v[h + p / 2], c(n(n(m, f), i(-h, p))));
          (v[h] = a(x, b)), (v[h + p / 2] = a(x, n(-1, b)));
        }
        return v;
      }
      throw new Error("Can only calculate FFT of power-of-two size");
    }
  }),
  bc = "ifft",
  WM = ["typed", "fft", "dotDivide", "conj"],
  XM = P(bc, WM, (e) => {
    var { typed: r, fft: t, dotDivide: a, conj: n } = e;
    return r(bc, {
      "Array | Matrix": function (c) {
        var m = ze(c) ? c.size() : Xe(c);
        return a(
          n(t(n(c))),
          m.reduce((f, u) => f * u, 1)
        );
      },
    });
  }),
  YM = "erf",
  QM = ["typed"],
  jM = P(YM, QM, (e) => {
    var { typed: r } = e;
    return r("name", {
      number: function (c) {
        var m = Math.abs(c);
        return m >= r2
          ? mn(c)
          : m <= KM
          ? mn(c) * t(m)
          : m <= 4
          ? mn(c) * (1 - a(m))
          : mn(c) * (1 - n(m));
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
    });
    function t(i) {
      var c = i * i,
        m = Vt[0][4] * c,
        f = c,
        u;
      for (u = 0; u < 3; u += 1)
        (m = (m + Vt[0][u]) * c), (f = (f + Xn[0][u]) * c);
      return (i * (m + Vt[0][3])) / (f + Xn[0][3]);
    }
    function a(i) {
      var c = Vt[1][8] * i,
        m = i,
        f;
      for (f = 0; f < 7; f += 1)
        (c = (c + Vt[1][f]) * i), (m = (m + Xn[1][f]) * i);
      var u = (c + Vt[1][7]) / (m + Xn[1][7]),
        s = parseInt(i * 16) / 16,
        o = (i - s) * (i + s);
      return Math.exp(-s * s) * Math.exp(-o) * u;
    }
    function n(i) {
      var c = 1 / (i * i),
        m = Vt[2][5] * c,
        f = c,
        u;
      for (u = 0; u < 4; u += 1)
        (m = (m + Vt[2][u]) * c), (f = (f + Xn[2][u]) * c);
      var s = (c * (m + Vt[2][4])) / (f + Xn[2][4]);
      (s = (e2 - s) / i), (c = parseInt(i * 16) / 16);
      var o = (i - c) * (i + c);
      return Math.exp(-c * c) * Math.exp(-o) * s;
    }
  }),
  KM = 0.46875,
  e2 = 0.5641895835477563,
  Vt = [
    [
      3.1611237438705655, 113.86415415105016, 377.485237685302,
      3209.3775891384694, 0.18577770618460315,
    ],
    [
      0.5641884969886701, 8.883149794388377, 66.11919063714163,
      298.6351381974001, 881.952221241769, 1712.0476126340707,
      2051.0783778260716, 1230.3393547979972, 21531153547440383e-24,
    ],
    [
      0.30532663496123236, 0.36034489994980445, 0.12578172611122926,
      0.016083785148742275, 0.0006587491615298378, 0.016315387137302097,
    ],
  ],
  Xn = [
    [
      23.601290952344122, 244.02463793444417, 1282.6165260773723,
      2844.236833439171,
    ],
    [
      15.744926110709835, 117.6939508913125, 537.1811018620099,
      1621.3895745666903, 3290.7992357334597, 4362.619090143247,
      3439.3676741437216, 1230.3393548037495,
    ],
    [
      2.568520192289822, 1.8729528499234604, 0.5279051029514285,
      0.06051834131244132, 0.0023352049762686918,
    ],
  ],
  r2 = Math.pow(2, 53),
  xc = "mode",
  t2 = ["typed", "isNaN", "isNumeric"],
  n2 = P(xc, t2, (e) => {
    var { typed: r, isNaN: t, isNumeric: a } = e;
    return r(xc, {
      "Array | Matrix": n,
      "...": function (c) {
        return n(c);
      },
    });
    function n(i) {
      i = Ke(i.valueOf());
      var c = i.length;
      if (c === 0) throw new Error("Cannot calculate mode of an empty array");
      for (var m = {}, f = [], u = 0, s = 0; s < i.length; s++) {
        var o = i[s];
        if (a(o) && t(o))
          throw new Error(
            "Cannot calculate mode of an array containing NaN values"
          );
        o in m || (m[o] = 0),
          m[o]++,
          m[o] === u ? f.push(o) : m[o] > u && ((u = m[o]), (f = [o]));
      }
      return f;
    }
  });
function Xr(e, r, t) {
  var a;
  return String(e).indexOf("Unexpected type") !== -1
    ? ((a =
        arguments.length > 2
          ? " (type: " + vr(t) + ", value: " + JSON.stringify(t) + ")"
          : " (type: " + e.data.actual + ")"),
      new TypeError(
        "Cannot calculate " + r + ", unexpected type of argument" + a
      ))
    : String(e).indexOf("complex numbers") !== -1
    ? ((a =
        arguments.length > 2
          ? " (type: " + vr(t) + ", value: " + JSON.stringify(t) + ")"
          : ""),
      new TypeError(
        "Cannot calculate " +
          r +
          ", no ordering relation is defined for complex numbers" +
          a
      ))
    : e;
}
var wc = "prod",
  a2 = ["typed", "config", "multiplyScalar", "numeric"],
  i2 = P(wc, a2, (e) => {
    var { typed: r, config: t, multiplyScalar: a, numeric: n } = e;
    return r(wc, {
      "Array | Matrix": i,
      "Array | Matrix, number | BigNumber": function (m, f) {
        throw new Error("prod(A, dim) is not yet supported");
      },
      "...": function (m) {
        return i(m);
      },
    });
    function i(c) {
      var m;
      if (
        (Qt(c, function (f) {
          try {
            m = m === void 0 ? f : a(m, f);
          } catch (u) {
            throw Xr(u, "prod", f);
          }
        }),
        typeof m == "string" && (m = n(m, t.number)),
        m === void 0)
      )
        throw new Error("Cannot calculate prod of an empty array");
      return m;
    }
  }),
  Nc = "format",
  o2 = ["typed"],
  s2 = P(Nc, o2, (e) => {
    var { typed: r } = e;
    return r(Nc, { any: Ze, "any, Object | function | number": Ze });
  }),
  Mc = "bin",
  u2 = ["typed", "format"],
  l2 = P(Mc, u2, (e) => {
    var { typed: r, format: t } = e;
    return r(Mc, {
      "number | BigNumber": function (n) {
        return t(n, { notation: "bin" });
      },
      "number | BigNumber, number": function (n, i) {
        return t(n, { notation: "bin", wordSize: i });
      },
    });
  }),
  Ac = "oct",
  c2 = ["typed", "format"],
  f2 = P(Ac, c2, (e) => {
    var { typed: r, format: t } = e;
    return r(Ac, {
      "number | BigNumber": function (n) {
        return t(n, { notation: "oct" });
      },
      "number | BigNumber, number": function (n, i) {
        return t(n, { notation: "oct", wordSize: i });
      },
    });
  }),
  Sc = "hex",
  m2 = ["typed", "format"],
  p2 = P(Sc, m2, (e) => {
    var { typed: r, format: t } = e;
    return r(Sc, {
      "number | BigNumber": function (n) {
        return t(n, { notation: "hex" });
      },
      "number | BigNumber, number": function (n, i) {
        return t(n, { notation: "hex", wordSize: i });
      },
    });
  }),
  Ec = "print",
  v2 = ["typed"],
  h2 = P(Ec, v2, (e) => {
    var { typed: r } = e;
    return r(Ec, {
      "string, Object | Array": Cc,
      "string, Object | Array, number | Object": Cc,
    });
  });
function Cc(e, r, t) {
  return e.replace(/\$([\w.]+)/g, function (a, n) {
    for (var i = n.split("."), c = r[i.shift()]; i.length && c !== void 0; ) {
      var m = i.shift();
      c = m ? c[m] : c + ".";
    }
    return c !== void 0 ? (et(c) ? c : Ze(c, t)) : a;
  });
}
var $c = "to",
  d2 = ["typed", "matrix"],
  g2 = P($c, d2, (e) => {
    var { typed: r, matrix: t } = e,
      a = hr({ typed: r }),
      n = ar({ typed: r });
    return r($c, {
      "Unit, Unit | string": function (c, m) {
        return c.to(m);
      },
      "Matrix, Matrix": function (c, m) {
        return a(c, m, this);
      },
      "Array, Array": function (c, m) {
        return this(t(c), t(m)).valueOf();
      },
      "Array, Matrix": function (c, m) {
        return this(t(c), m);
      },
      "Matrix, Array": function (c, m) {
        return this(c, t(m));
      },
      "Matrix, any": function (c, m) {
        return n(c, m, this, !1);
      },
      "any, Matrix": function (c, m) {
        return n(m, c, this, !0);
      },
      "Array, any": function (c, m) {
        return n(t(c), m, this, !1).valueOf();
      },
      "any, Array": function (c, m) {
        return n(t(m), c, this, !0).valueOf();
      },
    });
  }),
  Oc = "isPrime",
  y2 = ["typed"],
  b2 = P(Oc, y2, (e) => {
    var { typed: r } = e;
    return r(Oc, {
      number: function (a) {
        if (a * 0 !== 0) return !1;
        if (a <= 3) return a > 1;
        if (a % 2 === 0 || a % 3 === 0) return !1;
        for (var n = 5; n * n <= a; n += 6)
          if (a % n === 0 || a % (n + 2) === 0) return !1;
        return !0;
      },
      BigNumber: function (a) {
        if (a.toNumber() * 0 !== 0) return !1;
        if (a.lte(3)) return a.gt(1);
        if (a.mod(2).eq(0) || a.mod(3).eq(0)) return !1;
        if (a.lt(Math.pow(2, 32))) {
          for (var n = a.toNumber(), i = 5; i * i <= n; i += 6)
            if (n % i === 0 || n % (i + 2) === 0) return !1;
          return !0;
        }
        function c(N, d, y) {
          for (var w = 1; !d.eq(0); )
            d.mod(2).eq(0)
              ? ((d = d.div(2)), (N = N.mul(N).mod(y)))
              : ((d = d.sub(1)), (w = N.mul(w).mod(y)));
          return w;
        }
        var m = a.constructor.clone({ precision: a.toFixed(0).length * 2 });
        a = new m(a);
        for (var f = 0, u = a.sub(1); u.mod(2).eq(0); )
          (u = u.div(2)), (f += 1);
        var s = null;
        if (a.lt("3317044064679887385961981"))
          s = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter(
            (N) => N < a
          );
        else {
          var o = Math.min(
            a.toNumber() - 2,
            Math.floor(2 * Math.pow(a.toFixed(0).length * Math.log(10), 2))
          );
          s = [];
          for (var l = 2; l <= o; l += 1) s.push(o);
        }
        for (var p = 0; p < s.length; p += 1) {
          var v = s[p],
            h = c(a.sub(a).add(v), u, a);
          if (!h.eq(1)) {
            for (var x = 0, b = h; !b.eq(a.sub(1)); x += 1, b = b.mul(b).mod(a))
              if (x === f - 1) return !1;
          }
        }
        return !0;
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  x2 = "numeric",
  w2 = ["number", "?bignumber", "?fraction"],
  N2 = P(x2, w2, (e) => {
    var { number: r, bignumber: t, fraction: a } = e,
      n = { string: !0, number: !0, BigNumber: !0, Fraction: !0 },
      i = {
        number: (c) => r(c),
        BigNumber: t ? (c) => t(c) : js,
        Fraction: a ? (c) => a(c) : lh,
      };
    return function (m, f) {
      var u = vr(m);
      if (!(u in n))
        throw new TypeError(
          "Cannot convert " +
            m +
            ' of type "' +
            u +
            '"; valid input types are ' +
            Object.keys(n).join(", ")
        );
      if (!(f in i))
        throw new TypeError(
          "Cannot convert " +
            m +
            ' to type "' +
            f +
            '"; valid output types are ' +
            Object.keys(i).join(", ")
        );
      return f === u ? m : i[f](m);
    };
  }),
  Tc = "divideScalar",
  M2 = ["typed", "numeric"],
  A2 = P(Tc, M2, (e) => {
    var { typed: r, numeric: t } = e;
    return r(Tc, {
      "number, number": function (n, i) {
        return n / i;
      },
      "Complex, Complex": function (n, i) {
        return n.div(i);
      },
      "BigNumber, BigNumber": function (n, i) {
        return n.div(i);
      },
      "Fraction, Fraction": function (n, i) {
        return n.div(i);
      },
      "Unit, number | Fraction | BigNumber": function (n, i) {
        var c = n.clone(),
          m = t(1, vr(i));
        return (
          (c.value = this(c.value === null ? c._normalize(m) : c.value, i)), c
        );
      },
      "number | Fraction | BigNumber, Unit": function (n, i) {
        var c = i.clone();
        c = c.pow(-1);
        var m = t(1, vr(n));
        return (
          (c.value = this(n, i.value === null ? i._normalize(m) : i.value)), c
        );
      },
      "Unit, Unit": function (n, i) {
        return n.divide(i);
      },
    });
  }),
  Dc = "pow",
  S2 = [
    "typed",
    "config",
    "identity",
    "multiply",
    "matrix",
    "inv",
    "fraction",
    "number",
    "Complex",
  ],
  E2 = P(Dc, S2, (e) => {
    var {
      typed: r,
      config: t,
      identity: a,
      multiply: n,
      matrix: i,
      inv: c,
      number: m,
      fraction: f,
      Complex: u,
    } = e;
    return r(Dc, {
      "number, number": s,
      "Complex, Complex": function (v, h) {
        return v.pow(h);
      },
      "BigNumber, BigNumber": function (v, h) {
        return h.isInteger() || v >= 0 || t.predictable
          ? v.pow(h)
          : new u(v.toNumber(), 0).pow(h.toNumber(), 0);
      },
      "Fraction, Fraction": function (v, h) {
        var x = v.pow(h);
        if (x != null) return x;
        if (t.predictable)
          throw new Error(
            "Result of pow is non-rational and cannot be expressed as a fraction"
          );
        return s(v.valueOf(), h.valueOf());
      },
      "Array, number": o,
      "Array, BigNumber": function (v, h) {
        return o(v, h.toNumber());
      },
      "Matrix, number": l,
      "Matrix, BigNumber": function (v, h) {
        return l(v, h.toNumber());
      },
      "Unit, number | BigNumber": function (v, h) {
        return v.pow(h);
      },
    });
    function s(p, v) {
      if (t.predictable && !Be(v) && p < 0)
        try {
          var h = f(v),
            x = m(h);
          if ((v === x || Math.abs((v - x) / v) < 1e-14) && h.d % 2 === 1)
            return (h.n % 2 === 0 ? 1 : -1) * Math.pow(-p, v);
        } catch {}
      return t.predictable &&
        ((p < -1 && v === 1 / 0) || (p > -1 && p < 0 && v === -1 / 0))
        ? NaN
        : Be(v) || p >= 0 || t.predictable
        ? Nv(p, v)
        : (p * p < 1 && v === 1 / 0) || (p * p > 1 && v === -1 / 0)
        ? 0
        : new u(p, 0).pow(v, 0);
    }
    function o(p, v) {
      if (!Be(v))
        throw new TypeError(
          "For A^b, b must be an integer (value is " + v + ")"
        );
      var h = Xe(p);
      if (h.length !== 2)
        throw new Error(
          "For A^b, A must be 2 dimensional (A has " + h.length + " dimensions)"
        );
      if (h[0] !== h[1])
        throw new Error(
          "For A^b, A must be square (size is " + h[0] + "x" + h[1] + ")"
        );
      if (v < 0)
        try {
          return o(c(p), -v);
        } catch (N) {
          throw N.message === "Cannot calculate inverse, determinant is zero"
            ? new TypeError(
                "For A^b, when A is not invertible, b must be a positive integer (value is " +
                  v +
                  ")"
              )
            : N;
        }
      for (var x = a(h[0]).valueOf(), b = p; v >= 1; )
        (v & 1) === 1 && (x = n(b, x)), (v >>= 1), (b = n(b, b));
      return x;
    }
    function l(p, v) {
      return i(o(p.valueOf(), v));
    }
  }),
  Yn = "Number of decimals in function round must be an integer",
  Bc = "round",
  C2 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"],
  $2 = P(Bc, C2, (e) => {
    var {
        typed: r,
        matrix: t,
        equalScalar: a,
        zeros: n,
        BigNumber: i,
        DenseMatrix: c,
      } = e,
      m = Ur({ typed: r, equalScalar: a }),
      f = Ir({ typed: r, DenseMatrix: c }),
      u = ar({ typed: r });
    return r(Bc, {
      number: Ku,
      "number, number": Ku,
      "number, BigNumber": function (o, l) {
        if (!l.isInteger()) throw new TypeError(Yn);
        return new i(o).toDecimalPlaces(l.toNumber());
      },
      Complex: function (o) {
        return o.round();
      },
      "Complex, number": function (o, l) {
        if (l % 1) throw new TypeError(Yn);
        return o.round(l);
      },
      "Complex, BigNumber": function (o, l) {
        if (!l.isInteger()) throw new TypeError(Yn);
        var p = l.toNumber();
        return o.round(p);
      },
      BigNumber: function (o) {
        return o.toDecimalPlaces(0);
      },
      "BigNumber, BigNumber": function (o, l) {
        if (!l.isInteger()) throw new TypeError(Yn);
        return o.toDecimalPlaces(l.toNumber());
      },
      Fraction: function (o) {
        return o.round();
      },
      "Fraction, number": function (o, l) {
        if (l % 1) throw new TypeError(Yn);
        return o.round(l);
      },
      "Fraction, BigNumber": function (o, l) {
        if (!l.isInteger()) throw new TypeError(Yn);
        return o.round(l.toNumber());
      },
      "Array | Matrix": function (o) {
        return Oe(o, this);
      },
      "SparseMatrix, number | BigNumber": function (o, l) {
        return m(o, l, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (o, l) {
        return u(o, l, this, !1);
      },
      "Array, number | BigNumber": function (o, l) {
        return u(t(o), l, this, !1).valueOf();
      },
      "number | Complex | BigNumber | Fraction, SparseMatrix": function (o, l) {
        return a(o, 0) ? n(l.size(), l.storage()) : f(l, o, this, !0);
      },
      "number | Complex | BigNumber | Fraction, DenseMatrix": function (o, l) {
        return a(o, 0) ? n(l.size(), l.storage()) : u(l, o, this, !0);
      },
      "number | Complex | BigNumber | Fraction, Array": function (o, l) {
        return u(t(l), o, this, !0).valueOf();
      },
    });
  }),
  _c = "log",
  O2 = ["config", "typed", "divideScalar", "Complex"],
  T2 = P(_c, O2, (e) => {
    var { typed: r, config: t, divideScalar: a, Complex: n } = e;
    return r(_c, {
      number: function (c) {
        return c >= 0 || t.predictable ? Pb(c) : new n(c, 0).log();
      },
      Complex: function (c) {
        return c.log();
      },
      BigNumber: function (c) {
        return !c.isNegative() || t.predictable
          ? c.ln()
          : new n(c.toNumber(), 0).log();
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
      "any, any": function (c, m) {
        return a(this(c), this(m));
      },
    });
  }),
  Ic = "log1p",
  D2 = ["typed", "config", "divideScalar", "log", "Complex"],
  B2 = P(Ic, D2, (e) => {
    var { typed: r, config: t, divideScalar: a, log: n, Complex: i } = e;
    return r(Ic, {
      number: function (f) {
        return f >= -1 || t.predictable ? z0(f) : c(new i(f, 0));
      },
      Complex: c,
      BigNumber: function (f) {
        var u = f.plus(1);
        return !u.isNegative() || t.predictable
          ? u.ln()
          : c(new i(f.toNumber(), 0));
      },
      "Array | Matrix": function (f) {
        return Oe(f, this);
      },
      "any, any": function (f, u) {
        return a(this(f), n(u));
      },
    });
    function c(m) {
      var f = m.re + 1;
      return new i(
        Math.log(Math.sqrt(f * f + m.im * m.im)),
        Math.atan2(m.im, f)
      );
    }
  }),
  Rc = "nthRoots",
  _2 = ["config", "typed", "divideScalar", "Complex"],
  I2 = P(Rc, _2, (e) => {
    var { typed: r, config: t, divideScalar: a, Complex: n } = e,
      i = [
        function (f) {
          return new n(f, 0);
        },
        function (f) {
          return new n(0, f);
        },
        function (f) {
          return new n(-f, 0);
        },
        function (f) {
          return new n(0, -f);
        },
      ];
    function c(m, f) {
      if (f < 0) throw new Error("Root must be greater than zero");
      if (f === 0) throw new Error("Root must be non-zero");
      if (f % 1 !== 0) throw new Error("Root must be an integer");
      if (m === 0 || m.abs() === 0) return [new n(0, 0)];
      var u = typeof m == "number",
        s;
      (u || m.re === 0 || m.im === 0) &&
        (u
          ? (s = 2 * +(m < 0))
          : m.im === 0
          ? (s = 2 * +(m.re < 0))
          : (s = 2 * +(m.im < 0) + 1));
      for (
        var o = m.arg(), l = m.abs(), p = [], v = Math.pow(l, 1 / f), h = 0;
        h < f;
        h++
      ) {
        var x = (s + 4 * h) / f;
        if (x === Math.round(x)) {
          p.push(i[x % 4](v));
          continue;
        }
        p.push(new n({ r: v, phi: (o + 2 * Math.PI * h) / f }));
      }
      return p;
    }
    return r(Rc, {
      Complex: function (f) {
        return c(f, 2);
      },
      "Complex, number": c,
    });
  }),
  Fc = "dotPow",
  R2 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix"],
  F2 = P(Fc, R2, (e) => {
    var { typed: r, equalScalar: t, matrix: a, pow: n, DenseMatrix: i } = e,
      c = Yr({ typed: r }),
      m = qt({ typed: r, DenseMatrix: i }),
      f = Ur({ typed: r, equalScalar: t }),
      u = Ir({ typed: r, DenseMatrix: i }),
      s = hr({ typed: r }),
      o = ar({ typed: r });
    return r(Fc, {
      "any, any": n,
      "SparseMatrix, SparseMatrix": function (p, v) {
        return m(p, v, n, !1);
      },
      "SparseMatrix, DenseMatrix": function (p, v) {
        return c(v, p, n, !0);
      },
      "DenseMatrix, SparseMatrix": function (p, v) {
        return c(p, v, n, !1);
      },
      "DenseMatrix, DenseMatrix": function (p, v) {
        return s(p, v, n);
      },
      "Array, Array": function (p, v) {
        return this(a(p), a(v)).valueOf();
      },
      "Array, Matrix": function (p, v) {
        return this(a(p), v);
      },
      "Matrix, Array": function (p, v) {
        return this(p, a(v));
      },
      "SparseMatrix, any": function (p, v) {
        return f(p, v, this, !1);
      },
      "DenseMatrix, any": function (p, v) {
        return o(p, v, this, !1);
      },
      "any, SparseMatrix": function (p, v) {
        return u(v, p, this, !0);
      },
      "any, DenseMatrix": function (p, v) {
        return o(v, p, this, !0);
      },
      "Array, any": function (p, v) {
        return o(a(p), v, this, !1).valueOf();
      },
      "any, Array": function (p, v) {
        return o(a(v), p, this, !0).valueOf();
      },
    });
  }),
  Pc = "dotDivide",
  P2 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix"],
  q2 = P(Pc, P2, (e) => {
    var {
        typed: r,
        matrix: t,
        equalScalar: a,
        divideScalar: n,
        DenseMatrix: i,
      } = e,
      c = Et({ typed: r, equalScalar: a }),
      m = Yr({ typed: r }),
      f = qt({ typed: r, DenseMatrix: i }),
      u = Ur({ typed: r, equalScalar: a }),
      s = Ir({ typed: r, DenseMatrix: i }),
      o = hr({ typed: r }),
      l = ar({ typed: r });
    return r(Pc, {
      "any, any": n,
      "SparseMatrix, SparseMatrix": function (v, h) {
        return f(v, h, n, !1);
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return c(h, v, n, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        return m(v, h, n, !1);
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return o(v, h, n);
      },
      "Array, Array": function (v, h) {
        return this(t(v), t(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(t(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, t(h));
      },
      "SparseMatrix, any": function (v, h) {
        return u(v, h, n, !1);
      },
      "DenseMatrix, any": function (v, h) {
        return l(v, h, n, !1);
      },
      "any, SparseMatrix": function (v, h) {
        return s(h, v, n, !0);
      },
      "any, DenseMatrix": function (v, h) {
        return l(h, v, n, !0);
      },
      "Array, any": function (v, h) {
        return l(t(v), h, n, !1).valueOf();
      },
      "any, Array": function (v, h) {
        return l(t(h), v, n, !0).valueOf();
      },
    });
  });
function Ya(e) {
  var { DenseMatrix: r } = e;
  return function (a, n, i) {
    var c = a.size();
    if (c.length !== 2)
      throw new RangeError(
        "Matrix must be two dimensional (size: " + Ze(c) + ")"
      );
    var m = c[0],
      f = c[1];
    if (m !== f)
      throw new RangeError("Matrix must be square (size: " + Ze(c) + ")");
    var u = [];
    if (ze(n)) {
      var s = n.size(),
        o = n._data;
      if (s.length === 1) {
        if (s[0] !== m)
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        for (var l = 0; l < m; l++) u[l] = [o[l]];
        return new r({ data: u, size: [m, 1], datatype: n._datatype });
      }
      if (s.length === 2) {
        if (s[0] !== m || s[1] !== 1)
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        if ($i(n)) {
          if (i) {
            u = [];
            for (var p = 0; p < m; p++) u[p] = [o[p][0]];
            return new r({ data: u, size: [m, 1], datatype: n._datatype });
          }
          return n;
        }
        if (An(n)) {
          for (var v = 0; v < m; v++) u[v] = [0];
          for (
            var h = n._values, x = n._index, b = n._ptr, N = b[1], d = b[0];
            d < N;
            d++
          ) {
            var y = x[d];
            u[y][0] = h[d];
          }
          return new r({ data: u, size: [m, 1], datatype: n._datatype });
        }
      }
      throw new RangeError(
        "Dimension mismatch. The right side has to be either 1- or 2-dimensional vector."
      );
    }
    if (sr(n)) {
      var w = Xe(n);
      if (w.length === 1) {
        if (w[0] !== m)
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        for (var g = 0; g < m; g++) u[g] = [n[g]];
        return new r({ data: u, size: [m, 1] });
      }
      if (w.length === 2) {
        if (w[0] !== m || w[1] !== 1)
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        for (var S = 0; S < m; S++) u[S] = [n[S][0]];
        return new r({ data: u, size: [m, 1] });
      }
      throw new RangeError(
        "Dimension mismatch. The right side has to be either 1- or 2-dimensional vector."
      );
    }
  };
}
var qc = "lsolve",
  z2 = [
    "typed",
    "matrix",
    "divideScalar",
    "multiplyScalar",
    "subtract",
    "equalScalar",
    "DenseMatrix",
  ],
  U2 = P(qc, z2, (e) => {
    var {
        typed: r,
        matrix: t,
        divideScalar: a,
        multiplyScalar: n,
        subtract: i,
        equalScalar: c,
        DenseMatrix: m,
      } = e,
      f = Ya({ DenseMatrix: m });
    return r(qc, {
      "SparseMatrix, Array | Matrix": function (l, p) {
        return s(l, p);
      },
      "DenseMatrix, Array | Matrix": function (l, p) {
        return u(l, p);
      },
      "Array, Array | Matrix": function (l, p) {
        var v = t(l),
          h = u(v, p);
        return h.valueOf();
      },
    });
    function u(o, l) {
      l = f(o, l, !0);
      for (
        var p = l._data,
          v = o._size[0],
          h = o._size[1],
          x = [],
          b = o._data,
          N = 0;
        N < h;
        N++
      ) {
        var d = p[N][0] || 0,
          y = void 0;
        if (c(d, 0)) y = 0;
        else {
          var w = b[N][N];
          if (c(w, 0))
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          y = a(d, w);
          for (var g = N + 1; g < v; g++)
            p[g] = [i(p[g][0] || 0, n(y, b[g][N]))];
        }
        x[N] = [y];
      }
      return new m({ data: x, size: [v, 1] });
    }
    function s(o, l) {
      l = f(o, l, !0);
      for (
        var p = l._data,
          v = o._size[0],
          h = o._size[1],
          x = o._values,
          b = o._index,
          N = o._ptr,
          d = [],
          y = 0;
        y < h;
        y++
      ) {
        var w = p[y][0] || 0;
        if (c(w, 0)) d[y] = [0];
        else {
          for (
            var g = 0, S = [], A = [], E = N[y], M = N[y + 1], B = E;
            B < M;
            B++
          ) {
            var C = b[B];
            C === y ? (g = x[B]) : C > y && (S.push(x[B]), A.push(C));
          }
          if (c(g, 0))
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          for (var _ = a(w, g), z = 0, I = A.length; z < I; z++) {
            var T = A[z];
            p[T] = [i(p[T][0] || 0, n(_, S[z]))];
          }
          d[y] = [_];
        }
      }
      return new m({ data: d, size: [v, 1] });
    }
  }),
  zc = "usolve",
  L2 = [
    "typed",
    "matrix",
    "divideScalar",
    "multiplyScalar",
    "subtract",
    "equalScalar",
    "DenseMatrix",
  ],
  k2 = P(zc, L2, (e) => {
    var {
        typed: r,
        matrix: t,
        divideScalar: a,
        multiplyScalar: n,
        subtract: i,
        equalScalar: c,
        DenseMatrix: m,
      } = e,
      f = Ya({ DenseMatrix: m });
    return r(zc, {
      "SparseMatrix, Array | Matrix": function (l, p) {
        return s(l, p);
      },
      "DenseMatrix, Array | Matrix": function (l, p) {
        return u(l, p);
      },
      "Array, Array | Matrix": function (l, p) {
        var v = t(l),
          h = u(v, p);
        return h.valueOf();
      },
    });
    function u(o, l) {
      l = f(o, l, !0);
      for (
        var p = l._data,
          v = o._size[0],
          h = o._size[1],
          x = [],
          b = o._data,
          N = h - 1;
        N >= 0;
        N--
      ) {
        var d = p[N][0] || 0,
          y = void 0;
        if (c(d, 0)) y = 0;
        else {
          var w = b[N][N];
          if (c(w, 0))
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          y = a(d, w);
          for (var g = N - 1; g >= 0; g--)
            p[g] = [i(p[g][0] || 0, n(y, b[g][N]))];
        }
        x[N] = [y];
      }
      return new m({ data: x, size: [v, 1] });
    }
    function s(o, l) {
      l = f(o, l, !0);
      for (
        var p = l._data,
          v = o._size[0],
          h = o._size[1],
          x = o._values,
          b = o._index,
          N = o._ptr,
          d = [],
          y = h - 1;
        y >= 0;
        y--
      ) {
        var w = p[y][0] || 0;
        if (c(w, 0)) d[y] = [0];
        else {
          for (
            var g = 0, S = [], A = [], E = N[y], M = N[y + 1], B = M - 1;
            B >= E;
            B--
          ) {
            var C = b[B];
            C === y ? (g = x[B]) : C < y && (S.push(x[B]), A.push(C));
          }
          if (c(g, 0))
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          for (var _ = a(w, g), z = 0, I = A.length; z < I; z++) {
            var T = A[z];
            p[T] = [i(p[T][0], n(_, S[z]))];
          }
          d[y] = [_];
        }
      }
      return new m({ data: d, size: [v, 1] });
    }
  }),
  Uc = "lsolveAll",
  V2 = [
    "typed",
    "matrix",
    "divideScalar",
    "multiplyScalar",
    "subtract",
    "equalScalar",
    "DenseMatrix",
  ],
  G2 = P(Uc, V2, (e) => {
    var {
        typed: r,
        matrix: t,
        divideScalar: a,
        multiplyScalar: n,
        subtract: i,
        equalScalar: c,
        DenseMatrix: m,
      } = e,
      f = Ya({ DenseMatrix: m });
    return r(Uc, {
      "SparseMatrix, Array | Matrix": function (l, p) {
        return s(l, p);
      },
      "DenseMatrix, Array | Matrix": function (l, p) {
        return u(l, p);
      },
      "Array, Array | Matrix": function (l, p) {
        var v = t(l),
          h = u(v, p);
        return h.map((x) => x.valueOf());
      },
    });
    function u(o, l) {
      for (
        var p = [f(o, l, !0)._data.map((A) => A[0])],
          v = o._data,
          h = o._size[0],
          x = o._size[1],
          b = 0;
        b < x;
        b++
      )
        for (var N = p.length, d = 0; d < N; d++) {
          var y = p[d];
          if (c(v[b][b], 0))
            if (c(y[b], 0)) {
              if (d === 0) {
                var g = [...y];
                g[b] = 1;
                for (var S = b + 1; S < x; S++) g[S] = i(g[S], v[S][b]);
                p.push(g);
              }
            } else {
              if (d === 0) return [];
              p.splice(d, 1), (d -= 1), (N -= 1);
            }
          else {
            y[b] = a(y[b], v[b][b]);
            for (var w = b + 1; w < x; w++) y[w] = i(y[w], n(y[b], v[w][b]));
          }
        }
      return p.map((A) => new m({ data: A.map((E) => [E]), size: [h, 1] }));
    }
    function s(o, l) {
      for (
        var p = [f(o, l, !0)._data.map((Q) => Q[0])],
          v = o._size[0],
          h = o._size[1],
          x = o._values,
          b = o._index,
          N = o._ptr,
          d = 0;
        d < h;
        d++
      )
        for (var y = p.length, w = 0; w < y; w++) {
          for (
            var g = p[w], S = [], A = [], E = N[d], M = N[d + 1], B = 0, C = E;
            C < M;
            C++
          ) {
            var _ = b[C];
            _ === d ? (B = x[C]) : _ > d && (S.push(x[C]), A.push(_));
          }
          if (c(B, 0))
            if (c(g[d], 0)) {
              if (w === 0) {
                var D = [...g];
                D[d] = 1;
                for (var Z = 0, O = A.length; Z < O; Z++) {
                  var H = A[Z];
                  D[H] = i(D[H], S[Z]);
                }
                p.push(D);
              }
            } else {
              if (w === 0) return [];
              p.splice(w, 1), (w -= 1), (y -= 1);
            }
          else {
            g[d] = a(g[d], B);
            for (var z = 0, I = A.length; z < I; z++) {
              var T = A[z];
              g[T] = i(g[T], n(g[d], S[z]));
            }
          }
        }
      return p.map((Q) => new m({ data: Q.map((te) => [te]), size: [v, 1] }));
    }
  }),
  Lc = "usolveAll",
  H2 = [
    "typed",
    "matrix",
    "divideScalar",
    "multiplyScalar",
    "subtract",
    "equalScalar",
    "DenseMatrix",
  ],
  Z2 = P(Lc, H2, (e) => {
    var {
        typed: r,
        matrix: t,
        divideScalar: a,
        multiplyScalar: n,
        subtract: i,
        equalScalar: c,
        DenseMatrix: m,
      } = e,
      f = Ya({ DenseMatrix: m });
    return r(Lc, {
      "SparseMatrix, Array | Matrix": function (l, p) {
        return s(l, p);
      },
      "DenseMatrix, Array | Matrix": function (l, p) {
        return u(l, p);
      },
      "Array, Array | Matrix": function (l, p) {
        var v = t(l),
          h = u(v, p);
        return h.map((x) => x.valueOf());
      },
    });
    function u(o, l) {
      for (
        var p = [f(o, l, !0)._data.map((A) => A[0])],
          v = o._data,
          h = o._size[0],
          x = o._size[1],
          b = x - 1;
        b >= 0;
        b--
      )
        for (var N = p.length, d = 0; d < N; d++) {
          var y = p[d];
          if (c(v[b][b], 0))
            if (c(y[b], 0)) {
              if (d === 0) {
                var g = [...y];
                g[b] = 1;
                for (var S = b - 1; S >= 0; S--) g[S] = i(g[S], v[S][b]);
                p.push(g);
              }
            } else {
              if (d === 0) return [];
              p.splice(d, 1), (d -= 1), (N -= 1);
            }
          else {
            y[b] = a(y[b], v[b][b]);
            for (var w = b - 1; w >= 0; w--) y[w] = i(y[w], n(y[b], v[w][b]));
          }
        }
      return p.map((A) => new m({ data: A.map((E) => [E]), size: [h, 1] }));
    }
    function s(o, l) {
      for (
        var p = [f(o, l, !0)._data.map((Q) => Q[0])],
          v = o._size[0],
          h = o._size[1],
          x = o._values,
          b = o._index,
          N = o._ptr,
          d = h - 1;
        d >= 0;
        d--
      )
        for (var y = p.length, w = 0; w < y; w++) {
          for (
            var g = p[w],
              S = [],
              A = [],
              E = N[d],
              M = N[d + 1],
              B = 0,
              C = M - 1;
            C >= E;
            C--
          ) {
            var _ = b[C];
            _ === d ? (B = x[C]) : _ < d && (S.push(x[C]), A.push(_));
          }
          if (c(B, 0))
            if (c(g[d], 0)) {
              if (w === 0) {
                var D = [...g];
                D[d] = 1;
                for (var Z = 0, O = A.length; Z < O; Z++) {
                  var H = A[Z];
                  D[H] = i(D[H], S[Z]);
                }
                p.push(D);
              }
            } else {
              if (w === 0) return [];
              p.splice(w, 1), (w -= 1), (y -= 1);
            }
          else {
            g[d] = a(g[d], B);
            for (var z = 0, I = A.length; z < I; z++) {
              var T = A[z];
              g[T] = i(g[T], n(g[d], S[z]));
            }
          }
        }
      return p.map((Q) => new m({ data: Q.map((te) => [te]), size: [v, 1] }));
    }
  }),
  J2 = "algorithm08",
  W2 = ["typed", "equalScalar"],
  Ks = P(J2, W2, (e) => {
    var { typed: r, equalScalar: t } = e;
    return function (n, i, c) {
      var m = n._values,
        f = n._index,
        u = n._ptr,
        s = n._size,
        o = n._datatype,
        l = i._values,
        p = i._index,
        v = i._ptr,
        h = i._size,
        x = i._datatype;
      if (s.length !== h.length) throw new Je(s.length, h.length);
      if (s[0] !== h[0] || s[1] !== h[1])
        throw new RangeError(
          "Dimension mismatch. Matrix A (" +
            s +
            ") must match Matrix B (" +
            h +
            ")"
        );
      if (!m || !l)
        throw new Error("Cannot perform operation on Pattern Sparse Matrices");
      var b = s[0],
        N = s[1],
        d,
        y = t,
        w = 0,
        g = c;
      typeof o == "string" &&
        o === x &&
        ((d = o),
        (y = r.find(t, [d, d])),
        (w = r.convert(0, d)),
        (g = r.find(c, [d, d])));
      for (
        var S = [], A = [], E = [], M = [], B = [], C, _, z, I, T = 0;
        T < N;
        T++
      ) {
        E[T] = A.length;
        var D = T + 1;
        for (_ = u[T], z = u[T + 1], C = _; C < z; C++)
          (I = f[C]), (B[I] = D), (M[I] = m[C]), A.push(I);
        for (_ = v[T], z = v[T + 1], C = _; C < z; C++)
          (I = p[C]), B[I] === D && (M[I] = g(M[I], l[C]));
        for (C = E[T]; C < A.length; ) {
          I = A[C];
          var Z = M[I];
          y(Z, w) ? A.splice(C, 1) : (S.push(Z), C++);
        }
      }
      return (
        (E[N] = A.length),
        n.createSparseMatrix({
          values: S,
          index: A,
          ptr: E,
          size: [b, N],
          datatype: d,
        })
      );
    };
  }),
  kc = "leftShift",
  X2 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"],
  Y2 = P(kc, X2, (e) => {
    var { typed: r, matrix: t, equalScalar: a, zeros: n, DenseMatrix: i } = e,
      c = bn({ typed: r }),
      m = Et({ typed: r, equalScalar: a }),
      f = Ks({ typed: r, equalScalar: a }),
      u = Dn({ typed: r, DenseMatrix: i }),
      s = Ur({ typed: r, equalScalar: a }),
      o = hr({ typed: r }),
      l = ar({ typed: r });
    return r(kc, {
      "number, number": Cv,
      "BigNumber, BigNumber": yN,
      "SparseMatrix, SparseMatrix": function (v, h) {
        return f(v, h, this, !1);
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return m(h, v, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        return c(v, h, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return o(v, h, this);
      },
      "Array, Array": function (v, h) {
        return this(t(v), t(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(t(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, t(h));
      },
      "SparseMatrix, number | BigNumber": function (v, h) {
        return a(h, 0) ? v.clone() : s(v, h, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (v, h) {
        return a(h, 0) ? v.clone() : l(v, h, this, !1);
      },
      "number | BigNumber, SparseMatrix": function (v, h) {
        return a(v, 0) ? n(h.size(), h.storage()) : u(h, v, this, !0);
      },
      "number | BigNumber, DenseMatrix": function (v, h) {
        return a(v, 0) ? n(h.size(), h.storage()) : l(h, v, this, !0);
      },
      "Array, number | BigNumber": function (v, h) {
        return this(t(v), h).valueOf();
      },
      "number | BigNumber, Array": function (v, h) {
        return this(v, t(h)).valueOf();
      },
    });
  }),
  Vc = "rightArithShift",
  Q2 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"],
  j2 = P(Vc, Q2, (e) => {
    var { typed: r, matrix: t, equalScalar: a, zeros: n, DenseMatrix: i } = e,
      c = bn({ typed: r }),
      m = Et({ typed: r, equalScalar: a }),
      f = Ks({ typed: r, equalScalar: a }),
      u = Dn({ typed: r, DenseMatrix: i }),
      s = Ur({ typed: r, equalScalar: a }),
      o = hr({ typed: r }),
      l = ar({ typed: r });
    return r(Vc, {
      "number, number": $v,
      "BigNumber, BigNumber": bN,
      "SparseMatrix, SparseMatrix": function (v, h) {
        return f(v, h, this, !1);
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return m(h, v, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        return c(v, h, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return o(v, h, this);
      },
      "Array, Array": function (v, h) {
        return this(t(v), t(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(t(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, t(h));
      },
      "SparseMatrix, number | BigNumber": function (v, h) {
        return a(h, 0) ? v.clone() : s(v, h, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (v, h) {
        return a(h, 0) ? v.clone() : l(v, h, this, !1);
      },
      "number | BigNumber, SparseMatrix": function (v, h) {
        return a(v, 0) ? n(h.size(), h.storage()) : u(h, v, this, !0);
      },
      "number | BigNumber, DenseMatrix": function (v, h) {
        return a(v, 0) ? n(h.size(), h.storage()) : l(h, v, this, !0);
      },
      "Array, number | BigNumber": function (v, h) {
        return this(t(v), h).valueOf();
      },
      "number | BigNumber, Array": function (v, h) {
        return this(v, t(h)).valueOf();
      },
    });
  }),
  Gc = "rightLogShift",
  K2 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"],
  eA = P(Gc, K2, (e) => {
    var { typed: r, matrix: t, equalScalar: a, zeros: n, DenseMatrix: i } = e,
      c = bn({ typed: r }),
      m = Et({ typed: r, equalScalar: a }),
      f = Ks({ typed: r, equalScalar: a }),
      u = Dn({ typed: r, DenseMatrix: i }),
      s = Ur({ typed: r, equalScalar: a }),
      o = hr({ typed: r }),
      l = ar({ typed: r });
    return r(Gc, {
      "number, number": Ov,
      "SparseMatrix, SparseMatrix": function (v, h) {
        return f(v, h, this, !1);
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return m(h, v, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        return c(v, h, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return o(v, h, this);
      },
      "Array, Array": function (v, h) {
        return this(t(v), t(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(t(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, t(h));
      },
      "SparseMatrix, number | BigNumber": function (v, h) {
        return a(h, 0) ? v.clone() : s(v, h, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (v, h) {
        return a(h, 0) ? v.clone() : l(v, h, this, !1);
      },
      "number | BigNumber, SparseMatrix": function (v, h) {
        return a(v, 0) ? n(h.size(), h.storage()) : u(h, v, this, !0);
      },
      "number | BigNumber, DenseMatrix": function (v, h) {
        return a(v, 0) ? n(h.size(), h.storage()) : l(h, v, this, !0);
      },
      "Array, number | BigNumber": function (v, h) {
        return this(t(v), h).valueOf();
      },
      "number | BigNumber, Array": function (v, h) {
        return this(v, t(h)).valueOf();
      },
    });
  }),
  Hc = "and",
  rA = ["typed", "matrix", "equalScalar", "zeros", "not"],
  tA = P(Hc, rA, (e) => {
    var { typed: r, matrix: t, equalScalar: a, zeros: n, not: i } = e,
      c = Et({ typed: r, equalScalar: a }),
      m = no({ typed: r, equalScalar: a }),
      f = Ur({ typed: r, equalScalar: a }),
      u = hr({ typed: r }),
      s = ar({ typed: r });
    return r(Hc, {
      "number, number": Iv,
      "Complex, Complex": function (l, p) {
        return (l.re !== 0 || l.im !== 0) && (p.re !== 0 || p.im !== 0);
      },
      "BigNumber, BigNumber": function (l, p) {
        return !l.isZero() && !p.isZero() && !l.isNaN() && !p.isNaN();
      },
      "Unit, Unit": function (l, p) {
        return this(l.value || 0, p.value || 0);
      },
      "SparseMatrix, SparseMatrix": function (l, p) {
        return m(l, p, this, !1);
      },
      "SparseMatrix, DenseMatrix": function (l, p) {
        return c(p, l, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (l, p) {
        return c(l, p, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (l, p) {
        return u(l, p, this);
      },
      "Array, Array": function (l, p) {
        return this(t(l), t(p)).valueOf();
      },
      "Array, Matrix": function (l, p) {
        return this(t(l), p);
      },
      "Matrix, Array": function (l, p) {
        return this(l, t(p));
      },
      "SparseMatrix, any": function (l, p) {
        return i(p) ? n(l.size(), l.storage()) : f(l, p, this, !1);
      },
      "DenseMatrix, any": function (l, p) {
        return i(p) ? n(l.size(), l.storage()) : s(l, p, this, !1);
      },
      "any, SparseMatrix": function (l, p) {
        return i(l) ? n(l.size(), l.storage()) : f(p, l, this, !0);
      },
      "any, DenseMatrix": function (l, p) {
        return i(l) ? n(l.size(), l.storage()) : s(p, l, this, !0);
      },
      "Array, any": function (l, p) {
        return this(t(l), p).valueOf();
      },
      "any, Array": function (l, p) {
        return this(l, t(p)).valueOf();
      },
    });
  }),
  Zc = "compare",
  nA = [
    "typed",
    "config",
    "matrix",
    "equalScalar",
    "BigNumber",
    "Fraction",
    "DenseMatrix",
  ],
  aA = P(Zc, nA, (e) => {
    var {
        typed: r,
        config: t,
        equalScalar: a,
        matrix: n,
        BigNumber: i,
        Fraction: c,
        DenseMatrix: m,
      } = e,
      f = Yr({ typed: r }),
      u = ao({ typed: r, equalScalar: a }),
      s = Ir({ typed: r, DenseMatrix: m }),
      o = hr({ typed: r }),
      l = ar({ typed: r });
    return r(Zc, {
      "boolean, boolean": function (v, h) {
        return v === h ? 0 : v > h ? 1 : -1;
      },
      "number, number": function (v, h) {
        return nt(v, h, t.epsilon) ? 0 : v > h ? 1 : -1;
      },
      "BigNumber, BigNumber": function (v, h) {
        return Pt(v, h, t.epsilon) ? new i(0) : new i(v.cmp(h));
      },
      "Fraction, Fraction": function (v, h) {
        return new c(v.compare(h));
      },
      "Complex, Complex": function () {
        throw new TypeError(
          "No ordering relation is defined for complex numbers"
        );
      },
      "Unit, Unit": function (v, h) {
        if (!v.equalBase(h))
          throw new Error("Cannot compare units with different base");
        return this(v.value, h.value);
      },
      "SparseMatrix, SparseMatrix": function (v, h) {
        return u(v, h, this);
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return f(h, v, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        return f(v, h, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return o(v, h, this);
      },
      "Array, Array": function (v, h) {
        return this(n(v), n(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(n(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, n(h));
      },
      "SparseMatrix, any": function (v, h) {
        return s(v, h, this, !1);
      },
      "DenseMatrix, any": function (v, h) {
        return l(v, h, this, !1);
      },
      "any, SparseMatrix": function (v, h) {
        return s(h, v, this, !0);
      },
      "any, DenseMatrix": function (v, h) {
        return l(h, v, this, !0);
      },
      "Array, any": function (v, h) {
        return l(n(v), h, this, !1).valueOf();
      },
      "any, Array": function (v, h) {
        return l(n(h), v, this, !0).valueOf();
      },
    });
  }),
  iA = function e(r, t) {
    var a =
        /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
      n = /(^[ ]*|[ ]*$)/g,
      i =
        /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
      c = /^0x[0-9a-f]+$/i,
      m = /^0/,
      f = function (d) {
        return (e.insensitive && ("" + d).toLowerCase()) || "" + d;
      },
      u = f(r).replace(n, "") || "",
      s = f(t).replace(n, "") || "",
      o = u
        .replace(a, "\0$1\0")
        .replace(/\0$/, "")
        .replace(/^\0/, "")
        .split("\0"),
      l = s
        .replace(a, "\0$1\0")
        .replace(/\0$/, "")
        .replace(/^\0/, "")
        .split("\0"),
      p =
        parseInt(u.match(c), 16) ||
        (o.length !== 1 && u.match(i) && Date.parse(u)),
      v =
        parseInt(s.match(c), 16) || (p && s.match(i) && Date.parse(s)) || null,
      h,
      x;
    if (v) {
      if (p < v) return -1;
      if (p > v) return 1;
    }
    for (var b = 0, N = Math.max(o.length, l.length); b < N; b++) {
      if (
        ((h = (!(o[b] || "").match(m) && parseFloat(o[b])) || o[b] || 0),
        (x = (!(l[b] || "").match(m) && parseFloat(l[b])) || l[b] || 0),
        isNaN(h) !== isNaN(x))
      )
        return isNaN(h) ? 1 : -1;
      if ((typeof h != typeof x && ((h += ""), (x += "")), h < x)) return -1;
      if (h > x) return 1;
    }
    return 0;
  };
const Qn = pa(iA);
var Jc = "compareNatural",
  oA = ["typed", "compare"],
  sA = P(Jc, oA, (e) => {
    var { typed: r, compare: t } = e,
      a = t.signatures["boolean,boolean"];
    return r(Jc, {
      "any, any": function (f, u) {
        var s = vr(f),
          o = vr(u),
          l;
        if (
          (s === "number" || s === "BigNumber" || s === "Fraction") &&
          (o === "number" || o === "BigNumber" || o === "Fraction")
        )
          return (
            (l = t(f, u)), l.toString() !== "0" ? (l > 0 ? 1 : -1) : Qn(s, o)
          );
        if (s === "Array" || s === "Matrix" || o === "Array" || o === "Matrix")
          return (l = n(this, f, u)), l !== 0 ? l : Qn(s, o);
        if (s !== o) return Qn(s, o);
        if (s === "Complex") return uA(f, u);
        if (s === "Unit")
          return f.equalBase(u)
            ? this(f.value, u.value)
            : i(this, f.formatUnits(), u.formatUnits());
        if (s === "boolean") return a(f, u);
        if (s === "string") return Qn(f, u);
        if (s === "Object") return c(this, f, u);
        if (s === "null" || s === "undefined") return 0;
        throw new TypeError('Unsupported type of value "' + s + '"');
      },
    });
    function n(m, f, u) {
      return An(f) && An(u)
        ? i(m, f.toJSON().values, u.toJSON().values)
        : An(f)
        ? n(m, f.toArray(), u)
        : An(u)
        ? n(m, f, u.toArray())
        : $i(f)
        ? n(m, f.toJSON().data, u)
        : $i(u)
        ? n(m, f, u.toJSON().data)
        : Array.isArray(f)
        ? Array.isArray(u)
          ? i(m, f, u)
          : n(m, f, [u])
        : n(m, [f], u);
    }
    function i(m, f, u) {
      for (var s = 0, o = Math.min(f.length, u.length); s < o; s++) {
        var l = m(f[s], u[s]);
        if (l !== 0) return l;
      }
      return f.length > u.length ? 1 : f.length < u.length ? -1 : 0;
    }
    function c(m, f, u) {
      var s = Object.keys(f),
        o = Object.keys(u);
      s.sort(Qn), o.sort(Qn);
      var l = i(m, s, o);
      if (l !== 0) return l;
      for (var p = 0; p < s.length; p++) {
        var v = m(f[s[p]], u[o[p]]);
        if (v !== 0) return v;
      }
      return 0;
    }
  });
function uA(e, r) {
  return e.re > r.re
    ? 1
    : e.re < r.re
    ? -1
    : e.im > r.im
    ? 1
    : e.im < r.im
    ? -1
    : 0;
}
var Wc = "compareText",
  lA = ["typed", "matrix"],
  cA = P(Wc, lA, (e) => {
    var { typed: r, matrix: t } = e,
      a = hr({ typed: r }),
      n = ar({ typed: r });
    return r(Wc, {
      "any, any": Jn,
      "DenseMatrix, DenseMatrix": function (c, m) {
        return a(c, m, Jn);
      },
      "Array, Array": function (c, m) {
        return this(t(c), t(m)).valueOf();
      },
      "Array, Matrix": function (c, m) {
        return this(t(c), m);
      },
      "Matrix, Array": function (c, m) {
        return this(c, t(m));
      },
      "DenseMatrix, any": function (c, m) {
        return n(c, m, Jn, !1);
      },
      "any, DenseMatrix": function (c, m) {
        return n(m, c, Jn, !0);
      },
      "Array, any": function (c, m) {
        return n(t(c), m, Jn, !1).valueOf();
      },
      "any, Array": function (c, m) {
        return n(t(m), c, Jn, !0).valueOf();
      },
    });
  }),
  zi = "equal",
  fA = ["typed", "matrix", "equalScalar", "DenseMatrix"],
  mA = P(zi, fA, (e) => {
    var { typed: r, matrix: t, equalScalar: a, DenseMatrix: n } = e,
      i = Yr({ typed: r }),
      c = qt({ typed: r, DenseMatrix: n }),
      m = Ir({ typed: r, DenseMatrix: n }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(zi, {
      "any, any": function (o, l) {
        return o === null
          ? l === null
          : l === null
          ? o === null
          : o === void 0
          ? l === void 0
          : l === void 0
          ? o === void 0
          : a(o, l);
      },
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, a);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, a, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, a, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, a);
      },
      "Array, Array": function (o, l) {
        return this(t(o), t(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(t(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, t(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, a, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, a, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, a, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, a, !0);
      },
      "Array, any": function (o, l) {
        return u(t(o), l, a, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(t(l), o, a, !0).valueOf();
      },
    });
  });
P(zi, ["typed", "equalScalar"], (e) => {
  var { typed: r, equalScalar: t } = e;
  return r(zi, {
    "any, any": function (n, i) {
      return n === null
        ? i === null
        : i === null
        ? n === null
        : n === void 0
        ? i === void 0
        : i === void 0
        ? n === void 0
        : t(n, i);
    },
  });
});
var Xc = "equalText",
  pA = ["typed", "compareText", "isZero"],
  vA = P(Xc, pA, (e) => {
    var { typed: r, compareText: t, isZero: a } = e;
    return r(Xc, {
      "any, any": function (i, c) {
        return a(t(i, c));
      },
    });
  }),
  Yc = "smaller",
  hA = ["typed", "config", "matrix", "DenseMatrix"],
  dA = P(Yc, hA, (e) => {
    var { typed: r, config: t, matrix: a, DenseMatrix: n } = e,
      i = Yr({ typed: r }),
      c = qt({ typed: r, DenseMatrix: n }),
      m = Ir({ typed: r, DenseMatrix: n }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(Yc, {
      "boolean, boolean": function (o, l) {
        return o < l;
      },
      "number, number": function (o, l) {
        return o < l && !nt(o, l, t.epsilon);
      },
      "BigNumber, BigNumber": function (o, l) {
        return o.lt(l) && !Pt(o, l, t.epsilon);
      },
      "Fraction, Fraction": function (o, l) {
        return o.compare(l) === -1;
      },
      "Complex, Complex": function (o, l) {
        throw new TypeError(
          "No ordering relation is defined for complex numbers"
        );
      },
      "Unit, Unit": function (o, l) {
        if (!o.equalBase(l))
          throw new Error("Cannot compare units with different base");
        return this(o.value, l.value);
      },
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, this);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, this);
      },
      "Array, Array": function (o, l) {
        return this(a(o), a(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(a(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, a(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, this, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, this, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, this, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, this, !0);
      },
      "Array, any": function (o, l) {
        return u(a(o), l, this, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(a(l), o, this, !0).valueOf();
      },
    });
  }),
  Qc = "smallerEq",
  gA = ["typed", "config", "matrix", "DenseMatrix"],
  yA = P(Qc, gA, (e) => {
    var { typed: r, config: t, matrix: a, DenseMatrix: n } = e,
      i = Yr({ typed: r }),
      c = qt({ typed: r, DenseMatrix: n }),
      m = Ir({ typed: r, DenseMatrix: n }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(Qc, {
      "boolean, boolean": function (o, l) {
        return o <= l;
      },
      "number, number": function (o, l) {
        return o <= l || nt(o, l, t.epsilon);
      },
      "BigNumber, BigNumber": function (o, l) {
        return o.lte(l) || Pt(o, l, t.epsilon);
      },
      "Fraction, Fraction": function (o, l) {
        return o.compare(l) !== 1;
      },
      "Complex, Complex": function () {
        throw new TypeError(
          "No ordering relation is defined for complex numbers"
        );
      },
      "Unit, Unit": function (o, l) {
        if (!o.equalBase(l))
          throw new Error("Cannot compare units with different base");
        return this(o.value, l.value);
      },
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, this);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, this);
      },
      "Array, Array": function (o, l) {
        return this(a(o), a(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(a(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, a(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, this, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, this, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, this, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, this, !0);
      },
      "Array, any": function (o, l) {
        return u(a(o), l, this, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(a(l), o, this, !0).valueOf();
      },
    });
  }),
  jc = "larger",
  bA = ["typed", "config", "matrix", "DenseMatrix"],
  xA = P(jc, bA, (e) => {
    var { typed: r, config: t, matrix: a, DenseMatrix: n } = e,
      i = Yr({ typed: r }),
      c = qt({ typed: r, DenseMatrix: n }),
      m = Ir({ typed: r, DenseMatrix: n }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(jc, {
      "boolean, boolean": function (o, l) {
        return o > l;
      },
      "number, number": function (o, l) {
        return o > l && !nt(o, l, t.epsilon);
      },
      "BigNumber, BigNumber": function (o, l) {
        return o.gt(l) && !Pt(o, l, t.epsilon);
      },
      "Fraction, Fraction": function (o, l) {
        return o.compare(l) === 1;
      },
      "Complex, Complex": function () {
        throw new TypeError(
          "No ordering relation is defined for complex numbers"
        );
      },
      "Unit, Unit": function (o, l) {
        if (!o.equalBase(l))
          throw new Error("Cannot compare units with different base");
        return this(o.value, l.value);
      },
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, this);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, this);
      },
      "Array, Array": function (o, l) {
        return this(a(o), a(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(a(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, a(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, this, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, this, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, this, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, this, !0);
      },
      "Array, any": function (o, l) {
        return u(a(o), l, this, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(a(l), o, this, !0).valueOf();
      },
    });
  }),
  Kc = "largerEq",
  wA = ["typed", "config", "matrix", "DenseMatrix"],
  NA = P(Kc, wA, (e) => {
    var { typed: r, config: t, matrix: a, DenseMatrix: n } = e,
      i = Yr({ typed: r }),
      c = qt({ typed: r, DenseMatrix: n }),
      m = Ir({ typed: r, DenseMatrix: n }),
      f = hr({ typed: r }),
      u = ar({ typed: r });
    return r(Kc, {
      "boolean, boolean": function (o, l) {
        return o >= l;
      },
      "number, number": function (o, l) {
        return o >= l || nt(o, l, t.epsilon);
      },
      "BigNumber, BigNumber": function (o, l) {
        return o.gte(l) || Pt(o, l, t.epsilon);
      },
      "Fraction, Fraction": function (o, l) {
        return o.compare(l) !== -1;
      },
      "Complex, Complex": function () {
        throw new TypeError(
          "No ordering relation is defined for complex numbers"
        );
      },
      "Unit, Unit": function (o, l) {
        if (!o.equalBase(l))
          throw new Error("Cannot compare units with different base");
        return this(o.value, l.value);
      },
      "SparseMatrix, SparseMatrix": function (o, l) {
        return c(o, l, this);
      },
      "SparseMatrix, DenseMatrix": function (o, l) {
        return i(l, o, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (o, l) {
        return i(o, l, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (o, l) {
        return f(o, l, this);
      },
      "Array, Array": function (o, l) {
        return this(a(o), a(l)).valueOf();
      },
      "Array, Matrix": function (o, l) {
        return this(a(o), l);
      },
      "Matrix, Array": function (o, l) {
        return this(o, a(l));
      },
      "SparseMatrix, any": function (o, l) {
        return m(o, l, this, !1);
      },
      "DenseMatrix, any": function (o, l) {
        return u(o, l, this, !1);
      },
      "any, SparseMatrix": function (o, l) {
        return m(l, o, this, !0);
      },
      "any, DenseMatrix": function (o, l) {
        return u(l, o, this, !0);
      },
      "Array, any": function (o, l) {
        return u(a(o), l, this, !1).valueOf();
      },
      "any, Array": function (o, l) {
        return u(a(l), o, this, !0).valueOf();
      },
    });
  }),
  ef = "deepEqual",
  MA = ["typed", "equal"],
  AA = P(ef, MA, (e) => {
    var { typed: r, equal: t } = e;
    return r(ef, {
      "any, any": function (i, c) {
        return a(i.valueOf(), c.valueOf());
      },
    });
    function a(n, i) {
      if (Array.isArray(n))
        if (Array.isArray(i)) {
          var c = n.length;
          if (c !== i.length) return !1;
          for (var m = 0; m < c; m++) if (!a(n[m], i[m])) return !1;
          return !0;
        } else return !1;
      else return Array.isArray(i) ? !1 : t(n, i);
    }
  }),
  Ns = "unequal",
  SA = ["typed", "config", "equalScalar", "matrix", "DenseMatrix"],
  EA = P(Ns, SA, (e) => {
    var { typed: r, config: t, equalScalar: a, matrix: n, DenseMatrix: i } = e,
      c = Yr({ typed: r }),
      m = qt({ typed: r, DenseMatrix: i }),
      f = Ir({ typed: r, DenseMatrix: i }),
      u = hr({ typed: r }),
      s = ar({ typed: r });
    return r("unequal", {
      "any, any": function (p, v) {
        return p === null
          ? v !== null
          : v === null
          ? p !== null
          : p === void 0
          ? v !== void 0
          : v === void 0
          ? p !== void 0
          : o(p, v);
      },
      "SparseMatrix, SparseMatrix": function (p, v) {
        return m(p, v, o);
      },
      "SparseMatrix, DenseMatrix": function (p, v) {
        return c(v, p, o, !0);
      },
      "DenseMatrix, SparseMatrix": function (p, v) {
        return c(p, v, o, !1);
      },
      "DenseMatrix, DenseMatrix": function (p, v) {
        return u(p, v, o);
      },
      "Array, Array": function (p, v) {
        return this(n(p), n(v)).valueOf();
      },
      "Array, Matrix": function (p, v) {
        return this(n(p), v);
      },
      "Matrix, Array": function (p, v) {
        return this(p, n(v));
      },
      "SparseMatrix, any": function (p, v) {
        return f(p, v, o, !1);
      },
      "DenseMatrix, any": function (p, v) {
        return s(p, v, o, !1);
      },
      "any, SparseMatrix": function (p, v) {
        return f(v, p, o, !0);
      },
      "any, DenseMatrix": function (p, v) {
        return s(v, p, o, !0);
      },
      "Array, any": function (p, v) {
        return s(n(p), v, o, !1).valueOf();
      },
      "any, Array": function (p, v) {
        return s(n(v), p, o, !0).valueOf();
      },
    });
    function o(l, p) {
      return !a(l, p);
    }
  });
P(Ns, ["typed", "equalScalar"], (e) => {
  var { typed: r, equalScalar: t } = e;
  return r(Ns, {
    "any, any": function (n, i) {
      return n === null
        ? i !== null
        : i === null
        ? n !== null
        : n === void 0
        ? i !== void 0
        : i === void 0
        ? n !== void 0
        : !t(n, i);
    },
  });
});
var rf = "partitionSelect",
  CA = ["typed", "isNumeric", "isNaN", "compare"],
  $A = P(rf, CA, (e) => {
    var { typed: r, isNumeric: t, isNaN: a, compare: n } = e,
      i = n,
      c = (u, s) => -n(u, s);
    return r(rf, {
      "Array | Matrix, number": function (s, o) {
        return m(s, o, i);
      },
      "Array | Matrix, number, string": function (s, o, l) {
        if (l === "asc") return m(s, o, i);
        if (l === "desc") return m(s, o, c);
        throw new Error('Compare string must be "asc" or "desc"');
      },
      "Array | Matrix, number, function": m,
    });
    function m(u, s, o) {
      if (!Be(s) || s < 0) throw new Error("k must be a non-negative integer");
      if (ze(u)) {
        var l = u.size();
        if (l.length > 1)
          throw new Error("Only one dimensional matrices supported");
        return f(u.valueOf(), s, o);
      }
      if (Array.isArray(u)) return f(u, s, o);
    }
    function f(u, s, o) {
      if (s >= u.length) throw new Error("k out of bounds");
      for (var l = 0; l < u.length; l++) if (t(u[l]) && a(u[l])) return u[l];
      for (var p = 0, v = u.length - 1; p < v; ) {
        for (
          var h = p, x = v, b = u[Math.floor(Math.random() * (v - p + 1)) + p];
          h < x;

        )
          if (o(u[h], b) >= 0) {
            var N = u[x];
            (u[x] = u[h]), (u[h] = N), --x;
          } else ++h;
        o(u[h], b) > 0 && --h, s <= h ? (v = h) : (p = h + 1);
      }
      return u[s];
    }
  }),
  tf = "sort",
  OA = ["typed", "matrix", "compare", "compareNatural"],
  TA = P(tf, OA, (e) => {
    var { typed: r, matrix: t, compare: a, compareNatural: n } = e,
      i = a,
      c = (s, o) => -a(s, o);
    return r(tf, {
      Array: function (o) {
        return f(o), o.sort(i);
      },
      Matrix: function (o) {
        return u(o), t(o.toArray().sort(i), o.storage());
      },
      "Array, function": function (o, l) {
        return f(o), o.sort(l);
      },
      "Matrix, function": function (o, l) {
        return u(o), t(o.toArray().sort(l), o.storage());
      },
      "Array, string": function (o, l) {
        return f(o), o.sort(m(l));
      },
      "Matrix, string": function (o, l) {
        return u(o), t(o.toArray().sort(m(l)), o.storage());
      },
    });
    function m(s) {
      if (s === "asc") return i;
      if (s === "desc") return c;
      if (s === "natural") return n;
      throw new Error('String "asc", "desc", or "natural" expected');
    }
    function f(s) {
      if (Xe(s).length !== 1) throw new Error("One dimensional array expected");
    }
    function u(s) {
      if (s.size().length !== 1)
        throw new Error("One dimensional matrix expected");
    }
  }),
  nf = "max",
  DA = ["typed", "config", "numeric", "larger"],
  vh = P(nf, DA, (e) => {
    var { typed: r, config: t, numeric: a, larger: n } = e;
    return r(nf, {
      "Array | Matrix": c,
      "Array | Matrix, number | BigNumber": function (f, u) {
        return ro(f, u.valueOf(), i);
      },
      "...": function (f) {
        if (ya(f))
          throw new TypeError("Scalar values expected in function max");
        return c(f);
      },
    });
    function i(m, f) {
      try {
        return n(m, f) ? m : f;
      } catch (u) {
        throw Xr(u, "max", f);
      }
    }
    function c(m) {
      var f;
      if (
        (Qt(m, function (u) {
          try {
            isNaN(u) && typeof u == "number"
              ? (f = NaN)
              : (f === void 0 || n(u, f)) && (f = u);
          } catch (s) {
            throw Xr(s, "max", u);
          }
        }),
        f === void 0)
      )
        throw new Error("Cannot calculate max of an empty array");
      return typeof f == "string" && (f = a(f, t.number)), f;
    }
  }),
  af = "min",
  BA = ["typed", "config", "numeric", "smaller"],
  hh = P(af, BA, (e) => {
    var { typed: r, config: t, numeric: a, smaller: n } = e;
    return r(af, {
      "Array | Matrix": c,
      "Array | Matrix, number | BigNumber": function (f, u) {
        return ro(f, u.valueOf(), i);
      },
      "...": function (f) {
        if (ya(f))
          throw new TypeError("Scalar values expected in function min");
        return c(f);
      },
    });
    function i(m, f) {
      try {
        return n(m, f) ? m : f;
      } catch (u) {
        throw Xr(u, "min", f);
      }
    }
    function c(m) {
      var f;
      if (
        (Qt(m, function (u) {
          try {
            isNaN(u) && typeof u == "number"
              ? (f = NaN)
              : (f === void 0 || n(u, f)) && (f = u);
          } catch (s) {
            throw Xr(s, "min", u);
          }
        }),
        f === void 0)
      )
        throw new Error("Cannot calculate min of an empty array");
      return typeof f == "string" && (f = a(f, t.number)), f;
    }
  }),
  _A = "ImmutableDenseMatrix",
  IA = ["smaller", "DenseMatrix"],
  RA = P(
    _A,
    IA,
    (e) => {
      var { smaller: r, DenseMatrix: t } = e;
      function a(n, i) {
        if (!(this instanceof a))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (i && !et(i)) throw new Error("Invalid datatype: " + i);
        if (ze(n) || sr(n)) {
          var c = new t(n, i);
          (this._data = c._data),
            (this._size = c._size),
            (this._datatype = c._datatype),
            (this._min = null),
            (this._max = null);
        } else if (n && sr(n.data) && sr(n.size))
          (this._data = n.data),
            (this._size = n.size),
            (this._datatype = n.datatype),
            (this._min = typeof n.min < "u" ? n.min : null),
            (this._max = typeof n.max < "u" ? n.max : null);
        else {
          if (n)
            throw new TypeError("Unsupported type of data (" + vr(n) + ")");
          (this._data = []),
            (this._size = [0]),
            (this._datatype = i),
            (this._min = null),
            (this._max = null);
        }
      }
      return (
        (a.prototype = new t()),
        (a.prototype.type = "ImmutableDenseMatrix"),
        (a.prototype.isImmutableDenseMatrix = !0),
        (a.prototype.subset = function (n) {
          switch (arguments.length) {
            case 1: {
              var i = t.prototype.subset.call(this, n);
              return ze(i)
                ? new a({ data: i._data, size: i._size, datatype: i._datatype })
                : i;
            }
            case 2:
            case 3:
              throw new Error(
                "Cannot invoke set subset on an Immutable Matrix instance"
              );
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        }),
        (a.prototype.set = function () {
          throw new Error("Cannot invoke set on an Immutable Matrix instance");
        }),
        (a.prototype.resize = function () {
          throw new Error(
            "Cannot invoke resize on an Immutable Matrix instance"
          );
        }),
        (a.prototype.reshape = function () {
          throw new Error(
            "Cannot invoke reshape on an Immutable Matrix instance"
          );
        }),
        (a.prototype.clone = function () {
          return new a({
            data: Fe(this._data),
            size: Fe(this._size),
            datatype: this._datatype,
          });
        }),
        (a.prototype.toJSON = function () {
          return {
            mathjs: "ImmutableDenseMatrix",
            data: this._data,
            size: this._size,
            datatype: this._datatype,
          };
        }),
        (a.fromJSON = function (n) {
          return new a(n);
        }),
        (a.prototype.swapRows = function () {
          throw new Error(
            "Cannot invoke swapRows on an Immutable Matrix instance"
          );
        }),
        (a.prototype.min = function () {
          if (this._min === null) {
            var n = null;
            this.forEach(function (i) {
              (n === null || r(i, n)) && (n = i);
            }),
              (this._min = n !== null ? n : void 0);
          }
          return this._min;
        }),
        (a.prototype.max = function () {
          if (this._max === null) {
            var n = null;
            this.forEach(function (i) {
              (n === null || r(n, i)) && (n = i);
            }),
              (this._max = n !== null ? n : void 0);
          }
          return this._max;
        }),
        a
      );
    },
    { isClass: !0 }
  ),
  FA = "Index",
  PA = ["ImmutableDenseMatrix"],
  qA = P(
    FA,
    PA,
    (e) => {
      var { ImmutableDenseMatrix: r } = e;
      function t(n) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        (this._dimensions = []), (this._isScalar = !0);
        for (var i = 0, c = arguments.length; i < c; i++) {
          var m = arguments[i];
          if (Zi(m)) this._dimensions.push(m), (this._isScalar = !1);
          else if (Array.isArray(m) || ze(m)) {
            var f = a(m.valueOf());
            this._dimensions.push(f);
            var u = f.size();
            (u.length !== 1 || u[0] !== 1) && (this._isScalar = !1);
          } else if (typeof m == "number") this._dimensions.push(a([m]));
          else if (typeof m == "string") this._dimensions.push(m);
          else
            throw new TypeError(
              "Dimension must be an Array, Matrix, number, string, or Range"
            );
        }
      }
      (t.prototype.type = "Index"), (t.prototype.isIndex = !0);
      function a(n) {
        for (var i = 0, c = n.length; i < c; i++)
          if (typeof n[i] != "number" || !Be(n[i]))
            throw new TypeError(
              "Index parameters must be positive integer numbers"
            );
        return new r(n);
      }
      return (
        (t.prototype.clone = function () {
          var n = new t();
          return (
            (n._dimensions = Fe(this._dimensions)),
            (n._isScalar = this._isScalar),
            n
          );
        }),
        (t.create = function (n) {
          var i = new t();
          return t.apply(i, n), i;
        }),
        (t.prototype.size = function () {
          for (var n = [], i = 0, c = this._dimensions.length; i < c; i++) {
            var m = this._dimensions[i];
            n[i] = typeof m == "string" ? 1 : m.size()[0];
          }
          return n;
        }),
        (t.prototype.max = function () {
          for (var n = [], i = 0, c = this._dimensions.length; i < c; i++) {
            var m = this._dimensions[i];
            n[i] = typeof m == "string" ? m : m.max();
          }
          return n;
        }),
        (t.prototype.min = function () {
          for (var n = [], i = 0, c = this._dimensions.length; i < c; i++) {
            var m = this._dimensions[i];
            n[i] = typeof m == "string" ? m : m.min();
          }
          return n;
        }),
        (t.prototype.forEach = function (n) {
          for (var i = 0, c = this._dimensions.length; i < c; i++)
            n(this._dimensions[i], i, this);
        }),
        (t.prototype.dimension = function (n) {
          return this._dimensions[n] || null;
        }),
        (t.prototype.isObjectProperty = function () {
          return (
            this._dimensions.length === 1 &&
            typeof this._dimensions[0] == "string"
          );
        }),
        (t.prototype.getObjectProperty = function () {
          return this.isObjectProperty() ? this._dimensions[0] : null;
        }),
        (t.prototype.isScalar = function () {
          return this._isScalar;
        }),
        (t.prototype.toArray = function () {
          for (var n = [], i = 0, c = this._dimensions.length; i < c; i++) {
            var m = this._dimensions[i];
            n.push(typeof m == "string" ? m : m.toArray());
          }
          return n;
        }),
        (t.prototype.valueOf = t.prototype.toArray),
        (t.prototype.toString = function () {
          for (var n = [], i = 0, c = this._dimensions.length; i < c; i++) {
            var m = this._dimensions[i];
            typeof m == "string"
              ? n.push(JSON.stringify(m))
              : n.push(m.toString());
          }
          return "[" + n.join(", ") + "]";
        }),
        (t.prototype.toJSON = function () {
          return { mathjs: "Index", dimensions: this._dimensions };
        }),
        (t.fromJSON = function (n) {
          return t.create(n.dimensions);
        }),
        t
      );
    },
    { isClass: !0 }
  ),
  zA = "FibonacciHeap",
  UA = ["smaller", "larger"],
  LA = P(
    zA,
    UA,
    (e) => {
      var { smaller: r, larger: t } = e,
        a = 1 / Math.log((1 + Math.sqrt(5)) / 2);
      function n() {
        if (!(this instanceof n))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        (this._minimum = null), (this._size = 0);
      }
      (n.prototype.type = "FibonacciHeap"),
        (n.prototype.isFibonacciHeap = !0),
        (n.prototype.insert = function (s, o) {
          var l = { key: s, value: o, degree: 0 };
          if (this._minimum) {
            var p = this._minimum;
            (l.left = p),
              (l.right = p.right),
              (p.right = l),
              (l.right.left = l),
              r(s, p.key) && (this._minimum = l);
          } else (l.left = l), (l.right = l), (this._minimum = l);
          return this._size++, l;
        }),
        (n.prototype.size = function () {
          return this._size;
        }),
        (n.prototype.clear = function () {
          (this._minimum = null), (this._size = 0);
        }),
        (n.prototype.isEmpty = function () {
          return this._size === 0;
        }),
        (n.prototype.extractMinimum = function () {
          var s = this._minimum;
          if (s === null) return s;
          for (var o = this._minimum, l = s.degree, p = s.child; l > 0; ) {
            var v = p.right;
            (p.left.right = p.right),
              (p.right.left = p.left),
              (p.left = o),
              (p.right = o.right),
              (o.right = p),
              (p.right.left = p),
              (p.parent = null),
              (p = v),
              l--;
          }
          return (
            (s.left.right = s.right),
            (s.right.left = s.left),
            s === s.right
              ? (o = null)
              : ((o = s.right), (o = u(o, this._size))),
            this._size--,
            (this._minimum = o),
            s
          );
        }),
        (n.prototype.remove = function (s) {
          (this._minimum = i(this._minimum, s, -1)), this.extractMinimum();
        });
      function i(s, o, l) {
        o.key = l;
        var p = o.parent;
        return (
          p && r(o.key, p.key) && (c(s, o, p), m(s, p)),
          r(o.key, s.key) && (s = o),
          s
        );
      }
      function c(s, o, l) {
        (o.left.right = o.right),
          (o.right.left = o.left),
          l.degree--,
          l.child === o && (l.child = o.right),
          l.degree === 0 && (l.child = null),
          (o.left = s),
          (o.right = s.right),
          (s.right = o),
          (o.right.left = o),
          (o.parent = null),
          (o.mark = !1);
      }
      function m(s, o) {
        var l = o.parent;
        l && (o.mark ? (c(s, o, l), m(l)) : (o.mark = !0));
      }
      var f = function (o, l) {
        (o.left.right = o.right),
          (o.right.left = o.left),
          (o.parent = l),
          l.child
            ? ((o.left = l.child),
              (o.right = l.child.right),
              (l.child.right = o),
              (o.right.left = o))
            : ((l.child = o), (o.right = o), (o.left = o)),
          l.degree++,
          (o.mark = !1);
      };
      function u(s, o) {
        var l = Math.floor(Math.log(o) * a) + 1,
          p = new Array(l),
          v = 0,
          h = s;
        if (h) for (v++, h = h.right; h !== s; ) v++, (h = h.right);
        for (var x; v > 0; ) {
          for (var b = h.degree, N = h.right; (x = p[b]), !!x; ) {
            if (t(h.key, x.key)) {
              var d = x;
              (x = h), (h = d);
            }
            f(x, h), (p[b] = null), b++;
          }
          (p[b] = h), (h = N), v--;
        }
        s = null;
        for (var y = 0; y < l; y++)
          (x = p[y]),
            x &&
              (s
                ? ((x.left.right = x.right),
                  (x.right.left = x.left),
                  (x.left = s),
                  (x.right = s.right),
                  (s.right = x),
                  (x.right.left = x),
                  r(x.key, s.key) && (s = x))
                : (s = x));
        return s;
      }
      return n;
    },
    { isClass: !0 }
  ),
  kA = "Spa",
  VA = ["addScalar", "equalScalar", "FibonacciHeap"],
  GA = P(
    kA,
    VA,
    (e) => {
      var { addScalar: r, equalScalar: t, FibonacciHeap: a } = e;
      function n() {
        if (!(this instanceof n))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        (this._values = []), (this._heap = new a());
      }
      return (
        (n.prototype.type = "Spa"),
        (n.prototype.isSpa = !0),
        (n.prototype.set = function (i, c) {
          if (this._values[i]) this._values[i].value = c;
          else {
            var m = this._heap.insert(i, c);
            this._values[i] = m;
          }
        }),
        (n.prototype.get = function (i) {
          var c = this._values[i];
          return c ? c.value : 0;
        }),
        (n.prototype.accumulate = function (i, c) {
          var m = this._values[i];
          m
            ? (m.value = r(m.value, c))
            : ((m = this._heap.insert(i, c)), (this._values[i] = m));
        }),
        (n.prototype.forEach = function (i, c, m) {
          var f = this._heap,
            u = this._values,
            s = [],
            o = f.extractMinimum();
          for (o && s.push(o); o && o.key <= c; )
            o.key >= i && (t(o.value, 0) || m(o.key, o.value, this)),
              (o = f.extractMinimum()),
              o && s.push(o);
          for (var l = 0; l < s.length; l++) {
            var p = s[l];
            (o = f.insert(p.key, p.value)), (u[o.key] = o);
          }
        }),
        (n.prototype.swap = function (i, c) {
          var m = this._values[i],
            f = this._values[c];
          if (!m && f)
            (m = this._heap.insert(i, f.value)),
              this._heap.remove(f),
              (this._values[i] = m),
              (this._values[c] = void 0);
          else if (m && !f)
            (f = this._heap.insert(c, m.value)),
              this._heap.remove(m),
              (this._values[c] = f),
              (this._values[i] = void 0);
          else if (m && f) {
            var u = m.value;
            (m.value = f.value), (f.value = u);
          }
        }),
        n
      );
    },
    { isClass: !0 }
  );
function dh(e, r, t) {
  return (
    r in e
      ? Object.defineProperty(e, r, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[r] = t),
    e
  );
}
var HA = Xa(
    function (e) {
      return new e(1).exp();
    },
    { hasher: io }
  ),
  ZA = Xa(
    function (e) {
      return new e(1).plus(new e(5).sqrt()).div(2);
    },
    { hasher: io }
  ),
  eu = Xa(
    function (e) {
      return e.acos(-1);
    },
    { hasher: io }
  ),
  JA = Xa(
    function (e) {
      return eu(e).times(2);
    },
    { hasher: io }
  );
function io(e) {
  return e[0].precision;
}
function of(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    r &&
      (a = a.filter(function (n) {
        return Object.getOwnPropertyDescriptor(e, n).enumerable;
      })),
      t.push.apply(t, a);
  }
  return t;
}
function Lo(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2
      ? of(Object(t), !0).forEach(function (a) {
          dh(e, a, t[a]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
      : of(Object(t)).forEach(function (a) {
          Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(t, a));
        });
  }
  return e;
}
var WA = "Unit",
  XA = [
    "?on",
    "config",
    "addScalar",
    "subtract",
    "multiplyScalar",
    "divideScalar",
    "pow",
    "abs",
    "fix",
    "round",
    "equal",
    "isNumeric",
    "format",
    "number",
    "Complex",
    "BigNumber",
    "Fraction",
  ],
  YA = P(
    WA,
    XA,
    (e) => {
      var {
          on: r,
          config: t,
          addScalar: a,
          subtract: n,
          multiplyScalar: i,
          divideScalar: c,
          pow: m,
          abs: f,
          fix: u,
          round: s,
          equal: o,
          isNumeric: l,
          format: p,
          number: v,
          Complex: h,
          BigNumber: x,
          Fraction: b,
        } = e,
        N = v;
      function d(q, Y) {
        if (!(this instanceof d))
          throw new Error("Constructor must be called with the new operator");
        if (!(q == null || l(q) || Wt(q)))
          throw new TypeError(
            "First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined"
          );
        if (Y !== void 0 && (typeof Y != "string" || Y === ""))
          throw new TypeError(
            "Second parameter in Unit constructor must be a string"
          );
        if (Y !== void 0) {
          var V = d.parse(Y);
          (this.units = V.units), (this.dimensions = V.dimensions);
        } else {
          (this.units = [{ unit: te, prefix: D.NONE, power: 0 }]),
            (this.dimensions = []);
          for (var L = 0; L < Z.length; L++) this.dimensions[L] = 0;
        }
        (this.value = q != null ? this._normalize(q) : null),
          (this.fixPrefix = !1),
          (this.skipAutomaticSimplification = !0);
      }
      (d.prototype.type = "Unit"), (d.prototype.isUnit = !0);
      var y, w, g;
      function S() {
        for (; g === " " || g === "	"; ) M();
      }
      function A(q) {
        return (q >= "0" && q <= "9") || q === ".";
      }
      function E(q) {
        return q >= "0" && q <= "9";
      }
      function M() {
        w++, (g = y.charAt(w));
      }
      function B(q) {
        (w = q), (g = y.charAt(w));
      }
      function C() {
        var q = "",
          Y = w;
        if ((g === "+" ? M() : g === "-" && ((q += g), M()), !A(g)))
          return B(Y), null;
        if (g === ".") {
          if (((q += g), M(), !E(g))) return B(Y), null;
        } else {
          for (; E(g); ) (q += g), M();
          g === "." && ((q += g), M());
        }
        for (; E(g); ) (q += g), M();
        if (g === "E" || g === "e") {
          var V = "",
            L = w;
          if (
            ((V += g), M(), (g === "+" || g === "-") && ((V += g), M()), !E(g))
          )
            return B(L), q;
          for (q = q + V; E(g); ) (q += g), M();
        }
        return q;
      }
      function _() {
        for (var q = ""; E(g) || d.isValidAlpha(g); ) (q += g), M();
        var Y = q.charAt(0);
        return d.isValidAlpha(Y) ? q : null;
      }
      function z(q) {
        return g === q ? (M(), q) : null;
      }
      (d.parse = function (q, Y) {
        if (((Y = Y || {}), (y = q), (w = -1), (g = ""), typeof y != "string"))
          throw new TypeError(
            "Invalid argument in Unit.parse, string expected"
          );
        var V = new d();
        V.units = [];
        var L = 1,
          j = !1;
        M(), S();
        var F = C(),
          U = null;
        if (F) {
          if (t.number === "BigNumber") U = new x(F);
          else if (t.number === "Fraction")
            try {
              U = new b(F);
            } catch {
              U = parseFloat(F);
            }
          else U = parseFloat(F);
          S(), z("*") ? ((L = 1), (j = !0)) : z("/") && ((L = -1), (j = !0));
        }
        for (var ee = [], k = 1; ; ) {
          for (S(); g === "("; ) ee.push(L), (k *= L), (L = 1), M(), S();
          var me = void 0;
          if (g) {
            var he = g;
            if (((me = _()), me === null))
              throw new SyntaxError(
                'Unexpected "' +
                  he +
                  '" in "' +
                  y +
                  '" at index ' +
                  w.toString()
              );
          } else break;
          var Me = I(me);
          if (Me === null)
            throw new SyntaxError('Unit "' + me + '" not found.');
          var be = L * k;
          if ((S(), z("^"))) {
            S();
            var xe = C();
            if (xe === null)
              throw new SyntaxError(
                'In "' +
                  q +
                  '", "^" must be followed by a floating-point number'
              );
            be *= xe;
          }
          V.units.push({ unit: Me.unit, prefix: Me.prefix, power: be });
          for (var Te = 0; Te < Z.length; Te++)
            V.dimensions[Te] += (Me.unit.dimensions[Te] || 0) * be;
          for (S(); g === ")"; ) {
            if (ee.length === 0)
              throw new SyntaxError(
                'Unmatched ")" in "' + y + '" at index ' + w.toString()
              );
            (k /= ee.pop()), M(), S();
          }
          if (
            ((j = !1),
            z("*")
              ? ((L = 1), (j = !0))
              : z("/")
              ? ((L = -1), (j = !0))
              : (L = 1),
            Me.unit.base)
          ) {
            var or = Me.unit.base.key;
            ae.auto[or] = { unit: Me.unit, prefix: Me.prefix };
          }
        }
        if ((S(), g)) throw new SyntaxError('Could not parse: "' + q + '"');
        if (j) throw new SyntaxError('Trailing characters: "' + q + '"');
        if (ee.length !== 0)
          throw new SyntaxError('Unmatched "(" in "' + y + '"');
        if (V.units.length === 0 && !Y.allowNoUnits)
          throw new SyntaxError('"' + q + '" contains no units');
        return (V.value = U !== void 0 ? V._normalize(U) : null), V;
      }),
        (d.prototype.clone = function () {
          var q = new d();
          (q.fixPrefix = this.fixPrefix),
            (q.skipAutomaticSimplification = this.skipAutomaticSimplification),
            (q.value = Fe(this.value)),
            (q.dimensions = this.dimensions.slice(0)),
            (q.units = []);
          for (var Y = 0; Y < this.units.length; Y++) {
            q.units[Y] = {};
            for (var V in this.units[Y])
              De(this.units[Y], V) && (q.units[Y][V] = this.units[Y][V]);
          }
          return q;
        }),
        (d.prototype._isDerived = function () {
          return this.units.length === 0
            ? !1
            : this.units.length > 1 ||
                Math.abs(this.units[0].power - 1) > 1e-15;
        }),
        (d.prototype._normalize = function (q) {
          if (q == null || this.units.length === 0) return q;
          for (
            var Y = q, V = d._getNumberConverter(vr(q)), L = 0;
            L < this.units.length;
            L++
          ) {
            var j = V(this.units[L].unit.value),
              F = V(this.units[L].prefix.value),
              U = V(this.units[L].power);
            Y = i(Y, m(i(j, F), U));
          }
          return Y;
        }),
        (d.prototype._denormalize = function (q, Y) {
          if (q == null || this.units.length === 0) return q;
          for (
            var V = q, L = d._getNumberConverter(vr(q)), j = 0;
            j < this.units.length;
            j++
          ) {
            var F = L(this.units[j].unit.value),
              U = L(this.units[j].prefix.value),
              ee = L(this.units[j].power);
            V = c(V, m(i(F, U), ee));
          }
          return V;
        });
      var I = Xa(
        (q) => {
          if (De(J, q)) {
            var Y = J[q],
              V = Y.prefixes[""];
            return { unit: Y, prefix: V };
          }
          for (var L in J)
            if (De(J, L) && t1(q, L)) {
              var j = J[L],
                F = q.length - L.length,
                U = q.substring(0, F),
                ee = De(j.prefixes, U) ? j.prefixes[U] : void 0;
              if (ee !== void 0) return { unit: j, prefix: ee };
            }
          return null;
        },
        { hasher: (q) => q[0], limit: 100 }
      );
      (d.isValuelessUnit = function (q) {
        return I(q) !== null;
      }),
        (d.prototype.hasBase = function (q) {
          if ((typeof q == "string" && (q = O[q]), !q)) return !1;
          for (var Y = 0; Y < Z.length; Y++)
            if (
              Math.abs((this.dimensions[Y] || 0) - (q.dimensions[Y] || 0)) >
              1e-12
            )
              return !1;
          return !0;
        }),
        (d.prototype.equalBase = function (q) {
          for (var Y = 0; Y < Z.length; Y++)
            if (
              Math.abs((this.dimensions[Y] || 0) - (q.dimensions[Y] || 0)) >
              1e-12
            )
              return !1;
          return !0;
        }),
        (d.prototype.equals = function (q) {
          return this.equalBase(q) && o(this.value, q.value);
        }),
        (d.prototype.multiply = function (q) {
          for (var Y = this.clone(), V = 0; V < Z.length; V++)
            Y.dimensions[V] =
              (this.dimensions[V] || 0) + (q.dimensions[V] || 0);
          for (var L = 0; L < q.units.length; L++) {
            var j = Lo({}, q.units[L]);
            Y.units.push(j);
          }
          if (this.value !== null || q.value !== null) {
            var F = this.value === null ? this._normalize(1) : this.value,
              U = q.value === null ? q._normalize(1) : q.value;
            Y.value = i(F, U);
          } else Y.value = null;
          return (Y.skipAutomaticSimplification = !1), T(Y);
        }),
        (d.prototype.divide = function (q) {
          for (var Y = this.clone(), V = 0; V < Z.length; V++)
            Y.dimensions[V] =
              (this.dimensions[V] || 0) - (q.dimensions[V] || 0);
          for (var L = 0; L < q.units.length; L++) {
            var j = Lo(Lo({}, q.units[L]), {}, { power: -q.units[L].power });
            Y.units.push(j);
          }
          if (this.value !== null || q.value !== null) {
            var F = this.value === null ? this._normalize(1) : this.value,
              U = q.value === null ? q._normalize(1) : q.value;
            Y.value = c(F, U);
          } else Y.value = null;
          return (Y.skipAutomaticSimplification = !1), T(Y);
        }),
        (d.prototype.pow = function (q) {
          for (var Y = this.clone(), V = 0; V < Z.length; V++)
            Y.dimensions[V] = (this.dimensions[V] || 0) * q;
          for (var L = 0; L < Y.units.length; L++) Y.units[L].power *= q;
          return (
            Y.value !== null ? (Y.value = m(Y.value, q)) : (Y.value = null),
            (Y.skipAutomaticSimplification = !1),
            T(Y)
          );
        });
      function T(q) {
        return q.equalBase(O.NONE) && q.value !== null && !t.predictable
          ? q.value
          : q;
      }
      (d.prototype.abs = function () {
        var q = this.clone();
        if (q.value !== null)
          if (q._isDerived() || q.units[0].unit.offset === 0)
            q.value = f(q.value);
          else {
            var Y = d._getNumberConverter(vr(q.value)),
              V = Y(q.units[0].unit.value),
              L = Y(q.units[0].unit.offset),
              j = i(V, L);
            q.value = n(f(a(q.value, j)), j);
          }
        for (var F in q.units)
          (q.units[F].unit.name === "VA" || q.units[F].unit.name === "VAR") &&
            (q.units[F].unit = J.W);
        return q;
      }),
        (d.prototype.to = function (q) {
          var Y = this.value === null ? this._normalize(1) : this.value,
            V;
          if (typeof q == "string") V = d.parse(q);
          else if (Ha(q)) V = q.clone();
          else throw new Error("String or Unit expected as parameter");
          if (!this.equalBase(V))
            throw new Error(
              "Units do not match ('"
                .concat(V.toString(), "' != '")
                .concat(this.toString(), "')")
            );
          if (V.value !== null)
            throw new Error("Cannot convert to a unit with a value");
          if (
            this.value === null ||
            this._isDerived() ||
            this.units[0].unit.offset === V.units[0].unit.offset
          )
            V.value = Fe(Y);
          else {
            var L = d._getNumberConverter(vr(Y)),
              j = L(this.units[0].unit.value),
              F = L(this.units[0].unit.offset),
              U = i(j, F),
              ee = L(V.units[0].unit.value),
              k = L(V.units[0].unit.offset),
              me = i(ee, k);
            V.value = n(a(Y, U), me);
          }
          return (V.fixPrefix = !0), (V.skipAutomaticSimplification = !0), V;
        }),
        (d.prototype.toNumber = function (q) {
          return N(this.toNumeric(q));
        }),
        (d.prototype.toNumeric = function (q) {
          var Y;
          return (
            q ? (Y = this.to(q)) : (Y = this.clone()),
            Y._isDerived() || Y.units.length === 0
              ? Y._denormalize(Y.value)
              : Y._denormalize(Y.value, Y.units[0].prefix.value)
          );
        }),
        (d.prototype.toString = function () {
          return this.format();
        }),
        (d.prototype.toJSON = function () {
          return {
            mathjs: "Unit",
            value: this._denormalize(this.value),
            unit: this.formatUnits(),
            fixPrefix: this.fixPrefix,
          };
        }),
        (d.fromJSON = function (q) {
          var Y = new d(q.value, q.unit);
          return (Y.fixPrefix = q.fixPrefix || !1), Y;
        }),
        (d.prototype.valueOf = d.prototype.toString),
        (d.prototype.simplify = function () {
          var q = this.clone(),
            Y = [],
            V;
          for (var L in ce)
            if (De(ce, L) && q.hasBase(O[L])) {
              V = L;
              break;
            }
          if (V === "NONE") q.units = [];
          else {
            var j;
            if ((V && De(ce, V) && (j = ce[V]), j))
              q.units = [{ unit: j.unit, prefix: j.prefix, power: 1 }];
            else {
              for (var F = !1, U = 0; U < Z.length; U++) {
                var ee = Z[U];
                Math.abs(q.dimensions[U] || 0) > 1e-12 &&
                  (De(ce, ee)
                    ? Y.push({
                        unit: ce[ee].unit,
                        prefix: ce[ee].prefix,
                        power: q.dimensions[U] || 0,
                      })
                    : (F = !0));
              }
              Y.length < q.units.length && !F && (q.units = Y);
            }
          }
          return q;
        }),
        (d.prototype.toSI = function () {
          for (var q = this.clone(), Y = [], V = 0; V < Z.length; V++) {
            var L = Z[V];
            if (Math.abs(q.dimensions[V] || 0) > 1e-12)
              if (De(ae.si, L))
                Y.push({
                  unit: ae.si[L].unit,
                  prefix: ae.si[L].prefix,
                  power: q.dimensions[V] || 0,
                });
              else
                throw new Error(
                  "Cannot express custom unit " + L + " in SI units"
                );
          }
          return (
            (q.units = Y),
            (q.fixPrefix = !0),
            (q.skipAutomaticSimplification = !0),
            q
          );
        }),
        (d.prototype.formatUnits = function () {
          for (
            var q = "", Y = "", V = 0, L = 0, j = 0;
            j < this.units.length;
            j++
          )
            this.units[j].power > 0
              ? (V++,
                (q +=
                  " " + this.units[j].prefix.name + this.units[j].unit.name),
                Math.abs(this.units[j].power - 1) > 1e-15 &&
                  (q += "^" + this.units[j].power))
              : this.units[j].power < 0 && L++;
          if (L > 0)
            for (var F = 0; F < this.units.length; F++)
              this.units[F].power < 0 &&
                (V > 0
                  ? ((Y +=
                      " " +
                      this.units[F].prefix.name +
                      this.units[F].unit.name),
                    Math.abs(this.units[F].power + 1) > 1e-15 &&
                      (Y += "^" + -this.units[F].power))
                  : ((Y +=
                      " " +
                      this.units[F].prefix.name +
                      this.units[F].unit.name),
                    (Y += "^" + this.units[F].power)));
          (q = q.substr(1)),
            (Y = Y.substr(1)),
            V > 1 && L > 0 && (q = "(" + q + ")"),
            L > 1 && V > 0 && (Y = "(" + Y + ")");
          var U = q;
          return V > 0 && L > 0 && (U += " / "), (U += Y), U;
        }),
        (d.prototype.format = function (q) {
          var Y =
              this.skipAutomaticSimplification || this.value === null
                ? this.clone()
                : this.simplify(),
            V = !1;
          typeof Y.value < "u" &&
            Y.value !== null &&
            Wt(Y.value) &&
            (V = Math.abs(Y.value.re) < 1e-14);
          for (var L in Y.units)
            De(Y.units, L) &&
              Y.units[L].unit &&
              (Y.units[L].unit.name === "VA" && V
                ? (Y.units[L].unit = J.VAR)
                : Y.units[L].unit.name === "VAR" &&
                  !V &&
                  (Y.units[L].unit = J.VA));
          Y.units.length === 1 &&
            !Y.fixPrefix &&
            Math.abs(Y.units[0].power - Math.round(Y.units[0].power)) < 1e-14 &&
            (Y.units[0].prefix = Y._bestPrefix());
          var j = Y._denormalize(Y.value),
            F = Y.value !== null ? p(j, q || {}) : "",
            U = Y.formatUnits();
          return (
            Y.value && Wt(Y.value) && (F = "(" + F + ")"),
            U.length > 0 && F.length > 0 && (F += " "),
            (F += U),
            F
          );
        }),
        (d.prototype._bestPrefix = function () {
          if (this.units.length !== 1)
            throw new Error(
              "Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!"
            );
          if (
            Math.abs(this.units[0].power - Math.round(this.units[0].power)) >=
            1e-14
          )
            throw new Error(
              "Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!"
            );
          var q = this.value !== null ? f(this.value) : 0,
            Y = f(this.units[0].unit.value),
            V = this.units[0].prefix;
          if (q === 0) return V;
          var L = this.units[0].power,
            j = Math.log(q / Math.pow(V.value * Y, L)) / Math.LN10 - 1.2;
          if (j > -2.200001 && j < 1.800001) return V;
          j = Math.abs(j);
          var F = this.units[0].unit.prefixes;
          for (var U in F)
            if (De(F, U)) {
              var ee = F[U];
              if (ee.scientific) {
                var k = Math.abs(
                  Math.log(q / Math.pow(ee.value * Y, L)) / Math.LN10 - 1.2
                );
                (k < j || (k === j && ee.name.length < V.name.length)) &&
                  ((V = ee), (j = k));
              }
            }
          return V;
        }),
        (d.prototype.splitUnit = function (q) {
          for (
            var Y = this.clone(), V = [], L = 0;
            L < q.length && ((Y = Y.to(q[L])), L !== q.length - 1);
            L++
          ) {
            var j = Y.toNumeric(),
              F = s(j),
              U = void 0,
              ee = o(F, j);
            ee ? (U = F) : (U = u(Y.toNumeric()));
            var k = new d(U, q[L].toString());
            V.push(k), (Y = n(Y, k));
          }
          for (var me = 0, he = 0; he < V.length; he++) me = a(me, V[he].value);
          return o(me, this.value) && (Y.value = 0), V.push(Y), V;
        });
      var D = {
        NONE: { "": { name: "", value: 1, scientific: !0 } },
        SHORT: {
          "": { name: "", value: 1, scientific: !0 },
          da: { name: "da", value: 10, scientific: !1 },
          h: { name: "h", value: 100, scientific: !1 },
          k: { name: "k", value: 1e3, scientific: !0 },
          M: { name: "M", value: 1e6, scientific: !0 },
          G: { name: "G", value: 1e9, scientific: !0 },
          T: { name: "T", value: 1e12, scientific: !0 },
          P: { name: "P", value: 1e15, scientific: !0 },
          E: { name: "E", value: 1e18, scientific: !0 },
          Z: { name: "Z", value: 1e21, scientific: !0 },
          Y: { name: "Y", value: 1e24, scientific: !0 },
          d: { name: "d", value: 0.1, scientific: !1 },
          c: { name: "c", value: 0.01, scientific: !1 },
          m: { name: "m", value: 0.001, scientific: !0 },
          u: { name: "u", value: 1e-6, scientific: !0 },
          n: { name: "n", value: 1e-9, scientific: !0 },
          p: { name: "p", value: 1e-12, scientific: !0 },
          f: { name: "f", value: 1e-15, scientific: !0 },
          a: { name: "a", value: 1e-18, scientific: !0 },
          z: { name: "z", value: 1e-21, scientific: !0 },
          y: { name: "y", value: 1e-24, scientific: !0 },
        },
        LONG: {
          "": { name: "", value: 1, scientific: !0 },
          deca: { name: "deca", value: 10, scientific: !1 },
          hecto: { name: "hecto", value: 100, scientific: !1 },
          kilo: { name: "kilo", value: 1e3, scientific: !0 },
          mega: { name: "mega", value: 1e6, scientific: !0 },
          giga: { name: "giga", value: 1e9, scientific: !0 },
          tera: { name: "tera", value: 1e12, scientific: !0 },
          peta: { name: "peta", value: 1e15, scientific: !0 },
          exa: { name: "exa", value: 1e18, scientific: !0 },
          zetta: { name: "zetta", value: 1e21, scientific: !0 },
          yotta: { name: "yotta", value: 1e24, scientific: !0 },
          deci: { name: "deci", value: 0.1, scientific: !1 },
          centi: { name: "centi", value: 0.01, scientific: !1 },
          milli: { name: "milli", value: 0.001, scientific: !0 },
          micro: { name: "micro", value: 1e-6, scientific: !0 },
          nano: { name: "nano", value: 1e-9, scientific: !0 },
          pico: { name: "pico", value: 1e-12, scientific: !0 },
          femto: { name: "femto", value: 1e-15, scientific: !0 },
          atto: { name: "atto", value: 1e-18, scientific: !0 },
          zepto: { name: "zepto", value: 1e-21, scientific: !0 },
          yocto: { name: "yocto", value: 1e-24, scientific: !0 },
        },
        SQUARED: {
          "": { name: "", value: 1, scientific: !0 },
          da: { name: "da", value: 100, scientific: !1 },
          h: { name: "h", value: 1e4, scientific: !1 },
          k: { name: "k", value: 1e6, scientific: !0 },
          M: { name: "M", value: 1e12, scientific: !0 },
          G: { name: "G", value: 1e18, scientific: !0 },
          T: { name: "T", value: 1e24, scientific: !0 },
          P: { name: "P", value: 1e30, scientific: !0 },
          E: { name: "E", value: 1e36, scientific: !0 },
          Z: { name: "Z", value: 1e42, scientific: !0 },
          Y: { name: "Y", value: 1e48, scientific: !0 },
          d: { name: "d", value: 0.01, scientific: !1 },
          c: { name: "c", value: 1e-4, scientific: !1 },
          m: { name: "m", value: 1e-6, scientific: !0 },
          u: { name: "u", value: 1e-12, scientific: !0 },
          n: { name: "n", value: 1e-18, scientific: !0 },
          p: { name: "p", value: 1e-24, scientific: !0 },
          f: { name: "f", value: 1e-30, scientific: !0 },
          a: { name: "a", value: 1e-36, scientific: !0 },
          z: { name: "z", value: 1e-42, scientific: !0 },
          y: { name: "y", value: 1e-48, scientific: !0 },
        },
        CUBIC: {
          "": { name: "", value: 1, scientific: !0 },
          da: { name: "da", value: 1e3, scientific: !1 },
          h: { name: "h", value: 1e6, scientific: !1 },
          k: { name: "k", value: 1e9, scientific: !0 },
          M: { name: "M", value: 1e18, scientific: !0 },
          G: { name: "G", value: 1e27, scientific: !0 },
          T: { name: "T", value: 1e36, scientific: !0 },
          P: { name: "P", value: 1e45, scientific: !0 },
          E: { name: "E", value: 1e54, scientific: !0 },
          Z: { name: "Z", value: 1e63, scientific: !0 },
          Y: { name: "Y", value: 1e72, scientific: !0 },
          d: { name: "d", value: 0.001, scientific: !1 },
          c: { name: "c", value: 1e-6, scientific: !1 },
          m: { name: "m", value: 1e-9, scientific: !0 },
          u: { name: "u", value: 1e-18, scientific: !0 },
          n: { name: "n", value: 1e-27, scientific: !0 },
          p: { name: "p", value: 1e-36, scientific: !0 },
          f: { name: "f", value: 1e-45, scientific: !0 },
          a: { name: "a", value: 1e-54, scientific: !0 },
          z: { name: "z", value: 1e-63, scientific: !0 },
          y: { name: "y", value: 1e-72, scientific: !0 },
        },
        BINARY_SHORT_SI: {
          "": { name: "", value: 1, scientific: !0 },
          k: { name: "k", value: 1e3, scientific: !0 },
          M: { name: "M", value: 1e6, scientific: !0 },
          G: { name: "G", value: 1e9, scientific: !0 },
          T: { name: "T", value: 1e12, scientific: !0 },
          P: { name: "P", value: 1e15, scientific: !0 },
          E: { name: "E", value: 1e18, scientific: !0 },
          Z: { name: "Z", value: 1e21, scientific: !0 },
          Y: { name: "Y", value: 1e24, scientific: !0 },
        },
        BINARY_SHORT_IEC: {
          "": { name: "", value: 1, scientific: !0 },
          Ki: { name: "Ki", value: 1024, scientific: !0 },
          Mi: { name: "Mi", value: Math.pow(1024, 2), scientific: !0 },
          Gi: { name: "Gi", value: Math.pow(1024, 3), scientific: !0 },
          Ti: { name: "Ti", value: Math.pow(1024, 4), scientific: !0 },
          Pi: { name: "Pi", value: Math.pow(1024, 5), scientific: !0 },
          Ei: { name: "Ei", value: Math.pow(1024, 6), scientific: !0 },
          Zi: { name: "Zi", value: Math.pow(1024, 7), scientific: !0 },
          Yi: { name: "Yi", value: Math.pow(1024, 8), scientific: !0 },
        },
        BINARY_LONG_SI: {
          "": { name: "", value: 1, scientific: !0 },
          kilo: { name: "kilo", value: 1e3, scientific: !0 },
          mega: { name: "mega", value: 1e6, scientific: !0 },
          giga: { name: "giga", value: 1e9, scientific: !0 },
          tera: { name: "tera", value: 1e12, scientific: !0 },
          peta: { name: "peta", value: 1e15, scientific: !0 },
          exa: { name: "exa", value: 1e18, scientific: !0 },
          zetta: { name: "zetta", value: 1e21, scientific: !0 },
          yotta: { name: "yotta", value: 1e24, scientific: !0 },
        },
        BINARY_LONG_IEC: {
          "": { name: "", value: 1, scientific: !0 },
          kibi: { name: "kibi", value: 1024, scientific: !0 },
          mebi: { name: "mebi", value: Math.pow(1024, 2), scientific: !0 },
          gibi: { name: "gibi", value: Math.pow(1024, 3), scientific: !0 },
          tebi: { name: "tebi", value: Math.pow(1024, 4), scientific: !0 },
          pebi: { name: "pebi", value: Math.pow(1024, 5), scientific: !0 },
          exi: { name: "exi", value: Math.pow(1024, 6), scientific: !0 },
          zebi: { name: "zebi", value: Math.pow(1024, 7), scientific: !0 },
          yobi: { name: "yobi", value: Math.pow(1024, 8), scientific: !0 },
        },
        BTU: {
          "": { name: "", value: 1, scientific: !0 },
          MM: { name: "MM", value: 1e6, scientific: !0 },
        },
      };
      (D.SHORTLONG = Lr({}, D.SHORT, D.LONG)),
        (D.BINARY_SHORT = Lr({}, D.BINARY_SHORT_SI, D.BINARY_SHORT_IEC)),
        (D.BINARY_LONG = Lr({}, D.BINARY_LONG_SI, D.BINARY_LONG_IEC));
      var Z = [
          "MASS",
          "LENGTH",
          "TIME",
          "CURRENT",
          "TEMPERATURE",
          "LUMINOUS_INTENSITY",
          "AMOUNT_OF_SUBSTANCE",
          "ANGLE",
          "BIT",
        ],
        O = {
          NONE: { dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0] },
          MASS: { dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0] },
          LENGTH: { dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0] },
          TIME: { dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0] },
          CURRENT: { dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0] },
          TEMPERATURE: { dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0] },
          LUMINOUS_INTENSITY: { dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0] },
          AMOUNT_OF_SUBSTANCE: { dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0] },
          FORCE: { dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0] },
          SURFACE: { dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0] },
          VOLUME: { dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0] },
          ENERGY: { dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0] },
          POWER: { dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0] },
          PRESSURE: { dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0] },
          ELECTRIC_CHARGE: { dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0] },
          ELECTRIC_CAPACITANCE: { dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0] },
          ELECTRIC_POTENTIAL: { dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0] },
          ELECTRIC_RESISTANCE: { dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0] },
          ELECTRIC_INDUCTANCE: { dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0] },
          ELECTRIC_CONDUCTANCE: { dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0] },
          MAGNETIC_FLUX: { dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0] },
          MAGNETIC_FLUX_DENSITY: { dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0] },
          FREQUENCY: { dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0] },
          ANGLE: { dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0] },
          BIT: { dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1] },
        };
      for (var H in O) De(O, H) && (O[H].key = H);
      var Q = {},
        te = {
          name: "",
          base: Q,
          value: 1,
          offset: 0,
          dimensions: Z.map((q) => 0),
        },
        J = {
          meter: {
            name: "meter",
            base: O.LENGTH,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          inch: {
            name: "inch",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.0254,
            offset: 0,
          },
          foot: {
            name: "foot",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.3048,
            offset: 0,
          },
          yard: {
            name: "yard",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.9144,
            offset: 0,
          },
          mile: {
            name: "mile",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 1609.344,
            offset: 0,
          },
          link: {
            name: "link",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.201168,
            offset: 0,
          },
          rod: {
            name: "rod",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 5.0292,
            offset: 0,
          },
          chain: {
            name: "chain",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 20.1168,
            offset: 0,
          },
          angstrom: {
            name: "angstrom",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 1e-10,
            offset: 0,
          },
          m: {
            name: "m",
            base: O.LENGTH,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          in: {
            name: "in",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.0254,
            offset: 0,
          },
          ft: {
            name: "ft",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.3048,
            offset: 0,
          },
          yd: {
            name: "yd",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.9144,
            offset: 0,
          },
          mi: {
            name: "mi",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 1609.344,
            offset: 0,
          },
          li: {
            name: "li",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 0.201168,
            offset: 0,
          },
          rd: {
            name: "rd",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 5.02921,
            offset: 0,
          },
          ch: {
            name: "ch",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 20.1168,
            offset: 0,
          },
          mil: {
            name: "mil",
            base: O.LENGTH,
            prefixes: D.NONE,
            value: 254e-7,
            offset: 0,
          },
          m2: {
            name: "m2",
            base: O.SURFACE,
            prefixes: D.SQUARED,
            value: 1,
            offset: 0,
          },
          sqin: {
            name: "sqin",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 64516e-8,
            offset: 0,
          },
          sqft: {
            name: "sqft",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 0.09290304,
            offset: 0,
          },
          sqyd: {
            name: "sqyd",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 0.83612736,
            offset: 0,
          },
          sqmi: {
            name: "sqmi",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 2589988110336e-6,
            offset: 0,
          },
          sqrd: {
            name: "sqrd",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 25.29295,
            offset: 0,
          },
          sqch: {
            name: "sqch",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 404.6873,
            offset: 0,
          },
          sqmil: {
            name: "sqmil",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 64516e-14,
            offset: 0,
          },
          acre: {
            name: "acre",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 4046.86,
            offset: 0,
          },
          hectare: {
            name: "hectare",
            base: O.SURFACE,
            prefixes: D.NONE,
            value: 1e4,
            offset: 0,
          },
          m3: {
            name: "m3",
            base: O.VOLUME,
            prefixes: D.CUBIC,
            value: 1,
            offset: 0,
          },
          L: {
            name: "L",
            base: O.VOLUME,
            prefixes: D.SHORT,
            value: 0.001,
            offset: 0,
          },
          l: {
            name: "l",
            base: O.VOLUME,
            prefixes: D.SHORT,
            value: 0.001,
            offset: 0,
          },
          litre: {
            name: "litre",
            base: O.VOLUME,
            prefixes: D.LONG,
            value: 0.001,
            offset: 0,
          },
          cuin: {
            name: "cuin",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 16387064e-12,
            offset: 0,
          },
          cuft: {
            name: "cuft",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.028316846592,
            offset: 0,
          },
          cuyd: {
            name: "cuyd",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.764554857984,
            offset: 0,
          },
          teaspoon: {
            name: "teaspoon",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 5e-6,
            offset: 0,
          },
          tablespoon: {
            name: "tablespoon",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 15e-6,
            offset: 0,
          },
          drop: {
            name: "drop",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 5e-8,
            offset: 0,
          },
          gtt: {
            name: "gtt",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 5e-8,
            offset: 0,
          },
          minim: {
            name: "minim",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 6161152e-14,
            offset: 0,
          },
          fluiddram: {
            name: "fluiddram",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 36966911e-13,
            offset: 0,
          },
          fluidounce: {
            name: "fluidounce",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 2957353e-11,
            offset: 0,
          },
          gill: {
            name: "gill",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0001182941,
            offset: 0,
          },
          cc: {
            name: "cc",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 1e-6,
            offset: 0,
          },
          cup: {
            name: "cup",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0002365882,
            offset: 0,
          },
          pint: {
            name: "pint",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0004731765,
            offset: 0,
          },
          quart: {
            name: "quart",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0009463529,
            offset: 0,
          },
          gallon: {
            name: "gallon",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.003785412,
            offset: 0,
          },
          beerbarrel: {
            name: "beerbarrel",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.1173478,
            offset: 0,
          },
          oilbarrel: {
            name: "oilbarrel",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.1589873,
            offset: 0,
          },
          hogshead: {
            name: "hogshead",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.238481,
            offset: 0,
          },
          fldr: {
            name: "fldr",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 36966911e-13,
            offset: 0,
          },
          floz: {
            name: "floz",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 2957353e-11,
            offset: 0,
          },
          gi: {
            name: "gi",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0001182941,
            offset: 0,
          },
          cp: {
            name: "cp",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0002365882,
            offset: 0,
          },
          pt: {
            name: "pt",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0004731765,
            offset: 0,
          },
          qt: {
            name: "qt",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.0009463529,
            offset: 0,
          },
          gal: {
            name: "gal",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.003785412,
            offset: 0,
          },
          bbl: {
            name: "bbl",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.1173478,
            offset: 0,
          },
          obl: {
            name: "obl",
            base: O.VOLUME,
            prefixes: D.NONE,
            value: 0.1589873,
            offset: 0,
          },
          g: {
            name: "g",
            base: O.MASS,
            prefixes: D.SHORT,
            value: 0.001,
            offset: 0,
          },
          gram: {
            name: "gram",
            base: O.MASS,
            prefixes: D.LONG,
            value: 0.001,
            offset: 0,
          },
          ton: {
            name: "ton",
            base: O.MASS,
            prefixes: D.SHORT,
            value: 907.18474,
            offset: 0,
          },
          t: {
            name: "t",
            base: O.MASS,
            prefixes: D.SHORT,
            value: 1e3,
            offset: 0,
          },
          tonne: {
            name: "tonne",
            base: O.MASS,
            prefixes: D.LONG,
            value: 1e3,
            offset: 0,
          },
          grain: {
            name: "grain",
            base: O.MASS,
            prefixes: D.NONE,
            value: 6479891e-11,
            offset: 0,
          },
          dram: {
            name: "dram",
            base: O.MASS,
            prefixes: D.NONE,
            value: 0.0017718451953125,
            offset: 0,
          },
          ounce: {
            name: "ounce",
            base: O.MASS,
            prefixes: D.NONE,
            value: 0.028349523125,
            offset: 0,
          },
          poundmass: {
            name: "poundmass",
            base: O.MASS,
            prefixes: D.NONE,
            value: 0.45359237,
            offset: 0,
          },
          hundredweight: {
            name: "hundredweight",
            base: O.MASS,
            prefixes: D.NONE,
            value: 45.359237,
            offset: 0,
          },
          stick: {
            name: "stick",
            base: O.MASS,
            prefixes: D.NONE,
            value: 0.115,
            offset: 0,
          },
          stone: {
            name: "stone",
            base: O.MASS,
            prefixes: D.NONE,
            value: 6.35029318,
            offset: 0,
          },
          gr: {
            name: "gr",
            base: O.MASS,
            prefixes: D.NONE,
            value: 6479891e-11,
            offset: 0,
          },
          dr: {
            name: "dr",
            base: O.MASS,
            prefixes: D.NONE,
            value: 0.0017718451953125,
            offset: 0,
          },
          oz: {
            name: "oz",
            base: O.MASS,
            prefixes: D.NONE,
            value: 0.028349523125,
            offset: 0,
          },
          lbm: {
            name: "lbm",
            base: O.MASS,
            prefixes: D.NONE,
            value: 0.45359237,
            offset: 0,
          },
          cwt: {
            name: "cwt",
            base: O.MASS,
            prefixes: D.NONE,
            value: 45.359237,
            offset: 0,
          },
          s: {
            name: "s",
            base: O.TIME,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          min: {
            name: "min",
            base: O.TIME,
            prefixes: D.NONE,
            value: 60,
            offset: 0,
          },
          h: {
            name: "h",
            base: O.TIME,
            prefixes: D.NONE,
            value: 3600,
            offset: 0,
          },
          second: {
            name: "second",
            base: O.TIME,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          sec: {
            name: "sec",
            base: O.TIME,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          minute: {
            name: "minute",
            base: O.TIME,
            prefixes: D.NONE,
            value: 60,
            offset: 0,
          },
          hour: {
            name: "hour",
            base: O.TIME,
            prefixes: D.NONE,
            value: 3600,
            offset: 0,
          },
          day: {
            name: "day",
            base: O.TIME,
            prefixes: D.NONE,
            value: 86400,
            offset: 0,
          },
          week: {
            name: "week",
            base: O.TIME,
            prefixes: D.NONE,
            value: 7 * 86400,
            offset: 0,
          },
          month: {
            name: "month",
            base: O.TIME,
            prefixes: D.NONE,
            value: 2629800,
            offset: 0,
          },
          year: {
            name: "year",
            base: O.TIME,
            prefixes: D.NONE,
            value: 31557600,
            offset: 0,
          },
          decade: {
            name: "decade",
            base: O.TIME,
            prefixes: D.NONE,
            value: 315576e3,
            offset: 0,
          },
          century: {
            name: "century",
            base: O.TIME,
            prefixes: D.NONE,
            value: 315576e4,
            offset: 0,
          },
          millennium: {
            name: "millennium",
            base: O.TIME,
            prefixes: D.NONE,
            value: 315576e5,
            offset: 0,
          },
          hertz: {
            name: "Hertz",
            base: O.FREQUENCY,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
            reciprocal: !0,
          },
          Hz: {
            name: "Hz",
            base: O.FREQUENCY,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
            reciprocal: !0,
          },
          rad: {
            name: "rad",
            base: O.ANGLE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          radian: {
            name: "radian",
            base: O.ANGLE,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          deg: {
            name: "deg",
            base: O.ANGLE,
            prefixes: D.SHORT,
            value: null,
            offset: 0,
          },
          degree: {
            name: "degree",
            base: O.ANGLE,
            prefixes: D.LONG,
            value: null,
            offset: 0,
          },
          grad: {
            name: "grad",
            base: O.ANGLE,
            prefixes: D.SHORT,
            value: null,
            offset: 0,
          },
          gradian: {
            name: "gradian",
            base: O.ANGLE,
            prefixes: D.LONG,
            value: null,
            offset: 0,
          },
          cycle: {
            name: "cycle",
            base: O.ANGLE,
            prefixes: D.NONE,
            value: null,
            offset: 0,
          },
          arcsec: {
            name: "arcsec",
            base: O.ANGLE,
            prefixes: D.NONE,
            value: null,
            offset: 0,
          },
          arcmin: {
            name: "arcmin",
            base: O.ANGLE,
            prefixes: D.NONE,
            value: null,
            offset: 0,
          },
          A: {
            name: "A",
            base: O.CURRENT,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          ampere: {
            name: "ampere",
            base: O.CURRENT,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          K: {
            name: "K",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1,
            offset: 0,
          },
          degC: {
            name: "degC",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1,
            offset: 273.15,
          },
          degF: {
            name: "degF",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1 / 1.8,
            offset: 459.67,
          },
          degR: {
            name: "degR",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1 / 1.8,
            offset: 0,
          },
          kelvin: {
            name: "kelvin",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1,
            offset: 0,
          },
          celsius: {
            name: "celsius",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1,
            offset: 273.15,
          },
          fahrenheit: {
            name: "fahrenheit",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1 / 1.8,
            offset: 459.67,
          },
          rankine: {
            name: "rankine",
            base: O.TEMPERATURE,
            prefixes: D.NONE,
            value: 1 / 1.8,
            offset: 0,
          },
          mol: {
            name: "mol",
            base: O.AMOUNT_OF_SUBSTANCE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          mole: {
            name: "mole",
            base: O.AMOUNT_OF_SUBSTANCE,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          cd: {
            name: "cd",
            base: O.LUMINOUS_INTENSITY,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          candela: {
            name: "candela",
            base: O.LUMINOUS_INTENSITY,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          N: {
            name: "N",
            base: O.FORCE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          newton: {
            name: "newton",
            base: O.FORCE,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          dyn: {
            name: "dyn",
            base: O.FORCE,
            prefixes: D.SHORT,
            value: 1e-5,
            offset: 0,
          },
          dyne: {
            name: "dyne",
            base: O.FORCE,
            prefixes: D.LONG,
            value: 1e-5,
            offset: 0,
          },
          lbf: {
            name: "lbf",
            base: O.FORCE,
            prefixes: D.NONE,
            value: 4.4482216152605,
            offset: 0,
          },
          poundforce: {
            name: "poundforce",
            base: O.FORCE,
            prefixes: D.NONE,
            value: 4.4482216152605,
            offset: 0,
          },
          kip: {
            name: "kip",
            base: O.FORCE,
            prefixes: D.LONG,
            value: 4448.2216,
            offset: 0,
          },
          kilogramforce: {
            name: "kilogramforce",
            base: O.FORCE,
            prefixes: D.NONE,
            value: 9.80665,
            offset: 0,
          },
          J: {
            name: "J",
            base: O.ENERGY,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          joule: {
            name: "joule",
            base: O.ENERGY,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          erg: {
            name: "erg",
            base: O.ENERGY,
            prefixes: D.NONE,
            value: 1e-7,
            offset: 0,
          },
          Wh: {
            name: "Wh",
            base: O.ENERGY,
            prefixes: D.SHORT,
            value: 3600,
            offset: 0,
          },
          BTU: {
            name: "BTU",
            base: O.ENERGY,
            prefixes: D.BTU,
            value: 1055.05585262,
            offset: 0,
          },
          eV: {
            name: "eV",
            base: O.ENERGY,
            prefixes: D.SHORT,
            value: 1602176565e-28,
            offset: 0,
          },
          electronvolt: {
            name: "electronvolt",
            base: O.ENERGY,
            prefixes: D.LONG,
            value: 1602176565e-28,
            offset: 0,
          },
          W: {
            name: "W",
            base: O.POWER,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          watt: {
            name: "watt",
            base: O.POWER,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          hp: {
            name: "hp",
            base: O.POWER,
            prefixes: D.NONE,
            value: 745.6998715386,
            offset: 0,
          },
          VAR: {
            name: "VAR",
            base: O.POWER,
            prefixes: D.SHORT,
            value: h.I,
            offset: 0,
          },
          VA: {
            name: "VA",
            base: O.POWER,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          Pa: {
            name: "Pa",
            base: O.PRESSURE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          psi: {
            name: "psi",
            base: O.PRESSURE,
            prefixes: D.NONE,
            value: 6894.75729276459,
            offset: 0,
          },
          atm: {
            name: "atm",
            base: O.PRESSURE,
            prefixes: D.NONE,
            value: 101325,
            offset: 0,
          },
          bar: {
            name: "bar",
            base: O.PRESSURE,
            prefixes: D.SHORTLONG,
            value: 1e5,
            offset: 0,
          },
          torr: {
            name: "torr",
            base: O.PRESSURE,
            prefixes: D.NONE,
            value: 133.322,
            offset: 0,
          },
          mmHg: {
            name: "mmHg",
            base: O.PRESSURE,
            prefixes: D.NONE,
            value: 133.322,
            offset: 0,
          },
          mmH2O: {
            name: "mmH2O",
            base: O.PRESSURE,
            prefixes: D.NONE,
            value: 9.80665,
            offset: 0,
          },
          cmH2O: {
            name: "cmH2O",
            base: O.PRESSURE,
            prefixes: D.NONE,
            value: 98.0665,
            offset: 0,
          },
          coulomb: {
            name: "coulomb",
            base: O.ELECTRIC_CHARGE,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          C: {
            name: "C",
            base: O.ELECTRIC_CHARGE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          farad: {
            name: "farad",
            base: O.ELECTRIC_CAPACITANCE,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          F: {
            name: "F",
            base: O.ELECTRIC_CAPACITANCE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          volt: {
            name: "volt",
            base: O.ELECTRIC_POTENTIAL,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          V: {
            name: "V",
            base: O.ELECTRIC_POTENTIAL,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          ohm: {
            name: "ohm",
            base: O.ELECTRIC_RESISTANCE,
            prefixes: D.SHORTLONG,
            value: 1,
            offset: 0,
          },
          henry: {
            name: "henry",
            base: O.ELECTRIC_INDUCTANCE,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          H: {
            name: "H",
            base: O.ELECTRIC_INDUCTANCE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          siemens: {
            name: "siemens",
            base: O.ELECTRIC_CONDUCTANCE,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          S: {
            name: "S",
            base: O.ELECTRIC_CONDUCTANCE,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          weber: {
            name: "weber",
            base: O.MAGNETIC_FLUX,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          Wb: {
            name: "Wb",
            base: O.MAGNETIC_FLUX,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          tesla: {
            name: "tesla",
            base: O.MAGNETIC_FLUX_DENSITY,
            prefixes: D.LONG,
            value: 1,
            offset: 0,
          },
          T: {
            name: "T",
            base: O.MAGNETIC_FLUX_DENSITY,
            prefixes: D.SHORT,
            value: 1,
            offset: 0,
          },
          b: {
            name: "b",
            base: O.BIT,
            prefixes: D.BINARY_SHORT,
            value: 1,
            offset: 0,
          },
          bits: {
            name: "bits",
            base: O.BIT,
            prefixes: D.BINARY_LONG,
            value: 1,
            offset: 0,
          },
          B: {
            name: "B",
            base: O.BIT,
            prefixes: D.BINARY_SHORT,
            value: 8,
            offset: 0,
          },
          bytes: {
            name: "bytes",
            base: O.BIT,
            prefixes: D.BINARY_LONG,
            value: 8,
            offset: 0,
          },
        },
        re = {
          meters: "meter",
          inches: "inch",
          feet: "foot",
          yards: "yard",
          miles: "mile",
          links: "link",
          rods: "rod",
          chains: "chain",
          angstroms: "angstrom",
          lt: "l",
          litres: "litre",
          liter: "litre",
          liters: "litre",
          teaspoons: "teaspoon",
          tablespoons: "tablespoon",
          minims: "minim",
          fluiddrams: "fluiddram",
          fluidounces: "fluidounce",
          gills: "gill",
          cups: "cup",
          pints: "pint",
          quarts: "quart",
          gallons: "gallon",
          beerbarrels: "beerbarrel",
          oilbarrels: "oilbarrel",
          hogsheads: "hogshead",
          gtts: "gtt",
          grams: "gram",
          tons: "ton",
          tonnes: "tonne",
          grains: "grain",
          drams: "dram",
          ounces: "ounce",
          poundmasses: "poundmass",
          hundredweights: "hundredweight",
          sticks: "stick",
          lb: "lbm",
          lbs: "lbm",
          kips: "kip",
          kgf: "kilogramforce",
          acres: "acre",
          hectares: "hectare",
          sqfeet: "sqft",
          sqyard: "sqyd",
          sqmile: "sqmi",
          sqmiles: "sqmi",
          mmhg: "mmHg",
          mmh2o: "mmH2O",
          cmh2o: "cmH2O",
          seconds: "second",
          secs: "second",
          minutes: "minute",
          mins: "minute",
          hours: "hour",
          hr: "hour",
          hrs: "hour",
          days: "day",
          weeks: "week",
          months: "month",
          years: "year",
          decades: "decade",
          centuries: "century",
          millennia: "millennium",
          hertz: "hertz",
          radians: "radian",
          degrees: "degree",
          gradians: "gradian",
          cycles: "cycle",
          arcsecond: "arcsec",
          arcseconds: "arcsec",
          arcminute: "arcmin",
          arcminutes: "arcmin",
          BTUs: "BTU",
          watts: "watt",
          joules: "joule",
          amperes: "ampere",
          coulombs: "coulomb",
          volts: "volt",
          ohms: "ohm",
          farads: "farad",
          webers: "weber",
          teslas: "tesla",
          electronvolts: "electronvolt",
          moles: "mole",
          bit: "bits",
          byte: "bytes",
        };
      function oe(q) {
        if (q.number === "BigNumber") {
          var Y = eu(x);
          (J.rad.value = new x(1)),
            (J.deg.value = Y.div(180)),
            (J.grad.value = Y.div(200)),
            (J.cycle.value = Y.times(2)),
            (J.arcsec.value = Y.div(648e3)),
            (J.arcmin.value = Y.div(10800));
        } else
          (J.rad.value = 1),
            (J.deg.value = Math.PI / 180),
            (J.grad.value = Math.PI / 200),
            (J.cycle.value = Math.PI * 2),
            (J.arcsec.value = Math.PI / 648e3),
            (J.arcmin.value = Math.PI / 10800);
        (J.radian.value = J.rad.value),
          (J.degree.value = J.deg.value),
          (J.gradian.value = J.grad.value);
      }
      oe(t),
        r &&
          r("config", function (q, Y) {
            q.number !== Y.number && oe(q);
          });
      var ae = {
        si: {
          NONE: { unit: te, prefix: D.NONE[""] },
          LENGTH: { unit: J.m, prefix: D.SHORT[""] },
          MASS: { unit: J.g, prefix: D.SHORT.k },
          TIME: { unit: J.s, prefix: D.SHORT[""] },
          CURRENT: { unit: J.A, prefix: D.SHORT[""] },
          TEMPERATURE: { unit: J.K, prefix: D.SHORT[""] },
          LUMINOUS_INTENSITY: { unit: J.cd, prefix: D.SHORT[""] },
          AMOUNT_OF_SUBSTANCE: { unit: J.mol, prefix: D.SHORT[""] },
          ANGLE: { unit: J.rad, prefix: D.SHORT[""] },
          BIT: { unit: J.bits, prefix: D.SHORT[""] },
          FORCE: { unit: J.N, prefix: D.SHORT[""] },
          ENERGY: { unit: J.J, prefix: D.SHORT[""] },
          POWER: { unit: J.W, prefix: D.SHORT[""] },
          PRESSURE: { unit: J.Pa, prefix: D.SHORT[""] },
          ELECTRIC_CHARGE: { unit: J.C, prefix: D.SHORT[""] },
          ELECTRIC_CAPACITANCE: { unit: J.F, prefix: D.SHORT[""] },
          ELECTRIC_POTENTIAL: { unit: J.V, prefix: D.SHORT[""] },
          ELECTRIC_RESISTANCE: { unit: J.ohm, prefix: D.SHORT[""] },
          ELECTRIC_INDUCTANCE: { unit: J.H, prefix: D.SHORT[""] },
          ELECTRIC_CONDUCTANCE: { unit: J.S, prefix: D.SHORT[""] },
          MAGNETIC_FLUX: { unit: J.Wb, prefix: D.SHORT[""] },
          MAGNETIC_FLUX_DENSITY: { unit: J.T, prefix: D.SHORT[""] },
          FREQUENCY: { unit: J.Hz, prefix: D.SHORT[""] },
        },
      };
      (ae.cgs = JSON.parse(JSON.stringify(ae.si))),
        (ae.cgs.LENGTH = { unit: J.m, prefix: D.SHORT.c }),
        (ae.cgs.MASS = { unit: J.g, prefix: D.SHORT[""] }),
        (ae.cgs.FORCE = { unit: J.dyn, prefix: D.SHORT[""] }),
        (ae.cgs.ENERGY = { unit: J.erg, prefix: D.NONE[""] }),
        (ae.us = JSON.parse(JSON.stringify(ae.si))),
        (ae.us.LENGTH = { unit: J.ft, prefix: D.NONE[""] }),
        (ae.us.MASS = { unit: J.lbm, prefix: D.NONE[""] }),
        (ae.us.TEMPERATURE = { unit: J.degF, prefix: D.NONE[""] }),
        (ae.us.FORCE = { unit: J.lbf, prefix: D.NONE[""] }),
        (ae.us.ENERGY = { unit: J.BTU, prefix: D.BTU[""] }),
        (ae.us.POWER = { unit: J.hp, prefix: D.NONE[""] }),
        (ae.us.PRESSURE = { unit: J.psi, prefix: D.NONE[""] }),
        (ae.auto = JSON.parse(JSON.stringify(ae.si)));
      var ce = ae.auto;
      (d.setUnitSystem = function (q) {
        if (De(ae, q)) ce = ae[q];
        else
          throw new Error(
            "Unit system " +
              q +
              " does not exist. Choices are: " +
              Object.keys(ae).join(", ")
          );
      }),
        (d.getUnitSystem = function () {
          for (var q in ae) if (De(ae, q) && ae[q] === ce) return q;
        }),
        (d.typeConverters = {
          BigNumber: function (Y) {
            return new x(Y + "");
          },
          Fraction: function (Y) {
            return new b(Y);
          },
          Complex: function (Y) {
            return Y;
          },
          number: function (Y) {
            return Y;
          },
        }),
        (d._getNumberConverter = function (q) {
          if (!d.typeConverters[q])
            throw new TypeError('Unsupported type "' + q + '"');
          return d.typeConverters[q];
        });
      for (var se in J)
        if (De(J, se)) {
          var pe = J[se];
          pe.dimensions = pe.base.dimensions;
        }
      for (var ne in re)
        if (De(re, ne)) {
          var Ae = J[re[ne]],
            Ce = {};
          for (var ge in Ae) De(Ae, ge) && (Ce[ge] = Ae[ge]);
          (Ce.name = ne), (J[ne] = Ce);
        }
      d.isValidAlpha = function (Y) {
        return /^[a-zA-Z]$/.test(Y);
      };
      function Se(q) {
        for (var Y = 0; Y < q.length; Y++) {
          if (((g = q.charAt(Y)), Y === 0 && !d.isValidAlpha(g)))
            throw new Error(
              'Invalid unit name (must begin with alpha character): "' + q + '"'
            );
          if (Y > 0 && !(d.isValidAlpha(g) || E(g)))
            throw new Error(
              'Invalid unit name (only alphanumeric characters are allowed): "' +
                q +
                '"'
            );
        }
      }
      return (
        (d.createUnit = function (q, Y) {
          if (typeof q != "object")
            throw new TypeError(
              "createUnit expects first parameter to be of type 'Object'"
            );
          if (Y && Y.override) {
            for (var V in q)
              if ((De(q, V) && d.deleteUnit(V), q[V].aliases))
                for (var L = 0; L < q[V].aliases.length; L++)
                  d.deleteUnit(q[V].aliases[L]);
          }
          var j;
          for (var F in q) De(q, F) && (j = d.createUnitSingle(F, q[F]));
          return j;
        }),
        (d.createUnitSingle = function (q, Y, V) {
          if (
            ((typeof Y > "u" || Y === null) && (Y = {}), typeof q != "string")
          )
            throw new TypeError(
              "createUnitSingle expects first parameter to be of type 'string'"
            );
          if (De(J, q))
            throw new Error(
              'Cannot create unit "' +
                q +
                '": a unit with that name already exists'
            );
          Se(q);
          var L = null,
            j = [],
            F = 0,
            U,
            ee,
            k;
          if (Y && Y.type === "Unit") L = Y.clone();
          else if (typeof Y == "string") Y !== "" && (U = Y);
          else if (typeof Y == "object")
            (U = Y.definition),
              (ee = Y.prefixes),
              (F = Y.offset),
              (k = Y.baseName),
              Y.aliases && (j = Y.aliases.valueOf());
          else
            throw new TypeError(
              'Cannot create unit "' +
                q +
                '" from "' +
                Y.toString() +
                '": expecting "string" or "Unit" or "Object"'
            );
          if (j) {
            for (var me = 0; me < j.length; me++)
              if (De(J, j[me]))
                throw new Error(
                  'Cannot create alias "' +
                    j[me] +
                    '": a unit with that name already exists'
                );
          }
          if (U && typeof U == "string" && !L)
            try {
              L = d.parse(U, { allowNoUnits: !0 });
            } catch ($) {
              throw (
                (($.message =
                  'Could not create unit "' +
                  q +
                  '" from "' +
                  U +
                  '": ' +
                  $.message),
                $)
              );
            }
          else U && U.type === "Unit" && (L = U.clone());
          (j = j || []),
            (F = F || 0),
            ee && ee.toUpperCase
              ? (ee = D[ee.toUpperCase()] || D.NONE)
              : (ee = D.NONE);
          var he = {};
          if (L) {
            he = {
              name: q,
              value: L.value,
              dimensions: L.dimensions.slice(0),
              prefixes: ee,
              offset: F,
            };
            var Te = !1;
            for (var or in O)
              if (De(O, or)) {
                for (var br = !0, mr = 0; mr < Z.length; mr++)
                  if (
                    Math.abs(
                      (he.dimensions[mr] || 0) - (O[or].dimensions[mr] || 0)
                    ) > 1e-12
                  ) {
                    br = !1;
                    break;
                  }
                if (br) {
                  (Te = !0), (he.base = O[or]);
                  break;
                }
              }
            if (!Te) {
              k = k || q + "_STUFF";
              var Jr = { dimensions: L.dimensions.slice(0) };
              (Jr.key = k),
                (O[k] = Jr),
                (ce[k] = { unit: he, prefix: D.NONE[""] }),
                (he.base = O[k]);
            }
          } else {
            if (((k = k || q + "_STUFF"), Z.indexOf(k) >= 0))
              throw new Error(
                'Cannot create new base unit "' +
                  q +
                  '": a base unit with that name already exists (and cannot be overridden)'
              );
            Z.push(k);
            for (var Me in O) De(O, Me) && (O[Me].dimensions[Z.length - 1] = 0);
            for (var be = { dimensions: [] }, xe = 0; xe < Z.length; xe++)
              be.dimensions[xe] = 0;
            (be.dimensions[Z.length - 1] = 1),
              (be.key = k),
              (O[k] = be),
              (he = {
                name: q,
                value: 1,
                dimensions: O[k].dimensions.slice(0),
                prefixes: ee,
                offset: F,
                base: O[k],
              }),
              (ce[k] = { unit: he, prefix: D.NONE[""] });
          }
          d.UNITS[q] = he;
          for (var Wr = 0; Wr < j.length; Wr++) {
            var ot = j[Wr],
              rr = {};
            for (var $t in he) De(he, $t) && (rr[$t] = he[$t]);
            (rr.name = ot), (d.UNITS[ot] = rr);
          }
          return delete I.cache, new d(null, q);
        }),
        (d.deleteUnit = function (q) {
          delete d.UNITS[q];
        }),
        (d.PREFIXES = D),
        (d.BASE_DIMENSIONS = Z),
        (d.BASE_UNITS = O),
        (d.UNIT_SYSTEMS = ae),
        (d.UNITS = J),
        d
      );
    },
    { isClass: !0 }
  ),
  sf = "unit",
  QA = ["typed", "Unit"],
  jA = P(sf, QA, (e) => {
    var { typed: r, Unit: t } = e;
    return r(sf, {
      Unit: function (n) {
        return n.clone();
      },
      string: function (n) {
        return t.isValuelessUnit(n)
          ? new t(null, n)
          : t.parse(n, { allowNoUnits: !0 });
      },
      "number | BigNumber | Fraction | Complex, string": function (n, i) {
        return new t(n, i);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  uf = "sparse",
  KA = ["typed", "SparseMatrix"],
  eS = P(uf, KA, (e) => {
    var { typed: r, SparseMatrix: t } = e;
    return r(uf, {
      "": function () {
        return new t([]);
      },
      string: function (n) {
        return new t([], n);
      },
      "Array | Matrix": function (n) {
        return new t(n);
      },
      "Array | Matrix, string": function (n, i) {
        return new t(n, i);
      },
    });
  }),
  lf = "createUnit",
  rS = ["typed", "Unit"],
  tS = P(lf, rS, (e) => {
    var { typed: r, Unit: t } = e;
    return r(lf, {
      "Object, Object": function (n, i) {
        return t.createUnit(n, i);
      },
      Object: function (n) {
        return t.createUnit(n, {});
      },
      "string, Unit | string | Object, Object": function (n, i, c) {
        var m = {};
        return (m[n] = i), t.createUnit(m, c);
      },
      "string, Unit | string | Object": function (n, i) {
        var c = {};
        return (c[n] = i), t.createUnit(c, {});
      },
      string: function (n) {
        var i = {};
        return (i[n] = {}), t.createUnit(i, {});
      },
    });
  }),
  cf = "acos",
  nS = ["typed", "config", "Complex"],
  aS = P(cf, nS, (e) => {
    var { typed: r, config: t, Complex: a } = e;
    return r(cf, {
      number: function (i) {
        return (i >= -1 && i <= 1) || t.predictable
          ? Math.acos(i)
          : new a(i, 0).acos();
      },
      Complex: function (i) {
        return i.acos();
      },
      BigNumber: function (i) {
        return i.acos();
      },
      "Array | Matrix": function (i) {
        return Oe(i, this);
      },
    });
  }),
  ff = "acosh",
  iS = ["typed", "config", "Complex"],
  oS = P(ff, iS, (e) => {
    var { typed: r, config: t, Complex: a } = e;
    return r(ff, {
      number: function (i) {
        return i >= 1 || t.predictable
          ? Pv(i)
          : i <= -1
          ? new a(Math.log(Math.sqrt(i * i - 1) - i), Math.PI)
          : new a(i, 0).acosh();
      },
      Complex: function (i) {
        return i.acosh();
      },
      BigNumber: function (i) {
        return i.acosh();
      },
      "Array | Matrix": function (i) {
        return Oe(i, this);
      },
    });
  }),
  mf = "acot",
  sS = ["typed", "BigNumber"],
  uS = P(mf, sS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r(mf, {
      number: qv,
      Complex: function (n) {
        return n.acot();
      },
      BigNumber: function (n) {
        return new t(1).div(n).atan();
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  pf = "acoth",
  lS = ["typed", "config", "Complex", "BigNumber"],
  cS = P(pf, lS, (e) => {
    var { typed: r, config: t, Complex: a, BigNumber: n } = e;
    return r(pf, {
      number: function (c) {
        return c >= 1 || c <= -1 || t.predictable ? zv(c) : new a(c, 0).acoth();
      },
      Complex: function (c) {
        return c.acoth();
      },
      BigNumber: function (c) {
        return new n(1).div(c).atanh();
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
    });
  }),
  vf = "acsc",
  fS = ["typed", "config", "Complex", "BigNumber"],
  mS = P(vf, fS, (e) => {
    var { typed: r, config: t, Complex: a, BigNumber: n } = e;
    return r(vf, {
      number: function (c) {
        return c <= -1 || c >= 1 || t.predictable ? Uv(c) : new a(c, 0).acsc();
      },
      Complex: function (c) {
        return c.acsc();
      },
      BigNumber: function (c) {
        return new n(1).div(c).asin();
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
    });
  }),
  hf = "acsch",
  pS = ["typed", "BigNumber"],
  vS = P(hf, pS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r(hf, {
      number: Lv,
      Complex: function (n) {
        return n.acsch();
      },
      BigNumber: function (n) {
        return new t(1).div(n).asinh();
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  df = "asec",
  hS = ["typed", "config", "Complex", "BigNumber"],
  dS = P(df, hS, (e) => {
    var { typed: r, config: t, Complex: a, BigNumber: n } = e;
    return r(df, {
      number: function (c) {
        return c <= -1 || c >= 1 || t.predictable ? kv(c) : new a(c, 0).asec();
      },
      Complex: function (c) {
        return c.asec();
      },
      BigNumber: function (c) {
        return new n(1).div(c).acos();
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
    });
  }),
  gf = "asech",
  gS = ["typed", "config", "Complex", "BigNumber"],
  yS = P(gf, gS, (e) => {
    var { typed: r, config: t, Complex: a, BigNumber: n } = e;
    return r(gf, {
      number: function (c) {
        if ((c <= 1 && c >= -1) || t.predictable) {
          var m = 1 / c;
          if (m > 0 || t.predictable) return Vv(c);
          var f = Math.sqrt(m * m - 1);
          return new a(Math.log(f - m), Math.PI);
        }
        return new a(c, 0).asech();
      },
      Complex: function (c) {
        return c.asech();
      },
      BigNumber: function (c) {
        return new n(1).div(c).acosh();
      },
      "Array | Matrix": function (c) {
        return Oe(c, this);
      },
    });
  }),
  yf = "asin",
  bS = ["typed", "config", "Complex"],
  xS = P(yf, bS, (e) => {
    var { typed: r, config: t, Complex: a } = e;
    return r(yf, {
      number: function (i) {
        return (i >= -1 && i <= 1) || t.predictable
          ? Math.asin(i)
          : new a(i, 0).asin();
      },
      Complex: function (i) {
        return i.asin();
      },
      BigNumber: function (i) {
        return i.asin();
      },
      "Array | Matrix": function (i) {
        return Oe(i, this);
      },
    });
  }),
  wS = "asinh",
  NS = ["typed"],
  MS = P(wS, NS, (e) => {
    var { typed: r } = e;
    return r("asinh", {
      number: Gv,
      Complex: function (a) {
        return a.asinh();
      },
      BigNumber: function (a) {
        return a.asinh();
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  AS = "atan",
  SS = ["typed"],
  ES = P(AS, SS, (e) => {
    var { typed: r } = e;
    return r("atan", {
      number: function (a) {
        return Math.atan(a);
      },
      Complex: function (a) {
        return a.atan();
      },
      BigNumber: function (a) {
        return a.atan();
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  bf = "atan2",
  CS = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"],
  $S = P(bf, CS, (e) => {
    var {
        typed: r,
        matrix: t,
        equalScalar: a,
        BigNumber: n,
        DenseMatrix: i,
      } = e,
      c = Et({ typed: r, equalScalar: a }),
      m = Yr({ typed: r }),
      f = ah({ typed: r, equalScalar: a }),
      u = Ur({ typed: r, equalScalar: a }),
      s = Ir({ typed: r, DenseMatrix: i }),
      o = hr({ typed: r }),
      l = ar({ typed: r });
    return r(bf, {
      "number, number": Math.atan2,
      "BigNumber, BigNumber": function (v, h) {
        return n.atan2(v, h);
      },
      "SparseMatrix, SparseMatrix": function (v, h) {
        return f(v, h, this, !1);
      },
      "SparseMatrix, DenseMatrix": function (v, h) {
        return c(h, v, this, !0);
      },
      "DenseMatrix, SparseMatrix": function (v, h) {
        return m(v, h, this, !1);
      },
      "DenseMatrix, DenseMatrix": function (v, h) {
        return o(v, h, this);
      },
      "Array, Array": function (v, h) {
        return this(t(v), t(h)).valueOf();
      },
      "Array, Matrix": function (v, h) {
        return this(t(v), h);
      },
      "Matrix, Array": function (v, h) {
        return this(v, t(h));
      },
      "SparseMatrix, number | BigNumber": function (v, h) {
        return u(v, h, this, !1);
      },
      "DenseMatrix, number | BigNumber": function (v, h) {
        return l(v, h, this, !1);
      },
      "number | BigNumber, SparseMatrix": function (v, h) {
        return s(h, v, this, !0);
      },
      "number | BigNumber, DenseMatrix": function (v, h) {
        return l(h, v, this, !0);
      },
      "Array, number | BigNumber": function (v, h) {
        return l(t(v), h, this, !1).valueOf();
      },
      "number | BigNumber, Array": function (v, h) {
        return l(t(h), v, this, !0).valueOf();
      },
    });
  }),
  xf = "atanh",
  OS = ["typed", "config", "Complex"],
  TS = P(xf, OS, (e) => {
    var { typed: r, config: t, Complex: a } = e;
    return r(xf, {
      number: function (i) {
        return (i <= 1 && i >= -1) || t.predictable
          ? Hv(i)
          : new a(i, 0).atanh();
      },
      Complex: function (i) {
        return i.atanh();
      },
      BigNumber: function (i) {
        return i.atanh();
      },
      "Array | Matrix": function (i) {
        return Oe(i, this);
      },
    });
  }),
  wf = "cos",
  DS = ["typed"],
  BS = P(wf, DS, (e) => {
    var { typed: r } = e;
    return r(wf, {
      number: Math.cos,
      Complex: function (a) {
        return a.cos();
      },
      BigNumber: function (a) {
        return a.cos();
      },
      Unit: function (a) {
        if (!a.hasBase(a.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function cos is no angle");
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Nf = "cosh",
  _S = ["typed"],
  IS = P(Nf, _S, (e) => {
    var { typed: r } = e;
    return r(Nf, {
      number: X0,
      Complex: function (a) {
        return a.cosh();
      },
      BigNumber: function (a) {
        return a.cosh();
      },
      Unit: function (a) {
        if (!a.hasBase(a.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function cosh is no angle");
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Mf = "cot",
  RS = ["typed", "BigNumber"],
  FS = P(Mf, RS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r(Mf, {
      number: Zv,
      Complex: function (n) {
        return n.cot();
      },
      BigNumber: function (n) {
        return new t(1).div(n.tan());
      },
      Unit: function (n) {
        if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function cot is no angle");
        return this(n.value);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  Af = "coth",
  PS = ["typed", "BigNumber"],
  qS = P(Af, PS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r(Af, {
      number: Jv,
      Complex: function (n) {
        return n.coth();
      },
      BigNumber: function (n) {
        return new t(1).div(n.tanh());
      },
      Unit: function (n) {
        if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function coth is no angle");
        return this(n.value);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  Sf = "csc",
  zS = ["typed", "BigNumber"],
  US = P(Sf, zS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r(Sf, {
      number: Wv,
      Complex: function (n) {
        return n.csc();
      },
      BigNumber: function (n) {
        return new t(1).div(n.sin());
      },
      Unit: function (n) {
        if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function csc is no angle");
        return this(n.value);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  Ef = "csch",
  LS = ["typed", "BigNumber"],
  kS = P(Ef, LS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r(Ef, {
      number: Xv,
      Complex: function (n) {
        return n.csch();
      },
      BigNumber: function (n) {
        return new t(1).div(n.sinh());
      },
      Unit: function (n) {
        if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function csch is no angle");
        return this(n.value);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  Cf = "sec",
  VS = ["typed", "BigNumber"],
  GS = P(Cf, VS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r(Cf, {
      number: Yv,
      Complex: function (n) {
        return n.sec();
      },
      BigNumber: function (n) {
        return new t(1).div(n.cos());
      },
      Unit: function (n) {
        if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function sec is no angle");
        return this(n.value);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  $f = "sech",
  HS = ["typed", "BigNumber"],
  ZS = P($f, HS, (e) => {
    var { typed: r, BigNumber: t } = e;
    return r($f, {
      number: Qv,
      Complex: function (n) {
        return n.sech();
      },
      BigNumber: function (n) {
        return new t(1).div(n.cosh());
      },
      Unit: function (n) {
        if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function sech is no angle");
        return this(n.value);
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  Of = "sin",
  JS = ["typed"],
  WS = P(Of, JS, (e) => {
    var { typed: r } = e;
    return r(Of, {
      number: Math.sin,
      Complex: function (a) {
        return a.sin();
      },
      BigNumber: function (a) {
        return a.sin();
      },
      Unit: function (a) {
        if (!a.hasBase(a.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function sin is no angle");
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Tf = "sinh",
  XS = ["typed"],
  YS = P(Tf, XS, (e) => {
    var { typed: r } = e;
    return r(Tf, {
      number: jv,
      Complex: function (a) {
        return a.sinh();
      },
      BigNumber: function (a) {
        return a.sinh();
      },
      Unit: function (a) {
        if (!a.hasBase(a.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function sinh is no angle");
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Df = "tan",
  QS = ["typed"],
  jS = P(Df, QS, (e) => {
    var { typed: r } = e;
    return r(Df, {
      number: Math.tan,
      Complex: function (a) {
        return a.tan();
      },
      BigNumber: function (a) {
        return a.tan();
      },
      Unit: function (a) {
        if (!a.hasBase(a.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function tan is no angle");
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  KS = "tanh",
  eE = ["typed"],
  rE = P(KS, eE, (e) => {
    var { typed: r } = e;
    return r("tanh", {
      number: Q0,
      Complex: function (a) {
        return a.tanh();
      },
      BigNumber: function (a) {
        return a.tanh();
      },
      Unit: function (a) {
        if (!a.hasBase(a.constructor.BASE_UNITS.ANGLE))
          throw new TypeError("Unit in function tanh is no angle");
        return this(a.value);
      },
      "Array | Matrix": function (a) {
        return Oe(a, this);
      },
    });
  }),
  Bf = "setCartesian",
  tE = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"],
  nE = P(Bf, tE, (e) => {
    var {
      typed: r,
      size: t,
      subset: a,
      compareNatural: n,
      Index: i,
      DenseMatrix: c,
    } = e;
    return r(Bf, {
      "Array | Matrix, Array | Matrix": function (f, u) {
        var s = [];
        if (a(t(f), new i(0)) !== 0 && a(t(u), new i(0)) !== 0) {
          var o = Ke(Array.isArray(f) ? f : f.toArray()).sort(n),
            l = Ke(Array.isArray(u) ? u : u.toArray()).sort(n);
          s = [];
          for (var p = 0; p < o.length; p++)
            for (var v = 0; v < l.length; v++) s.push([o[p], l[v]]);
        }
        return Array.isArray(f) && Array.isArray(u) ? s : new c(s);
      },
    });
  }),
  _f = "setDifference",
  aE = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"],
  iE = P(_f, aE, (e) => {
    var {
      typed: r,
      size: t,
      subset: a,
      compareNatural: n,
      Index: i,
      DenseMatrix: c,
    } = e;
    return r(_f, {
      "Array | Matrix, Array | Matrix": function (f, u) {
        var s;
        if (a(t(f), new i(0)) === 0) s = [];
        else {
          if (a(t(u), new i(0)) === 0) return Ke(f.toArray());
          var o = sa(Ke(Array.isArray(f) ? f : f.toArray()).sort(n)),
            l = sa(Ke(Array.isArray(u) ? u : u.toArray()).sort(n));
          s = [];
          for (var p, v = 0; v < o.length; v++) {
            p = !1;
            for (var h = 0; h < l.length; h++)
              if (
                n(o[v].value, l[h].value) === 0 &&
                o[v].identifier === l[h].identifier
              ) {
                p = !0;
                break;
              }
            p || s.push(o[v]);
          }
        }
        return Array.isArray(f) && Array.isArray(u) ? Di(s) : new c(Di(s));
      },
    });
  }),
  If = "setDistinct",
  oE = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"],
  sE = P(If, oE, (e) => {
    var {
      typed: r,
      size: t,
      subset: a,
      compareNatural: n,
      Index: i,
      DenseMatrix: c,
    } = e;
    return r(If, {
      "Array | Matrix": function (f) {
        var u;
        if (a(t(f), new i(0)) === 0) u = [];
        else {
          var s = Ke(Array.isArray(f) ? f : f.toArray()).sort(n);
          (u = []), u.push(s[0]);
          for (var o = 1; o < s.length; o++)
            n(s[o], s[o - 1]) !== 0 && u.push(s[o]);
        }
        return Array.isArray(f) ? u : new c(u);
      },
    });
  }),
  Rf = "setIntersect",
  uE = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"],
  lE = P(Rf, uE, (e) => {
    var {
      typed: r,
      size: t,
      subset: a,
      compareNatural: n,
      Index: i,
      DenseMatrix: c,
    } = e;
    return r(Rf, {
      "Array | Matrix, Array | Matrix": function (f, u) {
        var s;
        if (a(t(f), new i(0)) === 0 || a(t(u), new i(0)) === 0) s = [];
        else {
          var o = sa(Ke(Array.isArray(f) ? f : f.toArray()).sort(n)),
            l = sa(Ke(Array.isArray(u) ? u : u.toArray()).sort(n));
          s = [];
          for (var p = 0; p < o.length; p++)
            for (var v = 0; v < l.length; v++)
              if (
                n(o[p].value, l[v].value) === 0 &&
                o[p].identifier === l[v].identifier
              ) {
                s.push(o[p]);
                break;
              }
        }
        return Array.isArray(f) && Array.isArray(u) ? Di(s) : new c(Di(s));
      },
    });
  }),
  Ff = "setIsSubset",
  cE = ["typed", "size", "subset", "compareNatural", "Index"],
  fE = P(Ff, cE, (e) => {
    var { typed: r, size: t, subset: a, compareNatural: n, Index: i } = e;
    return r(Ff, {
      "Array | Matrix, Array | Matrix": function (m, f) {
        if (a(t(m), new i(0)) === 0) return !0;
        if (a(t(f), new i(0)) === 0) return !1;
        for (
          var u = sa(Ke(Array.isArray(m) ? m : m.toArray()).sort(n)),
            s = sa(Ke(Array.isArray(f) ? f : f.toArray()).sort(n)),
            o,
            l = 0;
          l < u.length;
          l++
        ) {
          o = !1;
          for (var p = 0; p < s.length; p++)
            if (
              n(u[l].value, s[p].value) === 0 &&
              u[l].identifier === s[p].identifier
            ) {
              o = !0;
              break;
            }
          if (o === !1) return !1;
        }
        return !0;
      },
    });
  }),
  Pf = "setMultiplicity",
  mE = ["typed", "size", "subset", "compareNatural", "Index"],
  pE = P(Pf, mE, (e) => {
    var { typed: r, size: t, subset: a, compareNatural: n, Index: i } = e;
    return r(Pf, {
      "number | BigNumber | Fraction | Complex, Array | Matrix": function (
        m,
        f
      ) {
        if (a(t(f), new i(0)) === 0) return 0;
        for (
          var u = Ke(Array.isArray(f) ? f : f.toArray()), s = 0, o = 0;
          o < u.length;
          o++
        )
          n(u[o], m) === 0 && s++;
        return s;
      },
    });
  }),
  qf = "setPowerset",
  vE = ["typed", "size", "subset", "compareNatural", "Index"],
  hE = P(qf, vE, (e) => {
    var { typed: r, size: t, subset: a, compareNatural: n, Index: i } = e;
    return r(qf, {
      "Array | Matrix": function (u) {
        if (a(t(u), new i(0)) === 0) return [];
        for (
          var s = Ke(Array.isArray(u) ? u : u.toArray()).sort(n), o = [], l = 0;
          l.toString(2).length <= s.length;

        )
          o.push(c(s, l.toString(2).split("").reverse())), l++;
        return m(o);
      },
    });
    function c(f, u) {
      for (var s = [], o = 0; o < u.length; o++) u[o] === "1" && s.push(f[o]);
      return s;
    }
    function m(f) {
      for (var u = [], s = f.length - 1; s > 0; s--)
        for (var o = 0; o < s; o++)
          f[o].length > f[o + 1].length &&
            ((u = f[o]), (f[o] = f[o + 1]), (f[o + 1] = u));
      return f;
    }
  }),
  zf = "setSize",
  dE = ["typed", "compareNatural"],
  gE = P(zf, dE, (e) => {
    var { typed: r, compareNatural: t } = e;
    return r(zf, {
      "Array | Matrix": function (n) {
        return Array.isArray(n) ? Ke(n).length : Ke(n.toArray()).length;
      },
      "Array | Matrix, boolean": function (n, i) {
        if (i === !1 || n.length === 0)
          return Array.isArray(n) ? Ke(n).length : Ke(n.toArray()).length;
        for (
          var c = Ke(Array.isArray(n) ? n : n.toArray()).sort(t), m = 1, f = 1;
          f < c.length;
          f++
        )
          t(c[f], c[f - 1]) !== 0 && m++;
        return m;
      },
    });
  }),
  Uf = "setSymDifference",
  yE = ["typed", "size", "concat", "subset", "setDifference", "Index"],
  bE = P(Uf, yE, (e) => {
    var {
      typed: r,
      size: t,
      concat: a,
      subset: n,
      setDifference: i,
      Index: c,
    } = e;
    return r(Uf, {
      "Array | Matrix, Array | Matrix": function (f, u) {
        if (n(t(f), new c(0)) === 0) return Ke(u);
        if (n(t(u), new c(0)) === 0) return Ke(f);
        var s = Ke(f),
          o = Ke(u);
        return a(i(s, o), i(o, s));
      },
    });
  }),
  Lf = "setUnion",
  xE = [
    "typed",
    "size",
    "concat",
    "subset",
    "setIntersect",
    "setSymDifference",
    "Index",
  ],
  wE = P(Lf, xE, (e) => {
    var {
      typed: r,
      size: t,
      concat: a,
      subset: n,
      setIntersect: i,
      setSymDifference: c,
      Index: m,
    } = e;
    return r(Lf, {
      "Array | Matrix, Array | Matrix": function (u, s) {
        if (n(t(u), new m(0)) === 0) return Ke(s);
        if (n(t(s), new m(0)) === 0) return Ke(u);
        var o = Ke(u),
          l = Ke(s);
        return a(c(o, l), i(o, l));
      },
    });
  }),
  kf = "add",
  NE = [
    "typed",
    "matrix",
    "addScalar",
    "equalScalar",
    "DenseMatrix",
    "SparseMatrix",
  ],
  ME = P(kf, NE, (e) => {
    var {
        typed: r,
        matrix: t,
        addScalar: a,
        equalScalar: n,
        DenseMatrix: i,
        SparseMatrix: c,
      } = e,
      m = bn({ typed: r }),
      f = Ys({ typed: r, equalScalar: n }),
      u = Dn({ typed: r, DenseMatrix: i }),
      s = hr({ typed: r }),
      o = ar({ typed: r });
    return r(
      kf,
      Ls(
        {
          "DenseMatrix, DenseMatrix": function (p, v) {
            return s(p, v, a);
          },
          "DenseMatrix, SparseMatrix": function (p, v) {
            return m(p, v, a, !1);
          },
          "SparseMatrix, DenseMatrix": function (p, v) {
            return m(v, p, a, !0);
          },
          "SparseMatrix, SparseMatrix": function (p, v) {
            return f(p, v, a);
          },
          "Array, Array": function (p, v) {
            return this(t(p), t(v)).valueOf();
          },
          "Array, Matrix": function (p, v) {
            return this(t(p), v);
          },
          "Matrix, Array": function (p, v) {
            return this(p, t(v));
          },
          "DenseMatrix, any": function (p, v) {
            return o(p, v, a, !1);
          },
          "SparseMatrix, any": function (p, v) {
            return u(p, v, a, !1);
          },
          "any, DenseMatrix": function (p, v) {
            return o(v, p, a, !0);
          },
          "any, SparseMatrix": function (p, v) {
            return u(v, p, a, !0);
          },
          "Array, any": function (p, v) {
            return o(t(p), v, a, !1).valueOf();
          },
          "any, Array": function (p, v) {
            return o(t(v), p, a, !0).valueOf();
          },
          "any, any": a,
          "any, any, ...any": function (p, v, h) {
            for (var x = this(p, v), b = 0; b < h.length; b++)
              x = this(x, h[b]);
            return x;
          },
        },
        a.signatures
      )
    );
  }),
  Vf = "hypot",
  AE = [
    "typed",
    "abs",
    "addScalar",
    "divideScalar",
    "multiplyScalar",
    "sqrt",
    "smaller",
    "isPositive",
  ],
  SE = P(Vf, AE, (e) => {
    var {
      typed: r,
      abs: t,
      addScalar: a,
      divideScalar: n,
      multiplyScalar: i,
      sqrt: c,
      smaller: m,
      isPositive: f,
    } = e;
    return r(Vf, {
      "... number | BigNumber": u,
      Array: function (o) {
        return this.apply(this, Ke(o));
      },
      Matrix: function (o) {
        return this.apply(this, Ke(o.toArray()));
      },
    });
    function u(s) {
      for (var o = 0, l = 0, p = 0; p < s.length; p++) {
        var v = t(s[p]);
        m(l, v)
          ? ((o = i(o, i(n(l, v), n(l, v)))), (o = a(o, 1)), (l = v))
          : (o = a(o, f(v) ? i(n(v, l), n(v, l)) : v));
      }
      return i(l, c(o));
    }
  }),
  Gf = "norm",
  EE = [
    "typed",
    "abs",
    "add",
    "pow",
    "conj",
    "sqrt",
    "multiply",
    "equalScalar",
    "larger",
    "smaller",
    "matrix",
    "ctranspose",
    "eigs",
  ],
  CE = P(Gf, EE, (e) => {
    var {
      typed: r,
      abs: t,
      add: a,
      pow: n,
      conj: i,
      sqrt: c,
      multiply: m,
      equalScalar: f,
      larger: u,
      smaller: s,
      matrix: o,
      ctranspose: l,
      eigs: p,
    } = e;
    return r(Gf, {
      number: Math.abs,
      Complex: function (A) {
        return A.abs();
      },
      BigNumber: function (A) {
        return A.abs();
      },
      boolean: function (A) {
        return Math.abs(A);
      },
      Array: function (A) {
        return g(o(A), 2);
      },
      Matrix: function (A) {
        return g(A, 2);
      },
      "number | Complex | BigNumber | boolean, number | BigNumber | string":
        function (A) {
          return this(A);
        },
      "Array, number | BigNumber | string": function (A, E) {
        return g(o(A), E);
      },
      "Matrix, number | BigNumber | string": function (A, E) {
        return g(A, E);
      },
    });
    function v(S) {
      var A = 0;
      return (
        S.forEach(function (E) {
          var M = t(E);
          u(M, A) && (A = M);
        }, !0),
        A
      );
    }
    function h(S) {
      var A;
      return (
        S.forEach(function (E) {
          var M = t(E);
          (!A || s(M, A)) && (A = M);
        }, !0),
        A || 0
      );
    }
    function x(S, A) {
      if (A === Number.POSITIVE_INFINITY || A === "inf") return v(S);
      if (A === Number.NEGATIVE_INFINITY || A === "-inf") return h(S);
      if (A === "fro") return g(S, 2);
      if (typeof A == "number" && !isNaN(A)) {
        if (!f(A, 0)) {
          var E = 0;
          return (
            S.forEach(function (M) {
              E = a(n(t(M), A), E);
            }, !0),
            n(E, 1 / A)
          );
        }
        return Number.POSITIVE_INFINITY;
      }
      throw new Error("Unsupported parameter value");
    }
    function b(S) {
      var A = 0;
      return (
        S.forEach(function (E, M) {
          A = a(A, m(E, i(E)));
        }),
        t(c(A))
      );
    }
    function N(S) {
      var A = [],
        E = 0;
      return (
        S.forEach(function (M, B) {
          var C = B[1],
            _ = a(A[C] || 0, t(M));
          u(_, E) && (E = _), (A[C] = _);
        }, !0),
        E
      );
    }
    function d(S) {
      var A = S.size();
      if (A[0] !== A[1]) throw new RangeError("Invalid matrix dimensions");
      var E = l(S),
        M = m(E, S),
        B = p(M).values.toArray(),
        C = B[B.length - 1];
      return t(c(C));
    }
    function y(S) {
      var A = [],
        E = 0;
      return (
        S.forEach(function (M, B) {
          var C = B[0],
            _ = a(A[C] || 0, t(M));
          u(_, E) && (E = _), (A[C] = _);
        }, !0),
        E
      );
    }
    function w(S, A) {
      if (A === 1) return N(S);
      if (A === Number.POSITIVE_INFINITY || A === "inf") return y(S);
      if (A === "fro") return b(S);
      if (A === 2) return d(S);
      throw new Error("Unsupported parameter value " + A);
    }
    function g(S, A) {
      var E = S.size();
      if (E.length === 1) return x(S, A);
      if (E.length === 2) {
        if (E[0] && E[1]) return w(S, A);
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }),
  Hf = "dot",
  $E = ["typed", "addScalar", "multiplyScalar", "conj", "size"],
  OE = P(Hf, $E, (e) => {
    var { typed: r, addScalar: t, multiplyScalar: a, conj: n, size: i } = e;
    return r(Hf, {
      "Array | DenseMatrix, Array | DenseMatrix": m,
      "SparseMatrix, SparseMatrix": f,
    });
    function c(s, o) {
      var l = u(s),
        p = u(o),
        v,
        h;
      if (l.length === 1) v = l[0];
      else if (l.length === 2 && l[1] === 1) v = l[0];
      else
        throw new RangeError(
          "Expected a column vector, instead got a matrix of size (" +
            l.join(", ") +
            ")"
        );
      if (p.length === 1) h = p[0];
      else if (p.length === 2 && p[1] === 1) h = p[0];
      else
        throw new RangeError(
          "Expected a column vector, instead got a matrix of size (" +
            p.join(", ") +
            ")"
        );
      if (v !== h)
        throw new RangeError(
          "Vectors must have equal length (" + v + " != " + h + ")"
        );
      if (v === 0)
        throw new RangeError(
          "Cannot calculate the dot product of empty vectors"
        );
      return v;
    }
    function m(s, o) {
      var l = c(s, o),
        p = ze(s) ? s._data : s,
        v = ze(s) ? s._datatype : void 0,
        h = ze(o) ? o._data : o,
        x = ze(o) ? o._datatype : void 0,
        b = u(s).length === 2,
        N = u(o).length === 2,
        d = t,
        y = a;
      if (v && x && v === x && typeof v == "string") {
        var w = v;
        (d = r.find(t, [w, w])), (y = r.find(a, [w, w]));
      }
      if (!b && !N) {
        for (var g = y(n(p[0]), h[0]), S = 1; S < l; S++)
          g = d(g, y(n(p[S]), h[S]));
        return g;
      }
      if (!b && N) {
        for (var A = y(n(p[0]), h[0][0]), E = 1; E < l; E++)
          A = d(A, y(n(p[E]), h[E][0]));
        return A;
      }
      if (b && !N) {
        for (var M = y(n(p[0][0]), h[0]), B = 1; B < l; B++)
          M = d(M, y(n(p[B][0]), h[B]));
        return M;
      }
      if (b && N) {
        for (var C = y(n(p[0][0]), h[0][0]), _ = 1; _ < l; _++)
          C = d(C, y(n(p[_][0]), h[_][0]));
        return C;
      }
    }
    function f(s, o) {
      c(s, o);
      for (
        var l = s._index,
          p = s._values,
          v = o._index,
          h = o._values,
          x = 0,
          b = t,
          N = a,
          d = 0,
          y = 0;
        d < l.length && y < v.length;

      ) {
        var w = l[d],
          g = v[y];
        if (w < g) {
          d++;
          continue;
        }
        if (w > g) {
          y++;
          continue;
        }
        w === g && ((x = b(x, N(p[d], h[y]))), d++, y++);
      }
      return x;
    }
    function u(s) {
      return ze(s) ? s.size() : i(s);
    }
  }),
  TE = "trace",
  DE = ["typed", "matrix", "add"],
  BE = P(TE, DE, (e) => {
    var { typed: r, matrix: t, add: a } = e;
    return r("trace", {
      Array: function (m) {
        return n(t(m));
      },
      SparseMatrix: i,
      DenseMatrix: n,
      any: Fe,
    });
    function n(c) {
      var m = c._size,
        f = c._data;
      switch (m.length) {
        case 1:
          if (m[0] === 1) return Fe(f[0]);
          throw new RangeError("Matrix must be square (size: " + Ze(m) + ")");
        case 2: {
          var u = m[0],
            s = m[1];
          if (u === s) {
            for (var o = 0, l = 0; l < u; l++) o = a(o, f[l][l]);
            return o;
          } else
            throw new RangeError("Matrix must be square (size: " + Ze(m) + ")");
        }
        default:
          throw new RangeError(
            "Matrix must be two dimensional (size: " + Ze(m) + ")"
          );
      }
    }
    function i(c) {
      var m = c._values,
        f = c._index,
        u = c._ptr,
        s = c._size,
        o = s[0],
        l = s[1];
      if (o === l) {
        var p = 0;
        if (m.length > 0)
          for (var v = 0; v < l; v++)
            for (var h = u[v], x = u[v + 1], b = h; b < x; b++) {
              var N = f[b];
              if (N === v) {
                p = a(p, m[b]);
                break;
              }
              if (N > v) break;
            }
        return p;
      }
      throw new RangeError("Matrix must be square (size: " + Ze(s) + ")");
    }
  }),
  Zf = "index",
  _E = ["typed", "Index"],
  IE = P(Zf, _E, (e) => {
    var { typed: r, Index: t } = e;
    return r(Zf, {
      "...number | string | BigNumber | Range | Array | Matrix": function (n) {
        var i = n.map(function (m) {
            return Qe(m)
              ? m.toNumber()
              : Array.isArray(m) || ze(m)
              ? m.map(function (f) {
                  return Qe(f) ? f.toNumber() : f;
                })
              : m;
          }),
          c = new t();
        return t.apply(c, i), c;
      },
    });
  }),
  gh = new Set(["end"]),
  RE = "Node",
  FE = ["mathWithTransform"],
  PE = P(
    RE,
    FE,
    (e) => {
      var { mathWithTransform: r } = e;
      function t() {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
      }
      (t.prototype.evaluate = function (n) {
        return this.compile().evaluate(n);
      }),
        (t.prototype.type = "Node"),
        (t.prototype.isNode = !0),
        (t.prototype.comment = ""),
        (t.prototype.compile = function () {
          var n = this._compile(r, {}),
            i = {},
            c = null;
          function m(f) {
            var u = Zs(f);
            return a(u), n(u, i, c);
          }
          return { evaluate: m };
        }),
        (t.prototype._compile = function (n, i) {
          throw new Error(
            "Method _compile should be implemented by type " + this.type
          );
        }),
        (t.prototype.forEach = function (n) {
          throw new Error("Cannot run forEach on a Node interface");
        }),
        (t.prototype.map = function (n) {
          throw new Error("Cannot run map on a Node interface");
        }),
        (t.prototype._ifNode = function (n) {
          if (!ir(n))
            throw new TypeError("Callback function must return a Node");
          return n;
        }),
        (t.prototype.traverse = function (n) {
          n(this, null, null);
          function i(c, m) {
            c.forEach(function (f, u, s) {
              m(f, u, s), i(f, m);
            });
          }
          i(this, n);
        }),
        (t.prototype.transform = function (n) {
          function i(c, m, f) {
            var u = n(c, m, f);
            return u !== c ? u : c.map(i);
          }
          return i(this, null, null);
        }),
        (t.prototype.filter = function (n) {
          var i = [];
          return (
            this.traverse(function (c, m, f) {
              n(c, m, f) && i.push(c);
            }),
            i
          );
        }),
        (t.prototype.clone = function () {
          throw new Error("Cannot clone a Node interface");
        }),
        (t.prototype.cloneDeep = function () {
          return this.map(function (n) {
            return n.cloneDeep();
          });
        }),
        (t.prototype.equals = function (n) {
          return n ? Pa(this, n) : !1;
        }),
        (t.prototype.toString = function (n) {
          var i = this._getCustomString(n);
          return typeof i < "u" ? i : this._toString(n);
        }),
        (t.prototype.toJSON = function () {
          throw new Error(
            "Cannot serialize object: toJSON not implemented by " + this.type
          );
        }),
        (t.prototype.toHTML = function (n) {
          var i = this._getCustomString(n);
          return typeof i < "u" ? i : this.toHTML(n);
        }),
        (t.prototype._toString = function () {
          throw new Error("_toString not implemented for " + this.type);
        }),
        (t.prototype.toTex = function (n) {
          var i = this._getCustomString(n);
          return typeof i < "u" ? i : this._toTex(n);
        }),
        (t.prototype._toTex = function (n) {
          throw new Error("_toTex not implemented for " + this.type);
        }),
        (t.prototype._getCustomString = function (n) {
          if (n && typeof n == "object")
            switch (typeof n.handler) {
              case "object":
              case "undefined":
                return;
              case "function":
                return n.handler(this, n);
              default:
                throw new TypeError("Object or function expected as callback");
            }
        }),
        (t.prototype.getIdentifier = function () {
          return this.type;
        }),
        (t.prototype.getContent = function () {
          return this;
        });
      function a(n) {
        for (var i of [...gh])
          if (n.has(i))
            throw new Error(
              'Scope contains an illegal symbol, "' +
                i +
                '" is a reserved keyword'
            );
      }
      return t;
    },
    { isClass: !0, isNode: !0 }
  );
function Qr(e) {
  return e && e.isIndexError
    ? new At(e.index + 1, e.min + 1, e.max !== void 0 ? e.max + 1 : void 0)
    : e;
}
function yh(e) {
  var { subset: r } = e;
  return function (a, n) {
    try {
      if (Array.isArray(a)) return r(a, n);
      if (a && typeof a.subset == "function") return a.subset(n);
      if (typeof a == "string") return r(a, n);
      if (typeof a == "object") {
        if (!n.isObjectProperty())
          throw new TypeError(
            "Cannot apply a numeric index as object property"
          );
        return ct(a, n.getObjectProperty());
      } else
        throw new TypeError("Cannot apply index: unsupported type of object");
    } catch (i) {
      throw Qr(i);
    }
  };
}
var qE = "AccessorNode",
  zE = ["subset", "Node"],
  UE = P(
    qE,
    zE,
    (e) => {
      var { subset: r, Node: t } = e,
        a = yh({ subset: r });
      function n(c, m) {
        if (!(this instanceof n))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!ir(c)) throw new TypeError('Node expected for parameter "object"');
        if (!ga(m))
          throw new TypeError('IndexNode expected for parameter "index"');
        (this.object = c || null),
          (this.index = m),
          Object.defineProperty(this, "name", {
            get: function () {
              return this.index
                ? this.index.isObjectProperty()
                  ? this.index.getObjectProperty()
                  : ""
                : this.object.name || "";
            }.bind(this),
            set: function () {
              throw new Error("Cannot assign a new name, name is read-only");
            },
          });
      }
      (n.prototype = new t()),
        (n.prototype.type = "AccessorNode"),
        (n.prototype.isAccessorNode = !0),
        (n.prototype._compile = function (c, m) {
          var f = this.object._compile(c, m),
            u = this.index._compile(c, m);
          if (this.index.isObjectProperty()) {
            var s = this.index.getObjectProperty();
            return function (l, p, v) {
              return ct(f(l, p, v), s);
            };
          } else
            return function (l, p, v) {
              var h = f(l, p, v),
                x = u(l, p, h);
              return a(h, x);
            };
        }),
        (n.prototype.forEach = function (c) {
          c(this.object, "object", this), c(this.index, "index", this);
        }),
        (n.prototype.map = function (c) {
          return new n(
            this._ifNode(c(this.object, "object", this)),
            this._ifNode(c(this.index, "index", this))
          );
        }),
        (n.prototype.clone = function () {
          return new n(this.object, this.index);
        }),
        (n.prototype._toString = function (c) {
          var m = this.object.toString(c);
          return (
            i(this.object) && (m = "(" + m + ")"), m + this.index.toString(c)
          );
        }),
        (n.prototype.toHTML = function (c) {
          var m = this.object.toHTML(c);
          return (
            i(this.object) &&
              (m =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                m +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            m + this.index.toHTML(c)
          );
        }),
        (n.prototype._toTex = function (c) {
          var m = this.object.toTex(c);
          return (
            i(this.object) && (m = "\\left(' + object + '\\right)"),
            m + this.index.toTex(c)
          );
        }),
        (n.prototype.toJSON = function () {
          return {
            mathjs: "AccessorNode",
            object: this.object,
            index: this.index,
          };
        }),
        (n.fromJSON = function (c) {
          return new n(c.object, c.index);
        });
      function i(c) {
        return !(En(c) || ut(c) || lr(c) || Cn(c) || Ji(c) || Wa(c) || qr(c));
      }
      return n;
    },
    { isClass: !0, isNode: !0 }
  ),
  LE = "ArrayNode",
  kE = ["Node"],
  VE = P(
    LE,
    kE,
    (e) => {
      var { Node: r } = e;
      function t(a) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (
          ((this.items = a || []),
          !Array.isArray(this.items) || !this.items.every(ir))
        )
          throw new TypeError("Array containing Nodes expected");
      }
      return (
        (t.prototype = new r()),
        (t.prototype.type = "ArrayNode"),
        (t.prototype.isArrayNode = !0),
        (t.prototype._compile = function (a, n) {
          var i = Xt(this.items, function (f) {
              return f._compile(a, n);
            }),
            c = a.config.matrix !== "Array";
          if (c) {
            var m = a.matrix;
            return function (u, s, o) {
              return m(
                Xt(i, function (l) {
                  return l(u, s, o);
                })
              );
            };
          } else
            return function (u, s, o) {
              return Xt(i, function (l) {
                return l(u, s, o);
              });
            };
        }),
        (t.prototype.forEach = function (a) {
          for (var n = 0; n < this.items.length; n++) {
            var i = this.items[n];
            a(i, "items[" + n + "]", this);
          }
        }),
        (t.prototype.map = function (a) {
          for (var n = [], i = 0; i < this.items.length; i++)
            n[i] = this._ifNode(a(this.items[i], "items[" + i + "]", this));
          return new t(n);
        }),
        (t.prototype.clone = function () {
          return new t(this.items.slice(0));
        }),
        (t.prototype._toString = function (a) {
          var n = this.items.map(function (i) {
            return i.toString(a);
          });
          return "[" + n.join(", ") + "]";
        }),
        (t.prototype.toJSON = function () {
          return { mathjs: "ArrayNode", items: this.items };
        }),
        (t.fromJSON = function (a) {
          return new t(a.items);
        }),
        (t.prototype.toHTML = function (a) {
          var n = this.items.map(function (i) {
            return i.toHTML(a);
          });
          return (
            '<span class="math-parenthesis math-square-parenthesis">[</span>' +
            n.join('<span class="math-separator">,</span>') +
            '<span class="math-parenthesis math-square-parenthesis">]</span>'
          );
        }),
        (t.prototype._toTex = function (a) {
          function n(i, c) {
            var m = i.some(ut) && !i.every(ut),
              f = c || m,
              u = f ? "&" : "\\\\",
              s = i
                .map(function (o) {
                  return o.items ? n(o.items, !c) : o.toTex(a);
                })
                .join(u);
            return m || !f || (f && !c)
              ? "\\begin{bmatrix}" + s + "\\end{bmatrix}"
              : s;
          }
          return n(this.items, !1);
        }),
        t
      );
    },
    { isClass: !0, isNode: !0 }
  );
function GE(e) {
  var { subset: r, matrix: t } = e;
  return function (n, i, c) {
    try {
      if (Array.isArray(n)) return t(n).subset(i, c).valueOf();
      if (n && typeof n.subset == "function") return n.subset(i, c);
      if (typeof n == "string") return r(n, i, c);
      if (typeof n == "object") {
        if (!i.isObjectProperty())
          throw TypeError("Cannot apply a numeric index as object property");
        return ua(n, i.getObjectProperty(), c), n;
      } else
        throw new TypeError("Cannot apply index: unsupported type of object");
    } catch (m) {
      throw Qr(m);
    }
  };
}
var Bt = [
  { AssignmentNode: {}, FunctionAssignmentNode: {} },
  {
    ConditionalNode: {
      latexLeftParens: !1,
      latexRightParens: !1,
      latexParens: !1,
    },
  },
  { "OperatorNode:or": { associativity: "left", associativeWith: [] } },
  { "OperatorNode:xor": { associativity: "left", associativeWith: [] } },
  { "OperatorNode:and": { associativity: "left", associativeWith: [] } },
  { "OperatorNode:bitOr": { associativity: "left", associativeWith: [] } },
  { "OperatorNode:bitXor": { associativity: "left", associativeWith: [] } },
  { "OperatorNode:bitAnd": { associativity: "left", associativeWith: [] } },
  {
    "OperatorNode:equal": { associativity: "left", associativeWith: [] },
    "OperatorNode:unequal": { associativity: "left", associativeWith: [] },
    "OperatorNode:smaller": { associativity: "left", associativeWith: [] },
    "OperatorNode:larger": { associativity: "left", associativeWith: [] },
    "OperatorNode:smallerEq": { associativity: "left", associativeWith: [] },
    "OperatorNode:largerEq": { associativity: "left", associativeWith: [] },
    RelationalNode: { associativity: "left", associativeWith: [] },
  },
  {
    "OperatorNode:leftShift": { associativity: "left", associativeWith: [] },
    "OperatorNode:rightArithShift": {
      associativity: "left",
      associativeWith: [],
    },
    "OperatorNode:rightLogShift": {
      associativity: "left",
      associativeWith: [],
    },
  },
  { "OperatorNode:to": { associativity: "left", associativeWith: [] } },
  { RangeNode: {} },
  {
    "OperatorNode:add": {
      associativity: "left",
      associativeWith: ["OperatorNode:add", "OperatorNode:subtract"],
    },
    "OperatorNode:subtract": { associativity: "left", associativeWith: [] },
  },
  {
    "OperatorNode:multiply": {
      associativity: "left",
      associativeWith: [
        "OperatorNode:multiply",
        "OperatorNode:divide",
        "Operator:dotMultiply",
        "Operator:dotDivide",
      ],
    },
    "OperatorNode:divide": {
      associativity: "left",
      associativeWith: [],
      latexLeftParens: !1,
      latexRightParens: !1,
      latexParens: !1,
    },
    "OperatorNode:dotMultiply": {
      associativity: "left",
      associativeWith: [
        "OperatorNode:multiply",
        "OperatorNode:divide",
        "OperatorNode:dotMultiply",
        "OperatorNode:doDivide",
      ],
    },
    "OperatorNode:dotDivide": { associativity: "left", associativeWith: [] },
    "OperatorNode:mod": { associativity: "left", associativeWith: [] },
  },
  {
    "OperatorNode:unaryPlus": { associativity: "right" },
    "OperatorNode:unaryMinus": { associativity: "right" },
    "OperatorNode:bitNot": { associativity: "right" },
    "OperatorNode:not": { associativity: "right" },
  },
  {
    "OperatorNode:pow": {
      associativity: "right",
      associativeWith: [],
      latexRightParens: !1,
    },
    "OperatorNode:dotPow": { associativity: "right", associativeWith: [] },
  },
  { "OperatorNode:factorial": { associativity: "left" } },
  { "OperatorNode:transpose": { associativity: "left" } },
];
function fr(e, r) {
  var t = e;
  r !== "keep" && (t = e.getContent());
  for (var a = t.getIdentifier(), n = 0; n < Bt.length; n++)
    if (a in Bt[n]) return n;
  return null;
}
function Oa(e, r) {
  var t = e;
  r !== "keep" && (t = e.getContent());
  var a = t.getIdentifier(),
    n = fr(t, r);
  if (n === null) return null;
  var i = Bt[n][a];
  if (De(i, "associativity")) {
    if (i.associativity === "left") return "left";
    if (i.associativity === "right") return "right";
    throw Error(
      "'" + a + "' has the invalid associativity '" + i.associativity + "'."
    );
  }
  return null;
}
function ko(e, r, t) {
  var a = t !== "keep" ? e.getContent() : e,
    n = t !== "keep" ? e.getContent() : r,
    i = a.getIdentifier(),
    c = n.getIdentifier(),
    m = fr(a, t);
  if (m === null) return null;
  var f = Bt[m][i];
  if (De(f, "associativeWith") && f.associativeWith instanceof Array) {
    for (var u = 0; u < f.associativeWith.length; u++)
      if (f.associativeWith[u] === c) return !0;
    return !1;
  }
  return null;
}
var HE = "AssignmentNode",
  ZE = ["subset", "?matrix", "Node"],
  JE = P(
    HE,
    ZE,
    (e) => {
      var { subset: r, matrix: t, Node: a } = e,
        n = yh({ subset: r }),
        i = GE({ subset: r, matrix: t });
      function c(f, u, s) {
        if (!(this instanceof c))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (
          ((this.object = f),
          (this.index = s ? u : null),
          (this.value = s || u),
          !qr(f) && !En(f))
        )
          throw new TypeError(
            'SymbolNode or AccessorNode expected as "object"'
          );
        if (qr(f) && f.name === "end")
          throw new Error('Cannot assign to symbol "end"');
        if (this.index && !ga(this.index))
          throw new TypeError('IndexNode expected as "index"');
        if (!ir(this.value)) throw new TypeError('Node expected as "value"');
        Object.defineProperty(this, "name", {
          get: function () {
            return this.index
              ? this.index.isObjectProperty()
                ? this.index.getObjectProperty()
                : ""
              : this.object.name || "";
          }.bind(this),
          set: function () {
            throw new Error("Cannot assign a new name, name is read-only");
          },
        });
      }
      (c.prototype = new a()),
        (c.prototype.type = "AssignmentNode"),
        (c.prototype.isAssignmentNode = !0),
        (c.prototype._compile = function (f, u) {
          var s = this.object._compile(f, u),
            o = this.index ? this.index._compile(f, u) : null,
            l = this.value._compile(f, u),
            p = this.object.name;
          if (this.index)
            if (this.index.isObjectProperty()) {
              var v = this.index.getObjectProperty();
              return function (d, y, w) {
                var g = s(d, y, w),
                  S = l(d, y, w);
                return ua(g, v, S), S;
              };
            } else {
              if (qr(this.object))
                return function (d, y, w) {
                  var g = s(d, y, w),
                    S = l(d, y, w),
                    A = o(d, y, g);
                  return d.set(p, i(g, A, S)), S;
                };
              var h = this.object.object._compile(f, u);
              if (this.object.index.isObjectProperty()) {
                var x = this.object.index.getObjectProperty();
                return function (d, y, w) {
                  var g = h(d, y, w),
                    S = ct(g, x),
                    A = o(d, y, S),
                    E = l(d, y, w);
                  return ua(g, x, i(S, A, E)), E;
                };
              } else {
                var b = this.object.index._compile(f, u);
                return function (d, y, w) {
                  var g = h(d, y, w),
                    S = b(d, y, g),
                    A = n(g, S),
                    E = o(d, y, A),
                    M = l(d, y, w);
                  return i(g, S, i(A, E, M)), M;
                };
              }
            }
          else {
            if (!qr(this.object))
              throw new TypeError("SymbolNode expected as object");
            return function (d, y, w) {
              var g = l(d, y, w);
              return d.set(p, g), g;
            };
          }
        }),
        (c.prototype.forEach = function (f) {
          f(this.object, "object", this),
            this.index && f(this.index, "index", this),
            f(this.value, "value", this);
        }),
        (c.prototype.map = function (f) {
          var u = this._ifNode(f(this.object, "object", this)),
            s = this.index ? this._ifNode(f(this.index, "index", this)) : null,
            o = this._ifNode(f(this.value, "value", this));
          return new c(u, s, o);
        }),
        (c.prototype.clone = function () {
          return new c(this.object, this.index, this.value);
        });
      function m(f, u) {
        u || (u = "keep");
        var s = fr(f, u),
          o = fr(f.value, u);
        return u === "all" || (o !== null && o <= s);
      }
      return (
        (c.prototype._toString = function (f) {
          var u = this.object.toString(f),
            s = this.index ? this.index.toString(f) : "",
            o = this.value.toString(f);
          return (
            m(this, f && f.parenthesis) && (o = "(" + o + ")"),
            u + s + " = " + o
          );
        }),
        (c.prototype.toJSON = function () {
          return {
            mathjs: "AssignmentNode",
            object: this.object,
            index: this.index,
            value: this.value,
          };
        }),
        (c.fromJSON = function (f) {
          return new c(f.object, f.index, f.value);
        }),
        (c.prototype.toHTML = function (f) {
          var u = this.object.toHTML(f),
            s = this.index ? this.index.toHTML(f) : "",
            o = this.value.toHTML(f);
          return (
            m(this, f && f.parenthesis) &&
              (o =
                '<span class="math-paranthesis math-round-parenthesis">(</span>' +
                o +
                '<span class="math-paranthesis math-round-parenthesis">)</span>'),
            u +
              s +
              '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' +
              o
          );
        }),
        (c.prototype._toTex = function (f) {
          var u = this.object.toTex(f),
            s = this.index ? this.index.toTex(f) : "",
            o = this.value.toTex(f);
          return (
            m(this, f && f.parenthesis) &&
              (o = "\\left(".concat(o, "\\right)")),
            u + s + ":=" + o
          );
        }),
        c
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  WE = "BlockNode",
  XE = ["ResultSet", "Node"],
  YE = P(
    WE,
    XE,
    (e) => {
      var { ResultSet: r, Node: t } = e;
      function a(n) {
        if (!(this instanceof a))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!Array.isArray(n)) throw new Error("Array expected");
        this.blocks = n.map(function (i) {
          var c = i && i.node,
            m = i && i.visible !== void 0 ? i.visible : !0;
          if (!ir(c)) throw new TypeError('Property "node" must be a Node');
          if (typeof m != "boolean")
            throw new TypeError('Property "visible" must be a boolean');
          return { node: c, visible: m };
        });
      }
      return (
        (a.prototype = new t()),
        (a.prototype.type = "BlockNode"),
        (a.prototype.isBlockNode = !0),
        (a.prototype._compile = function (n, i) {
          var c = Xt(this.blocks, function (m) {
            return { evaluate: m.node._compile(n, i), visible: m.visible };
          });
          return function (f, u, s) {
            var o = [];
            return (
              Yi(c, function (p) {
                var v = p.evaluate(f, u, s);
                p.visible && o.push(v);
              }),
              new r(o)
            );
          };
        }),
        (a.prototype.forEach = function (n) {
          for (var i = 0; i < this.blocks.length; i++)
            n(this.blocks[i].node, "blocks[" + i + "].node", this);
        }),
        (a.prototype.map = function (n) {
          for (var i = [], c = 0; c < this.blocks.length; c++) {
            var m = this.blocks[c],
              f = this._ifNode(n(m.node, "blocks[" + c + "].node", this));
            i[c] = { node: f, visible: m.visible };
          }
          return new a(i);
        }),
        (a.prototype.clone = function () {
          var n = this.blocks.map(function (i) {
            return { node: i.node, visible: i.visible };
          });
          return new a(n);
        }),
        (a.prototype._toString = function (n) {
          return this.blocks.map(function (i) {
            return i.node.toString(n) + (i.visible ? "" : ";");
          }).join(`
`);
        }),
        (a.prototype.toJSON = function () {
          return { mathjs: "BlockNode", blocks: this.blocks };
        }),
        (a.fromJSON = function (n) {
          return new a(n.blocks);
        }),
        (a.prototype.toHTML = function (n) {
          return this.blocks
            .map(function (i) {
              return (
                i.node.toHTML(n) +
                (i.visible ? "" : '<span class="math-separator">;</span>')
              );
            })
            .join('<span class="math-separator"><br /></span>');
        }),
        (a.prototype._toTex = function (n) {
          return this.blocks.map(function (i) {
            return i.node.toTex(n) + (i.visible ? "" : ";");
          }).join(`\\;\\;
`);
        }),
        a
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  QE = "ConditionalNode",
  jE = ["Node"],
  KE = P(
    QE,
    jE,
    (e) => {
      var { Node: r } = e;
      function t(n, i, c) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!ir(n)) throw new TypeError("Parameter condition must be a Node");
        if (!ir(i)) throw new TypeError("Parameter trueExpr must be a Node");
        if (!ir(c)) throw new TypeError("Parameter falseExpr must be a Node");
        (this.condition = n), (this.trueExpr = i), (this.falseExpr = c);
      }
      (t.prototype = new r()),
        (t.prototype.type = "ConditionalNode"),
        (t.prototype.isConditionalNode = !0),
        (t.prototype._compile = function (n, i) {
          var c = this.condition._compile(n, i),
            m = this.trueExpr._compile(n, i),
            f = this.falseExpr._compile(n, i);
          return function (s, o, l) {
            return a(c(s, o, l)) ? m(s, o, l) : f(s, o, l);
          };
        }),
        (t.prototype.forEach = function (n) {
          n(this.condition, "condition", this),
            n(this.trueExpr, "trueExpr", this),
            n(this.falseExpr, "falseExpr", this);
        }),
        (t.prototype.map = function (n) {
          return new t(
            this._ifNode(n(this.condition, "condition", this)),
            this._ifNode(n(this.trueExpr, "trueExpr", this)),
            this._ifNode(n(this.falseExpr, "falseExpr", this))
          );
        }),
        (t.prototype.clone = function () {
          return new t(this.condition, this.trueExpr, this.falseExpr);
        }),
        (t.prototype._toString = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = fr(this, i),
            m = this.condition.toString(n),
            f = fr(this.condition, i);
          (i === "all" ||
            this.condition.type === "OperatorNode" ||
            (f !== null && f <= c)) &&
            (m = "(" + m + ")");
          var u = this.trueExpr.toString(n),
            s = fr(this.trueExpr, i);
          (i === "all" ||
            this.trueExpr.type === "OperatorNode" ||
            (s !== null && s <= c)) &&
            (u = "(" + u + ")");
          var o = this.falseExpr.toString(n),
            l = fr(this.falseExpr, i);
          return (
            (i === "all" ||
              this.falseExpr.type === "OperatorNode" ||
              (l !== null && l <= c)) &&
              (o = "(" + o + ")"),
            m + " ? " + u + " : " + o
          );
        }),
        (t.prototype.toJSON = function () {
          return {
            mathjs: "ConditionalNode",
            condition: this.condition,
            trueExpr: this.trueExpr,
            falseExpr: this.falseExpr,
          };
        }),
        (t.fromJSON = function (n) {
          return new t(n.condition, n.trueExpr, n.falseExpr);
        }),
        (t.prototype.toHTML = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = fr(this, i),
            m = this.condition.toHTML(n),
            f = fr(this.condition, i);
          (i === "all" ||
            this.condition.type === "OperatorNode" ||
            (f !== null && f <= c)) &&
            (m =
              '<span class="math-parenthesis math-round-parenthesis">(</span>' +
              m +
              '<span class="math-parenthesis math-round-parenthesis">)</span>');
          var u = this.trueExpr.toHTML(n),
            s = fr(this.trueExpr, i);
          (i === "all" ||
            this.trueExpr.type === "OperatorNode" ||
            (s !== null && s <= c)) &&
            (u =
              '<span class="math-parenthesis math-round-parenthesis">(</span>' +
              u +
              '<span class="math-parenthesis math-round-parenthesis">)</span>');
          var o = this.falseExpr.toHTML(n),
            l = fr(this.falseExpr, i);
          return (
            (i === "all" ||
              this.falseExpr.type === "OperatorNode" ||
              (l !== null && l <= c)) &&
              (o =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                o +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            m +
              '<span class="math-operator math-conditional-operator">?</span>' +
              u +
              '<span class="math-operator math-conditional-operator">:</span>' +
              o
          );
        }),
        (t.prototype._toTex = function (n) {
          return (
            "\\begin{cases} {" +
            this.trueExpr.toTex(n) +
            "}, &\\quad{\\text{if }\\;" +
            this.condition.toTex(n) +
            "}\\\\{" +
            this.falseExpr.toTex(n) +
            "}, &\\quad{\\text{otherwise}}\\end{cases}"
          );
        });
      function a(n) {
        if (
          typeof n == "number" ||
          typeof n == "boolean" ||
          typeof n == "string"
        )
          return !!n;
        if (n) {
          if (Qe(n)) return !n.isZero();
          if (Wt(n)) return !!(n.re || n.im);
          if (Ha(n)) return !!n.value;
        }
        if (n == null) return !1;
        throw new TypeError('Unsupported type of condition "' + vr(n) + '"');
      }
      return t;
    },
    { isClass: !0, isNode: !0 }
  ),
  Ms =
    Object.assign ||
    function (e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = arguments[r];
        for (var a in t)
          Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
      }
      return e;
    },
  eC = {
    "{": "\\{",
    "}": "\\}",
    "\\": "\\textbackslash{}",
    "#": "\\#",
    $: "\\$",
    "%": "\\%",
    "&": "\\&",
    "^": "\\textasciicircum{}",
    _: "\\_",
    "~": "\\textasciitilde{}",
  },
  rC = {
    "–": "\\--",
    "—": "\\---",
    " ": "~",
    "	": "\\qquad{}",
    "\r\n": "\\newline{}",
    "\n": "\\newline{}",
  },
  tC = function (r, t) {
    return Ms({}, r, t);
  },
  nC = function (e) {
    for (
      var r =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        t = r.preserveFormatting,
        a = t === void 0 ? !1 : t,
        n = r.escapeMapFn,
        i = n === void 0 ? tC : n,
        c = String(e),
        m = "",
        f = i(Ms({}, eC), a ? Ms({}, rC) : {}),
        u = Object.keys(f),
        s = function () {
          var l = !1;
          u.forEach(function (p, v) {
            l ||
              (c.length >= p.length &&
                c.slice(0, p.length) === p &&
                ((m += f[u[v]]), (c = c.slice(p.length, c.length)), (l = !0)));
          }),
            l || ((m += c.slice(0, 1)), (c = c.slice(1, c.length)));
        };
      c;

    )
      s();
    return m;
  };
const aC = pa(nC);
var As = {
    Alpha: "A",
    alpha: "\\alpha",
    Beta: "B",
    beta: "\\beta",
    Gamma: "\\Gamma",
    gamma: "\\gamma",
    Delta: "\\Delta",
    delta: "\\delta",
    Epsilon: "E",
    epsilon: "\\epsilon",
    varepsilon: "\\varepsilon",
    Zeta: "Z",
    zeta: "\\zeta",
    Eta: "H",
    eta: "\\eta",
    Theta: "\\Theta",
    theta: "\\theta",
    vartheta: "\\vartheta",
    Iota: "I",
    iota: "\\iota",
    Kappa: "K",
    kappa: "\\kappa",
    varkappa: "\\varkappa",
    Lambda: "\\Lambda",
    lambda: "\\lambda",
    Mu: "M",
    mu: "\\mu",
    Nu: "N",
    nu: "\\nu",
    Xi: "\\Xi",
    xi: "\\xi",
    Omicron: "O",
    omicron: "o",
    Pi: "\\Pi",
    pi: "\\pi",
    varpi: "\\varpi",
    Rho: "P",
    rho: "\\rho",
    varrho: "\\varrho",
    Sigma: "\\Sigma",
    sigma: "\\sigma",
    varsigma: "\\varsigma",
    Tau: "T",
    tau: "\\tau",
    Upsilon: "\\Upsilon",
    upsilon: "\\upsilon",
    Phi: "\\Phi",
    phi: "\\phi",
    varphi: "\\varphi",
    Chi: "X",
    chi: "\\chi",
    Psi: "\\Psi",
    psi: "\\psi",
    Omega: "\\Omega",
    omega: "\\omega",
    true: "\\mathrm{True}",
    false: "\\mathrm{False}",
    i: "i",
    inf: "\\infty",
    Inf: "\\infty",
    infinity: "\\infty",
    Infinity: "\\infty",
    oo: "\\infty",
    lim: "\\lim",
    undefined: "\\mathbf{?}",
  },
  tr = {
    transpose: "^\\top",
    ctranspose: "^H",
    factorial: "!",
    pow: "^",
    dotPow: ".^\\wedge",
    unaryPlus: "+",
    unaryMinus: "-",
    bitNot: "\\~",
    not: "\\neg",
    multiply: "\\cdot",
    divide: "\\frac",
    dotMultiply: ".\\cdot",
    dotDivide: ".:",
    mod: "\\mod",
    add: "+",
    subtract: "-",
    to: "\\rightarrow",
    leftShift: "<<",
    rightArithShift: ">>",
    rightLogShift: ">>>",
    equal: "=",
    unequal: "\\neq",
    smaller: "<",
    larger: ">",
    smallerEq: "\\leq",
    largerEq: "\\geq",
    bitAnd: "\\&",
    bitXor: "\\underline{|}",
    bitOr: "|",
    and: "\\wedge",
    xor: "\\veebar",
    or: "\\vee",
  },
  Jf = {
    abs: { 1: "\\left|${args[0]}\\right|" },
    add: { 2: "\\left(${args[0]}".concat(tr.add, "${args[1]}\\right)") },
    cbrt: { 1: "\\sqrt[3]{${args[0]}}" },
    ceil: { 1: "\\left\\lceil${args[0]}\\right\\rceil" },
    cube: { 1: "\\left(${args[0]}\\right)^3" },
    divide: { 2: "\\frac{${args[0]}}{${args[1]}}" },
    dotDivide: {
      2: "\\left(${args[0]}".concat(tr.dotDivide, "${args[1]}\\right)"),
    },
    dotMultiply: {
      2: "\\left(${args[0]}".concat(tr.dotMultiply, "${args[1]}\\right)"),
    },
    dotPow: { 2: "\\left(${args[0]}".concat(tr.dotPow, "${args[1]}\\right)") },
    exp: { 1: "\\exp\\left(${args[0]}\\right)" },
    expm1: "\\left(e".concat(tr.pow, "{${args[0]}}-1\\right)"),
    fix: { 1: "\\mathrm{${name}}\\left(${args[0]}\\right)" },
    floor: { 1: "\\left\\lfloor${args[0]}\\right\\rfloor" },
    gcd: "\\gcd\\left(${args}\\right)",
    hypot: "\\hypot\\left(${args}\\right)",
    log: {
      1: "\\ln\\left(${args[0]}\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}\\right)",
    },
    log10: { 1: "\\log_{10}\\left(${args[0]}\\right)" },
    log1p: {
      1: "\\ln\\left(${args[0]}+1\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)",
    },
    log2: "\\log_{2}\\left(${args[0]}\\right)",
    mod: { 2: "\\left(${args[0]}".concat(tr.mod, "${args[1]}\\right)") },
    multiply: {
      2: "\\left(${args[0]}".concat(tr.multiply, "${args[1]}\\right)"),
    },
    norm: { 1: "\\left\\|${args[0]}\\right\\|", 2: void 0 },
    nthRoot: { 2: "\\sqrt[${args[1]}]{${args[0]}}" },
    nthRoots: { 2: "\\{y : $y^{args[1]} = {${args[0]}}\\}" },
    pow: { 2: "\\left(${args[0]}\\right)".concat(tr.pow, "{${args[1]}}") },
    round: { 1: "\\left\\lfloor${args[0]}\\right\\rceil", 2: void 0 },
    sign: { 1: "\\mathrm{${name}}\\left(${args[0]}\\right)" },
    sqrt: { 1: "\\sqrt{${args[0]}}" },
    square: { 1: "\\left(${args[0]}\\right)^2" },
    subtract: {
      2: "\\left(${args[0]}".concat(tr.subtract, "${args[1]}\\right)"),
    },
    unaryMinus: { 1: "".concat(tr.unaryMinus, "\\left(${args[0]}\\right)") },
    unaryPlus: { 1: "".concat(tr.unaryPlus, "\\left(${args[0]}\\right)") },
    bitAnd: { 2: "\\left(${args[0]}".concat(tr.bitAnd, "${args[1]}\\right)") },
    bitNot: { 1: tr.bitNot + "\\left(${args[0]}\\right)" },
    bitOr: { 2: "\\left(${args[0]}".concat(tr.bitOr, "${args[1]}\\right)") },
    bitXor: { 2: "\\left(${args[0]}".concat(tr.bitXor, "${args[1]}\\right)") },
    leftShift: {
      2: "\\left(${args[0]}".concat(tr.leftShift, "${args[1]}\\right)"),
    },
    rightArithShift: {
      2: "\\left(${args[0]}".concat(tr.rightArithShift, "${args[1]}\\right)"),
    },
    rightLogShift: {
      2: "\\left(${args[0]}".concat(tr.rightLogShift, "${args[1]}\\right)"),
    },
    bellNumbers: { 1: "\\mathrm{B}_{${args[0]}}" },
    catalan: { 1: "\\mathrm{C}_{${args[0]}}" },
    stirlingS2: { 2: "\\mathrm{S}\\left(${args}\\right)" },
    arg: { 1: "\\arg\\left(${args[0]}\\right)" },
    conj: { 1: "\\left(${args[0]}\\right)^*" },
    im: { 1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace" },
    re: { 1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace" },
    and: { 2: "\\left(${args[0]}".concat(tr.and, "${args[1]}\\right)") },
    not: { 1: tr.not + "\\left(${args[0]}\\right)" },
    or: { 2: "\\left(${args[0]}".concat(tr.or, "${args[1]}\\right)") },
    xor: { 2: "\\left(${args[0]}".concat(tr.xor, "${args[1]}\\right)") },
    cross: { 2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)" },
    ctranspose: { 1: "\\left(${args[0]}\\right)".concat(tr.ctranspose) },
    det: { 1: "\\det\\left(${args[0]}\\right)" },
    dot: { 2: "\\left(${args[0]}\\cdot${args[1]}\\right)" },
    expm: { 1: "\\exp\\left(${args[0]}\\right)" },
    inv: { 1: "\\left(${args[0]}\\right)^{-1}" },
    pinv: { 1: "\\left(${args[0]}\\right)^{+}" },
    sqrtm: { 1: "{${args[0]}}".concat(tr.pow, "{\\frac{1}{2}}") },
    trace: { 1: "\\mathrm{tr}\\left(${args[0]}\\right)" },
    transpose: { 1: "\\left(${args[0]}\\right)".concat(tr.transpose) },
    combinations: { 2: "\\binom{${args[0]}}{${args[1]}}" },
    combinationsWithRep: {
      2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)",
    },
    factorial: { 1: "\\left(${args[0]}\\right)".concat(tr.factorial) },
    gamma: { 1: "\\Gamma\\left(${args[0]}\\right)" },
    lgamma: { 1: "\\ln\\Gamma\\left(${args[0]}\\right)" },
    equal: { 2: "\\left(${args[0]}".concat(tr.equal, "${args[1]}\\right)") },
    larger: { 2: "\\left(${args[0]}".concat(tr.larger, "${args[1]}\\right)") },
    largerEq: {
      2: "\\left(${args[0]}".concat(tr.largerEq, "${args[1]}\\right)"),
    },
    smaller: {
      2: "\\left(${args[0]}".concat(tr.smaller, "${args[1]}\\right)"),
    },
    smallerEq: {
      2: "\\left(${args[0]}".concat(tr.smallerEq, "${args[1]}\\right)"),
    },
    unequal: {
      2: "\\left(${args[0]}".concat(tr.unequal, "${args[1]}\\right)"),
    },
    erf: { 1: "erf\\left(${args[0]}\\right)" },
    max: "\\max\\left(${args}\\right)",
    min: "\\min\\left(${args}\\right)",
    variance: "\\mathrm{Var}\\left(${args}\\right)",
    acos: { 1: "\\cos^{-1}\\left(${args[0]}\\right)" },
    acosh: { 1: "\\cosh^{-1}\\left(${args[0]}\\right)" },
    acot: { 1: "\\cot^{-1}\\left(${args[0]}\\right)" },
    acoth: { 1: "\\coth^{-1}\\left(${args[0]}\\right)" },
    acsc: { 1: "\\csc^{-1}\\left(${args[0]}\\right)" },
    acsch: { 1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)" },
    asec: { 1: "\\sec^{-1}\\left(${args[0]}\\right)" },
    asech: { 1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)" },
    asin: { 1: "\\sin^{-1}\\left(${args[0]}\\right)" },
    asinh: { 1: "\\sinh^{-1}\\left(${args[0]}\\right)" },
    atan: { 1: "\\tan^{-1}\\left(${args[0]}\\right)" },
    atan2: { 2: "\\mathrm{atan2}\\left(${args}\\right)" },
    atanh: { 1: "\\tanh^{-1}\\left(${args[0]}\\right)" },
    cos: { 1: "\\cos\\left(${args[0]}\\right)" },
    cosh: { 1: "\\cosh\\left(${args[0]}\\right)" },
    cot: { 1: "\\cot\\left(${args[0]}\\right)" },
    coth: { 1: "\\coth\\left(${args[0]}\\right)" },
    csc: { 1: "\\csc\\left(${args[0]}\\right)" },
    csch: { 1: "\\mathrm{csch}\\left(${args[0]}\\right)" },
    sec: { 1: "\\sec\\left(${args[0]}\\right)" },
    sech: { 1: "\\mathrm{sech}\\left(${args[0]}\\right)" },
    sin: { 1: "\\sin\\left(${args[0]}\\right)" },
    sinh: { 1: "\\sinh\\left(${args[0]}\\right)" },
    tan: { 1: "\\tan\\left(${args[0]}\\right)" },
    tanh: { 1: "\\tanh\\left(${args[0]}\\right)" },
    to: { 2: "\\left(${args[0]}".concat(tr.to, "${args[1]}\\right)") },
    numeric: function (r, t) {
      return r.args[0].toTex();
    },
    number: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)",
    },
    string: {
      0: '\\mathtt{""}',
      1: "\\mathrm{string}\\left(${args[0]}\\right)",
    },
    bignumber: { 0: "0", 1: "\\left(${args[0]}\\right)" },
    complex: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)+".concat(
        As.i,
        "\\cdot\\left(${args[1]}\\right)\\right)"
      ),
    },
    matrix: {
      0: "\\begin{bmatrix}\\end{bmatrix}",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(${args[0]}\\right)",
    },
    sparse: {
      0: "\\begin{bsparse}\\end{bsparse}",
      1: "\\left(${args[0]}\\right)",
    },
    unit: {
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)",
    },
  },
  iC = "\\mathrm{${name}}\\left(${args}\\right)",
  Wf = { deg: "^\\circ" };
function Ss(e) {
  return aC(e, { preserveFormatting: !0 });
}
function bh(e, r) {
  return (
    (r = typeof r > "u" ? !1 : r),
    r
      ? De(Wf, e)
        ? Wf[e]
        : "\\mathrm{" + Ss(e) + "}"
      : De(As, e)
      ? As[e]
      : Ss(e)
  );
}
var oC = "ConstantNode",
  sC = ["Node"],
  uC = P(
    oC,
    sC,
    (e) => {
      var { Node: r } = e;
      function t(a) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        this.value = a;
      }
      return (
        (t.prototype = new r()),
        (t.prototype.type = "ConstantNode"),
        (t.prototype.isConstantNode = !0),
        (t.prototype._compile = function (a, n) {
          var i = this.value;
          return function () {
            return i;
          };
        }),
        (t.prototype.forEach = function (a) {}),
        (t.prototype.map = function (a) {
          return this.clone();
        }),
        (t.prototype.clone = function () {
          return new t(this.value);
        }),
        (t.prototype._toString = function (a) {
          return Ze(this.value, a);
        }),
        (t.prototype.toHTML = function (a) {
          var n = this._toString(a);
          switch (vr(this.value)) {
            case "number":
            case "BigNumber":
            case "Fraction":
              return '<span class="math-number">' + n + "</span>";
            case "string":
              return '<span class="math-string">' + n + "</span>";
            case "boolean":
              return '<span class="math-boolean">' + n + "</span>";
            case "null":
              return '<span class="math-null-symbol">' + n + "</span>";
            case "undefined":
              return '<span class="math-undefined">' + n + "</span>";
            default:
              return '<span class="math-symbol">' + n + "</span>";
          }
        }),
        (t.prototype.toJSON = function () {
          return { mathjs: "ConstantNode", value: this.value };
        }),
        (t.fromJSON = function (a) {
          return new t(a.value);
        }),
        (t.prototype._toTex = function (a) {
          var n = this._toString(a);
          switch (vr(this.value)) {
            case "string":
              return "\\mathtt{" + Ss(n) + "}";
            case "number":
            case "BigNumber":
              {
                if (!isFinite(this.value))
                  return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
                var i = n.toLowerCase().indexOf("e");
                if (i !== -1)
                  return (
                    n.substring(0, i) + "\\cdot10^{" + n.substring(i + 1) + "}"
                  );
              }
              return n;
            case "Fraction":
              return this.value.toLatex();
            default:
              return n;
          }
        }),
        t
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  lC = "FunctionAssignmentNode",
  cC = ["typed", "Node"],
  fC = P(
    lC,
    cC,
    (e) => {
      var { typed: r, Node: t } = e;
      function a(i, c, m) {
        if (!(this instanceof a))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (typeof i != "string")
          throw new TypeError('String expected for parameter "name"');
        if (!Array.isArray(c))
          throw new TypeError(
            'Array containing strings or objects expected for parameter "params"'
          );
        if (!ir(m)) throw new TypeError('Node expected for parameter "expr"');
        if (gh.has(i))
          throw new Error(
            'Illegal function name, "' + i + '" is a reserved keyword'
          );
        (this.name = i),
          (this.params = c.map(function (f) {
            return (f && f.name) || f;
          })),
          (this.types = c.map(function (f) {
            return (f && f.type) || "any";
          })),
          (this.expr = m);
      }
      (a.prototype = new t()),
        (a.prototype.type = "FunctionAssignmentNode"),
        (a.prototype.isFunctionAssignmentNode = !0),
        (a.prototype._compile = function (i, c) {
          var m = Object.create(c);
          Yi(this.params, function (p) {
            m[p] = !0;
          });
          var f = this.expr._compile(i, m),
            u = this.name,
            s = this.params,
            o = Gu(this.types, ","),
            l = u + "(" + Gu(this.params, ", ") + ")";
          return function (v, h, x) {
            var b = {};
            b[o] = function () {
              for (var d = Object.create(h), y = 0; y < s.length; y++)
                d[s[y]] = arguments[y];
              return f(v, d, x);
            };
            var N = r(u, b);
            return (N.syntax = l), v.set(u, N), N;
          };
        }),
        (a.prototype.forEach = function (i) {
          i(this.expr, "expr", this);
        }),
        (a.prototype.map = function (i) {
          var c = this._ifNode(i(this.expr, "expr", this));
          return new a(this.name, this.params.slice(0), c);
        }),
        (a.prototype.clone = function () {
          return new a(this.name, this.params.slice(0), this.expr);
        });
      function n(i, c) {
        var m = fr(i, c),
          f = fr(i.expr, c);
        return c === "all" || (f !== null && f <= m);
      }
      return (
        (a.prototype._toString = function (i) {
          var c = i && i.parenthesis ? i.parenthesis : "keep",
            m = this.expr.toString(i);
          return (
            n(this, c) && (m = "(" + m + ")"),
            this.name + "(" + this.params.join(", ") + ") = " + m
          );
        }),
        (a.prototype.toJSON = function () {
          var i = this.types;
          return {
            mathjs: "FunctionAssignmentNode",
            name: this.name,
            params: this.params.map(function (c, m) {
              return { name: c, type: i[m] };
            }),
            expr: this.expr,
          };
        }),
        (a.fromJSON = function (i) {
          return new a(i.name, i.params, i.expr);
        }),
        (a.prototype.toHTML = function (i) {
          for (
            var c = i && i.parenthesis ? i.parenthesis : "keep", m = [], f = 0;
            f < this.params.length;
            f++
          )
            m.push(
              '<span class="math-symbol math-parameter">' +
                lt(this.params[f]) +
                "</span>"
            );
          var u = this.expr.toHTML(i);
          return (
            n(this, c) &&
              (u =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                u +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            '<span class="math-function">' +
              lt(this.name) +
              '</span><span class="math-parenthesis math-round-parenthesis">(</span>' +
              m.join('<span class="math-separator">,</span>') +
              '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' +
              u
          );
        }),
        (a.prototype._toTex = function (i) {
          var c = i && i.parenthesis ? i.parenthesis : "keep",
            m = this.expr.toTex(i);
          return (
            n(this, c) && (m = "\\left(".concat(m, "\\right)")),
            "\\mathrm{" +
              this.name +
              "}\\left(" +
              this.params.map(bh).join(",") +
              "\\right):=" +
              m
          );
        }),
        a
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  mC = "IndexNode",
  pC = ["Node", "size"],
  vC = P(
    mC,
    pC,
    (e) => {
      var { Node: r, size: t } = e;
      function a(n, i) {
        if (!(this instanceof a))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (
          ((this.dimensions = n),
          (this.dotNotation = i || !1),
          !Array.isArray(n) || !n.every(ir))
        )
          throw new TypeError(
            'Array containing Nodes expected for parameter "dimensions"'
          );
        if (this.dotNotation && !this.isObjectProperty())
          throw new Error("dotNotation only applicable for object properties");
      }
      return (
        (a.prototype = new r()),
        (a.prototype.type = "IndexNode"),
        (a.prototype.isIndexNode = !0),
        (a.prototype._compile = function (n, i) {
          var c = Xt(this.dimensions, function (f, u) {
              var s =
                f.filter((p) => p.isSymbolNode && p.name === "end").length > 0;
              if (s) {
                var o = Object.create(i);
                o.end = !0;
                var l = f._compile(n, o);
                return function (v, h, x) {
                  if (!ze(x) && !sr(x) && !et(x))
                    throw new TypeError(
                      'Cannot resolve "end": context must be a Matrix, Array, or string but is ' +
                        vr(x)
                    );
                  var b = t(x).valueOf(),
                    N = Object.create(h);
                  return (N.end = b[u]), l(v, N, x);
                };
              } else return f._compile(n, i);
            }),
            m = ct(n, "index");
          return function (u, s, o) {
            var l = Xt(c, function (p) {
              return p(u, s, o);
            });
            return m(...l);
          };
        }),
        (a.prototype.forEach = function (n) {
          for (var i = 0; i < this.dimensions.length; i++)
            n(this.dimensions[i], "dimensions[" + i + "]", this);
        }),
        (a.prototype.map = function (n) {
          for (var i = [], c = 0; c < this.dimensions.length; c++)
            i[c] = this._ifNode(
              n(this.dimensions[c], "dimensions[" + c + "]", this)
            );
          return new a(i, this.dotNotation);
        }),
        (a.prototype.clone = function () {
          return new a(this.dimensions.slice(0), this.dotNotation);
        }),
        (a.prototype.isObjectProperty = function () {
          return (
            this.dimensions.length === 1 &&
            lr(this.dimensions[0]) &&
            typeof this.dimensions[0].value == "string"
          );
        }),
        (a.prototype.getObjectProperty = function () {
          return this.isObjectProperty() ? this.dimensions[0].value : null;
        }),
        (a.prototype._toString = function (n) {
          return this.dotNotation
            ? "." + this.getObjectProperty()
            : "[" + this.dimensions.join(", ") + "]";
        }),
        (a.prototype.toJSON = function () {
          return {
            mathjs: "IndexNode",
            dimensions: this.dimensions,
            dotNotation: this.dotNotation,
          };
        }),
        (a.fromJSON = function (n) {
          return new a(n.dimensions, n.dotNotation);
        }),
        (a.prototype.toHTML = function (n) {
          for (var i = [], c = 0; c < this.dimensions.length; c++)
            i[c] = this.dimensions[c].toHTML();
          return this.dotNotation
            ? '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' +
                lt(this.getObjectProperty()) +
                "</span>"
            : '<span class="math-parenthesis math-square-parenthesis">[</span>' +
                i.join('<span class="math-separator">,</span>') +
                '<span class="math-parenthesis math-square-parenthesis">]</span>';
        }),
        (a.prototype._toTex = function (n) {
          var i = this.dimensions.map(function (c) {
            return c.toTex(n);
          });
          return this.dotNotation
            ? "." + this.getObjectProperty()
            : "_{" + i.join(",") + "}";
        }),
        a
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  hC = "ObjectNode",
  dC = ["Node"],
  gC = P(
    hC,
    dC,
    (e) => {
      var { Node: r } = e;
      function t(a) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (
          ((this.properties = a || {}),
          a &&
            (typeof a != "object" ||
              !Object.keys(a).every(function (n) {
                return ir(a[n]);
              })))
        )
          throw new TypeError("Object containing Nodes expected");
      }
      return (
        (t.prototype = new r()),
        (t.prototype.type = "ObjectNode"),
        (t.prototype.isObjectNode = !0),
        (t.prototype._compile = function (a, n) {
          var i = {};
          for (var c in this.properties)
            if (De(this.properties, c)) {
              var m = hi(c),
                f = JSON.parse(m);
              if (!Vs(this.properties, f))
                throw new Error('No access to property "' + f + '"');
              i[f] = this.properties[c]._compile(a, n);
            }
          return function (s, o, l) {
            var p = {};
            for (var v in i) De(i, v) && (p[v] = i[v](s, o, l));
            return p;
          };
        }),
        (t.prototype.forEach = function (a) {
          for (var n in this.properties)
            De(this.properties, n) &&
              a(this.properties[n], "properties[" + hi(n) + "]", this);
        }),
        (t.prototype.map = function (a) {
          var n = {};
          for (var i in this.properties)
            De(this.properties, i) &&
              (n[i] = this._ifNode(
                a(this.properties[i], "properties[" + hi(i) + "]", this)
              ));
          return new t(n);
        }),
        (t.prototype.clone = function () {
          var a = {};
          for (var n in this.properties)
            De(this.properties, n) && (a[n] = this.properties[n]);
          return new t(a);
        }),
        (t.prototype._toString = function (a) {
          var n = [];
          for (var i in this.properties)
            De(this.properties, i) &&
              n.push(hi(i) + ": " + this.properties[i].toString(a));
          return "{" + n.join(", ") + "}";
        }),
        (t.prototype.toJSON = function () {
          return { mathjs: "ObjectNode", properties: this.properties };
        }),
        (t.fromJSON = function (a) {
          return new t(a.properties);
        }),
        (t.prototype.toHTML = function (a) {
          var n = [];
          for (var i in this.properties)
            De(this.properties, i) &&
              n.push(
                '<span class="math-symbol math-property">' +
                  lt(i) +
                  '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' +
                  this.properties[i].toHTML(a)
              );
          return (
            '<span class="math-parenthesis math-curly-parenthesis">{</span>' +
            n.join('<span class="math-separator">,</span>') +
            '<span class="math-parenthesis math-curly-parenthesis">}</span>'
          );
        }),
        (t.prototype._toTex = function (a) {
          var n = [];
          for (var i in this.properties)
            De(this.properties, i) &&
              n.push(
                "\\mathbf{" + i + ":} & " + this.properties[i].toTex(a) + "\\\\"
              );
          return "\\left\\{\\begin{array}{ll}".concat(
            n.join(`
`),
            "\\end{array}\\right\\}"
          );
        }),
        t
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  yC = "OperatorNode",
  bC = ["Node"],
  xC = P(
    yC,
    bC,
    (e) => {
      var { Node: r } = e;
      function t(n, i, c, m, f) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (typeof n != "string")
          throw new TypeError('string expected for parameter "op"');
        if (typeof i != "string")
          throw new TypeError('string expected for parameter "fn"');
        if (!Array.isArray(c) || !c.every(ir))
          throw new TypeError(
            'Array containing Nodes expected for parameter "args"'
          );
        (this.implicit = m === !0),
          (this.isPercentage = f === !0),
          (this.op = n),
          (this.fn = i),
          (this.args = c || []);
      }
      (t.prototype = new r()),
        (t.prototype.type = "OperatorNode"),
        (t.prototype.isOperatorNode = !0),
        (t.prototype._compile = function (n, i) {
          if (typeof this.fn != "string" || !Gs(n, this.fn))
            throw n[this.fn]
              ? new Error('No access to function "' + this.fn + '"')
              : new Error(
                  "Function " +
                    this.fn +
                    ' missing in provided namespace "math"'
                );
          var c = ct(n, this.fn),
            m = Xt(this.args, function (o) {
              return o._compile(n, i);
            });
          if (m.length === 1) {
            var f = m[0];
            return function (l, p, v) {
              return c(f(l, p, v));
            };
          } else if (m.length === 2) {
            var u = m[0],
              s = m[1];
            return function (l, p, v) {
              return c(u(l, p, v), s(l, p, v));
            };
          } else
            return function (l, p, v) {
              return c.apply(
                null,
                Xt(m, function (h) {
                  return h(l, p, v);
                })
              );
            };
        }),
        (t.prototype.forEach = function (n) {
          for (var i = 0; i < this.args.length; i++)
            n(this.args[i], "args[" + i + "]", this);
        }),
        (t.prototype.map = function (n) {
          for (var i = [], c = 0; c < this.args.length; c++)
            i[c] = this._ifNode(n(this.args[c], "args[" + c + "]", this));
          return new t(this.op, this.fn, i, this.implicit, this.isPercentage);
        }),
        (t.prototype.clone = function () {
          return new t(
            this.op,
            this.fn,
            this.args.slice(0),
            this.implicit,
            this.isPercentage
          );
        }),
        (t.prototype.isUnary = function () {
          return this.args.length === 1;
        }),
        (t.prototype.isBinary = function () {
          return this.args.length === 2;
        });
      function a(n, i, c, m, f) {
        var u = fr(n, i),
          s = Oa(n, i);
        if (
          i === "all" ||
          (m.length > 2 &&
            n.getIdentifier() !== "OperatorNode:add" &&
            n.getIdentifier() !== "OperatorNode:multiply")
        )
          return m.map(function (A) {
            switch (A.getContent().type) {
              case "ArrayNode":
              case "ConstantNode":
              case "SymbolNode":
              case "ParenthesisNode":
                return !1;
              default:
                return !0;
            }
          });
        var o;
        switch (m.length) {
          case 0:
            o = [];
            break;
          case 1:
            {
              var l = fr(m[0], i);
              if (f && l !== null) {
                var p, v;
                if (
                  (i === "keep"
                    ? ((p = m[0].getIdentifier()), (v = n.getIdentifier()))
                    : ((p = m[0].getContent().getIdentifier()),
                      (v = n.getContent().getIdentifier())),
                  Bt[u][v].latexLeftParens === !1)
                ) {
                  o = [!1];
                  break;
                }
                if (Bt[l][p].latexParens === !1) {
                  o = [!1];
                  break;
                }
              }
              if (l === null) {
                o = [!1];
                break;
              }
              if (l <= u) {
                o = [!0];
                break;
              }
              o = [!1];
            }
            break;
          case 2:
            {
              var h,
                x = fr(m[0], i),
                b = ko(n, m[0], i);
              x === null
                ? (h = !1)
                : (x === u && s === "right" && !b) || x < u
                ? (h = !0)
                : (h = !1);
              var N,
                d = fr(m[1], i),
                y = ko(n, m[1], i);
              if (
                (d === null
                  ? (N = !1)
                  : (d === u && s === "left" && !y) || d < u
                  ? (N = !0)
                  : (N = !1),
                f)
              ) {
                var w, g, S;
                i === "keep"
                  ? ((w = n.getIdentifier()),
                    (g = n.args[0].getIdentifier()),
                    (S = n.args[1].getIdentifier()))
                  : ((w = n.getContent().getIdentifier()),
                    (g = n.args[0].getContent().getIdentifier()),
                    (S = n.args[1].getContent().getIdentifier())),
                  x !== null &&
                    (Bt[u][w].latexLeftParens === !1 && (h = !1),
                    Bt[x][g].latexParens === !1 && (h = !1)),
                  d !== null &&
                    (Bt[u][w].latexRightParens === !1 && (N = !1),
                    Bt[d][S].latexParens === !1 && (N = !1));
              }
              o = [h, N];
            }
            break;
          default:
            (n.getIdentifier() === "OperatorNode:add" ||
              n.getIdentifier() === "OperatorNode:multiply") &&
              (o = m.map(function (A) {
                var E = fr(A, i),
                  M = ko(n, A, i),
                  B = Oa(A, i);
                return E === null ? !1 : u === E && s === B && !M ? !0 : E < u;
              }));
            break;
        }
        return (
          m.length >= 2 &&
            n.getIdentifier() === "OperatorNode:multiply" &&
            n.implicit &&
            i === "auto" &&
            c === "hide" &&
            (o = m.map(function (A, E) {
              var M = A.getIdentifier() === "ParenthesisNode";
              return !!(o[E] || M);
            })),
          o
        );
      }
      return (
        (t.prototype._toString = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = n && n.implicit ? n.implicit : "hide",
            m = this.args,
            f = a(this, i, c, m, !1);
          if (m.length === 1) {
            var u = Oa(this, i),
              s = m[0].toString(n);
            f[0] && (s = "(" + s + ")");
            var o = /[a-zA-Z]+/.test(this.op);
            return u === "right"
              ? this.op + (o ? " " : "") + s
              : u === "left"
              ? s + (o ? " " : "") + this.op
              : s + this.op;
          } else if (m.length === 2) {
            var l = m[0].toString(n),
              p = m[1].toString(n);
            return (
              f[0] && (l = "(" + l + ")"),
              f[1] && (p = "(" + p + ")"),
              this.implicit &&
              this.getIdentifier() === "OperatorNode:multiply" &&
              c === "hide"
                ? l + " " + p
                : l + " " + this.op + " " + p
            );
          } else if (
            m.length > 2 &&
            (this.getIdentifier() === "OperatorNode:add" ||
              this.getIdentifier() === "OperatorNode:multiply")
          ) {
            var v = m.map(function (h, x) {
              return (h = h.toString(n)), f[x] && (h = "(" + h + ")"), h;
            });
            return this.implicit &&
              this.getIdentifier() === "OperatorNode:multiply" &&
              c === "hide"
              ? v.join(" ")
              : v.join(" " + this.op + " ");
          } else return this.fn + "(" + this.args.join(", ") + ")";
        }),
        (t.prototype.toJSON = function () {
          return {
            mathjs: "OperatorNode",
            op: this.op,
            fn: this.fn,
            args: this.args,
            implicit: this.implicit,
            isPercentage: this.isPercentage,
          };
        }),
        (t.fromJSON = function (n) {
          return new t(n.op, n.fn, n.args, n.implicit, n.isPercentage);
        }),
        (t.prototype.toHTML = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = n && n.implicit ? n.implicit : "hide",
            m = this.args,
            f = a(this, i, c, m, !1);
          if (m.length === 1) {
            var u = Oa(this, i),
              s = m[0].toHTML(n);
            return (
              f[0] &&
                (s =
                  '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                  s +
                  '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              u === "right"
                ? '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' +
                  lt(this.op) +
                  "</span>" +
                  s
                : s +
                  '<span class="math-operator math-unary-operator math-righthand-unary-operator">' +
                  lt(this.op) +
                  "</span>"
            );
          } else if (m.length === 2) {
            var o = m[0].toHTML(n),
              l = m[1].toHTML(n);
            return (
              f[0] &&
                (o =
                  '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                  o +
                  '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              f[1] &&
                (l =
                  '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                  l +
                  '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              this.implicit &&
              this.getIdentifier() === "OperatorNode:multiply" &&
              c === "hide"
                ? o +
                  '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' +
                  l
                : o +
                  '<span class="math-operator math-binary-operator math-explicit-binary-operator">' +
                  lt(this.op) +
                  "</span>" +
                  l
            );
          } else {
            var p = m.map(function (v, h) {
              return (
                (v = v.toHTML(n)),
                f[h] &&
                  (v =
                    '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                    v +
                    '<span class="math-parenthesis math-round-parenthesis">)</span>'),
                v
              );
            });
            return m.length > 2 &&
              (this.getIdentifier() === "OperatorNode:add" ||
                this.getIdentifier() === "OperatorNode:multiply")
              ? this.implicit &&
                this.getIdentifier() === "OperatorNode:multiply" &&
                c === "hide"
                ? p.join(
                    '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>'
                  )
                : p.join(
                    '<span class="math-operator math-binary-operator math-explicit-binary-operator">' +
                      lt(this.op) +
                      "</span>"
                  )
              : '<span class="math-function">' +
                  lt(this.fn) +
                  '</span><span class="math-paranthesis math-round-parenthesis">(</span>' +
                  p.join('<span class="math-separator">,</span>') +
                  '<span class="math-paranthesis math-round-parenthesis">)</span>';
          }
        }),
        (t.prototype._toTex = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = n && n.implicit ? n.implicit : "hide",
            m = this.args,
            f = a(this, i, c, m, !0),
            u = tr[this.fn];
          if (((u = typeof u > "u" ? this.op : u), m.length === 1)) {
            var s = Oa(this, i),
              o = m[0].toTex(n);
            return (
              f[0] && (o = "\\left(".concat(o, "\\right)")),
              s === "right" ? u + o : o + u
            );
          } else if (m.length === 2) {
            var l = m[0],
              p = l.toTex(n);
            f[0] && (p = "\\left(".concat(p, "\\right)"));
            var v = m[1],
              h = v.toTex(n);
            f[1] && (h = "\\left(".concat(h, "\\right)"));
            var x;
            switch (
              (i === "keep"
                ? (x = l.getIdentifier())
                : (x = l.getContent().getIdentifier()),
              this.getIdentifier())
            ) {
              case "OperatorNode:divide":
                return u + "{" + p + "}{" + h + "}";
              case "OperatorNode:pow":
                switch (((p = "{" + p + "}"), (h = "{" + h + "}"), x)) {
                  case "ConditionalNode":
                  case "OperatorNode:divide":
                    p = "\\left(".concat(p, "\\right)");
                }
                break;
              case "OperatorNode:multiply":
                if (this.implicit && c === "hide") return p + "~" + h;
            }
            return p + u + h;
          } else if (
            m.length > 2 &&
            (this.getIdentifier() === "OperatorNode:add" ||
              this.getIdentifier() === "OperatorNode:multiply")
          ) {
            var b = m.map(function (N, d) {
              return (
                (N = N.toTex(n)),
                f[d] && (N = "\\left(".concat(N, "\\right)")),
                N
              );
            });
            return this.getIdentifier() === "OperatorNode:multiply" &&
              this.implicit
              ? b.join("~")
              : b.join(u);
          } else
            return (
              "\\mathrm{" +
              this.fn +
              "}\\left(" +
              m
                .map(function (N) {
                  return N.toTex(n);
                })
                .join(",") +
              "\\right)"
            );
        }),
        (t.prototype.getIdentifier = function () {
          return this.type + ":" + this.fn;
        }),
        t
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  wC = "ParenthesisNode",
  NC = ["Node"],
  MC = P(
    wC,
    NC,
    (e) => {
      var { Node: r } = e;
      function t(a) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!ir(a))
          throw new TypeError('Node expected for parameter "content"');
        this.content = a;
      }
      return (
        (t.prototype = new r()),
        (t.prototype.type = "ParenthesisNode"),
        (t.prototype.isParenthesisNode = !0),
        (t.prototype._compile = function (a, n) {
          return this.content._compile(a, n);
        }),
        (t.prototype.getContent = function () {
          return this.content.getContent();
        }),
        (t.prototype.forEach = function (a) {
          a(this.content, "content", this);
        }),
        (t.prototype.map = function (a) {
          var n = a(this.content, "content", this);
          return new t(n);
        }),
        (t.prototype.clone = function () {
          return new t(this.content);
        }),
        (t.prototype._toString = function (a) {
          return !a || (a && !a.parenthesis) || (a && a.parenthesis === "keep")
            ? "(" + this.content.toString(a) + ")"
            : this.content.toString(a);
        }),
        (t.prototype.toJSON = function () {
          return { mathjs: "ParenthesisNode", content: this.content };
        }),
        (t.fromJSON = function (a) {
          return new t(a.content);
        }),
        (t.prototype.toHTML = function (a) {
          return !a || (a && !a.parenthesis) || (a && a.parenthesis === "keep")
            ? '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                this.content.toHTML(a) +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'
            : this.content.toHTML(a);
        }),
        (t.prototype._toTex = function (a) {
          return !a || (a && !a.parenthesis) || (a && a.parenthesis === "keep")
            ? "\\left(".concat(this.content.toTex(a), "\\right)")
            : this.content.toTex(a);
        }),
        t
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  AC = "RangeNode",
  SC = ["Node"],
  EC = P(
    AC,
    SC,
    (e) => {
      var { Node: r } = e;
      function t(n, i, c) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!ir(n)) throw new TypeError("Node expected");
        if (!ir(i)) throw new TypeError("Node expected");
        if (c && !ir(c)) throw new TypeError("Node expected");
        if (arguments.length > 3) throw new Error("Too many arguments");
        (this.start = n), (this.end = i), (this.step = c || null);
      }
      (t.prototype = new r()),
        (t.prototype.type = "RangeNode"),
        (t.prototype.isRangeNode = !0),
        (t.prototype.needsEnd = function () {
          var n = this.filter(function (i) {
            return qr(i) && i.name === "end";
          });
          return n.length > 0;
        }),
        (t.prototype._compile = function (n, i) {
          var c = n.range,
            m = this.start._compile(n, i),
            f = this.end._compile(n, i);
          if (this.step) {
            var u = this.step._compile(n, i);
            return function (o, l, p) {
              return c(m(o, l, p), f(o, l, p), u(o, l, p));
            };
          } else
            return function (o, l, p) {
              return c(m(o, l, p), f(o, l, p));
            };
        }),
        (t.prototype.forEach = function (n) {
          n(this.start, "start", this),
            n(this.end, "end", this),
            this.step && n(this.step, "step", this);
        }),
        (t.prototype.map = function (n) {
          return new t(
            this._ifNode(n(this.start, "start", this)),
            this._ifNode(n(this.end, "end", this)),
            this.step && this._ifNode(n(this.step, "step", this))
          );
        }),
        (t.prototype.clone = function () {
          return new t(this.start, this.end, this.step && this.step);
        });
      function a(n, i) {
        var c = fr(n, i),
          m = {},
          f = fr(n.start, i);
        if (((m.start = (f !== null && f <= c) || i === "all"), n.step)) {
          var u = fr(n.step, i);
          m.step = (u !== null && u <= c) || i === "all";
        }
        var s = fr(n.end, i);
        return (m.end = (s !== null && s <= c) || i === "all"), m;
      }
      return (
        (t.prototype._toString = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = a(this, i),
            m,
            f = this.start.toString(n);
          if ((c.start && (f = "(" + f + ")"), (m = f), this.step)) {
            var u = this.step.toString(n);
            c.step && (u = "(" + u + ")"), (m += ":" + u);
          }
          var s = this.end.toString(n);
          return c.end && (s = "(" + s + ")"), (m += ":" + s), m;
        }),
        (t.prototype.toJSON = function () {
          return {
            mathjs: "RangeNode",
            start: this.start,
            end: this.end,
            step: this.step,
          };
        }),
        (t.fromJSON = function (n) {
          return new t(n.start, n.end, n.step);
        }),
        (t.prototype.toHTML = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = a(this, i),
            m,
            f = this.start.toHTML(n);
          if (
            (c.start &&
              (f =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                f +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            (m = f),
            this.step)
          ) {
            var u = this.step.toHTML(n);
            c.step &&
              (u =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                u +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              (m +=
                '<span class="math-operator math-range-operator">:</span>' + u);
          }
          var s = this.end.toHTML(n);
          return (
            c.end &&
              (s =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                s +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            (m +=
              '<span class="math-operator math-range-operator">:</span>' + s),
            m
          );
        }),
        (t.prototype._toTex = function (n) {
          var i = n && n.parenthesis ? n.parenthesis : "keep",
            c = a(this, i),
            m = this.start.toTex(n);
          if ((c.start && (m = "\\left(".concat(m, "\\right)")), this.step)) {
            var f = this.step.toTex(n);
            c.step && (f = "\\left(".concat(f, "\\right)")), (m += ":" + f);
          }
          var u = this.end.toTex(n);
          return (
            c.end && (u = "\\left(".concat(u, "\\right)")), (m += ":" + u), m
          );
        }),
        t
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  CC = "RelationalNode",
  $C = ["Node"],
  OC = P(
    CC,
    $C,
    (e) => {
      var { Node: r } = e;
      function t(a, n) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!Array.isArray(a))
          throw new TypeError("Parameter conditionals must be an array");
        if (!Array.isArray(n))
          throw new TypeError("Parameter params must be an array");
        if (a.length !== n.length - 1)
          throw new TypeError(
            "Parameter params must contain exactly one more element than parameter conditionals"
          );
        (this.conditionals = a), (this.params = n);
      }
      return (
        (t.prototype = new r()),
        (t.prototype.type = "RelationalNode"),
        (t.prototype.isRelationalNode = !0),
        (t.prototype._compile = function (a, n) {
          var i = this,
            c = this.params.map((m) => m._compile(a, n));
          return function (f, u, s) {
            for (
              var o, l = c[0](f, u, s), p = 0;
              p < i.conditionals.length;
              p++
            ) {
              (o = l), (l = c[p + 1](f, u, s));
              var v = ct(a, i.conditionals[p]);
              if (!v(o, l)) return !1;
            }
            return !0;
          };
        }),
        (t.prototype.forEach = function (a) {
          this.params.forEach((n, i) => a(n, "params[" + i + "]", this), this);
        }),
        (t.prototype.map = function (a) {
          return new t(
            this.conditionals.slice(),
            this.params.map(
              (n, i) => this._ifNode(a(n, "params[" + i + "]", this)),
              this
            )
          );
        }),
        (t.prototype.clone = function () {
          return new t(this.conditionals, this.params);
        }),
        (t.prototype._toString = function (a) {
          for (
            var n = a && a.parenthesis ? a.parenthesis : "keep",
              i = fr(this, n),
              c = this.params.map(function (s, o) {
                var l = fr(s, n);
                return n === "all" || (l !== null && l <= i)
                  ? "(" + s.toString(a) + ")"
                  : s.toString(a);
              }),
              m = {
                equal: "==",
                unequal: "!=",
                smaller: "<",
                larger: ">",
                smallerEq: "<=",
                largerEq: ">=",
              },
              f = c[0],
              u = 0;
            u < this.conditionals.length;
            u++
          )
            f += " " + m[this.conditionals[u]] + " " + c[u + 1];
          return f;
        }),
        (t.prototype.toJSON = function () {
          return {
            mathjs: "RelationalNode",
            conditionals: this.conditionals,
            params: this.params,
          };
        }),
        (t.fromJSON = function (a) {
          return new t(a.conditionals, a.params);
        }),
        (t.prototype.toHTML = function (a) {
          for (
            var n = a && a.parenthesis ? a.parenthesis : "keep",
              i = fr(this, n),
              c = this.params.map(function (s, o) {
                var l = fr(s, n);
                return n === "all" || (l !== null && l <= i)
                  ? '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                      s.toHTML(a) +
                      '<span class="math-parenthesis math-round-parenthesis">)</span>'
                  : s.toHTML(a);
              }),
              m = {
                equal: "==",
                unequal: "!=",
                smaller: "<",
                larger: ">",
                smallerEq: "<=",
                largerEq: ">=",
              },
              f = c[0],
              u = 0;
            u < this.conditionals.length;
            u++
          )
            f +=
              '<span class="math-operator math-binary-operator math-explicit-binary-operator">' +
              lt(m[this.conditionals[u]]) +
              "</span>" +
              c[u + 1];
          return f;
        }),
        (t.prototype._toTex = function (a) {
          for (
            var n = a && a.parenthesis ? a.parenthesis : "keep",
              i = fr(this, n),
              c = this.params.map(function (u, s) {
                var o = fr(u, n);
                return n === "all" || (o !== null && o <= i)
                  ? "\\left(" + u.toTex(a) + "\right)"
                  : u.toTex(a);
              }),
              m = c[0],
              f = 0;
            f < this.conditionals.length;
            f++
          )
            m += tr[this.conditionals[f]] + c[f + 1];
          return m;
        }),
        t
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  TC = "SymbolNode",
  DC = ["math", "?Unit", "Node"],
  BC = P(
    TC,
    DC,
    (e) => {
      var { math: r, Unit: t, Node: a } = e;
      function n(c) {
        return t ? t.isValuelessUnit(c) : !1;
      }
      function i(c) {
        if (!(this instanceof i))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (typeof c != "string")
          throw new TypeError('String expected for parameter "name"');
        this.name = c;
      }
      return (
        (i.prototype = new a()),
        (i.prototype.type = "SymbolNode"),
        (i.prototype.isSymbolNode = !0),
        (i.prototype._compile = function (c, m) {
          var f = this.name;
          if (m[f] === !0)
            return function (s, o, l) {
              return o[f];
            };
          if (f in c)
            return function (s, o, l) {
              return s.has(f) ? s.get(f) : ct(c, f);
            };
          var u = n(f);
          return function (s, o, l) {
            return s.has(f)
              ? s.get(f)
              : u
              ? new t(null, f)
              : i.onUndefinedSymbol(f);
          };
        }),
        (i.prototype.forEach = function (c) {}),
        (i.prototype.map = function (c) {
          return this.clone();
        }),
        (i.onUndefinedSymbol = function (c) {
          throw new Error("Undefined symbol " + c);
        }),
        (i.prototype.clone = function () {
          return new i(this.name);
        }),
        (i.prototype._toString = function (c) {
          return this.name;
        }),
        (i.prototype.toHTML = function (c) {
          var m = lt(this.name);
          return m === "true" || m === "false"
            ? '<span class="math-symbol math-boolean">' + m + "</span>"
            : m === "i"
            ? '<span class="math-symbol math-imaginary-symbol">' + m + "</span>"
            : m === "Infinity"
            ? '<span class="math-symbol math-infinity-symbol">' + m + "</span>"
            : m === "NaN"
            ? '<span class="math-symbol math-nan-symbol">' + m + "</span>"
            : m === "null"
            ? '<span class="math-symbol math-null-symbol">' + m + "</span>"
            : m === "undefined"
            ? '<span class="math-symbol math-undefined-symbol">' + m + "</span>"
            : '<span class="math-symbol">' + m + "</span>";
        }),
        (i.prototype.toJSON = function () {
          return { mathjs: "SymbolNode", name: this.name };
        }),
        (i.fromJSON = function (c) {
          return new i(c.name);
        }),
        (i.prototype._toTex = function (c) {
          var m = !1;
          typeof r[this.name] > "u" && n(this.name) && (m = !0);
          var f = bh(this.name, m);
          return f[0] === "\\" ? f : " " + f;
        }),
        i
      );
    },
    { isClass: !0, isNode: !0 }
  );
function Ia(e) {
  for (
    var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), a = 1;
    a < r;
    a++
  )
    t[a - 1] = arguments[a];
  return typeof e.createSubScope == "function"
    ? Hu(e.createSubScope(), ...t)
    : Hu(Gt(), e, ...t);
}
var _C = "FunctionNode",
  IC = ["math", "Node", "SymbolNode"],
  RC = P(
    _C,
    IC,
    (e) => {
      var { math: r, Node: t, SymbolNode: a } = e;
      function n(u, s) {
        if (!(this instanceof n))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if ((typeof u == "string" && (u = new a(u)), !ir(u)))
          throw new TypeError('Node expected as parameter "fn"');
        if (!Array.isArray(s) || !s.every(ir))
          throw new TypeError(
            'Array containing Nodes expected for parameter "args"'
          );
        (this.fn = u),
          (this.args = s || []),
          Object.defineProperty(this, "name", {
            get: function () {
              return this.fn.name || "";
            }.bind(this),
            set: function () {
              throw new Error("Cannot assign a new name, name is read-only");
            },
          });
      }
      (n.prototype = new t()),
        (n.prototype.type = "FunctionNode"),
        (n.prototype.isFunctionNode = !0);
      var i = (u) => Ze(u, { truncate: 78 });
      (n.prototype._compile = function (u, s) {
        if (!(this instanceof n)) throw new TypeError("No valid FunctionNode");
        var o = this.args.map((A) => A._compile(u, s));
        if (qr(this.fn)) {
          var l = this.fn.name;
          if (s[l]) {
            var b = this.args;
            return function (E, M, B) {
              var C = M[l];
              if (typeof C != "function")
                throw new TypeError(
                  "Argument '"
                    .concat(l, "' was not a function; received: ")
                    .concat(i(C))
                );
              if (C.rawArgs) return C(b, u, Ia(E, M), E);
              var _ = o.map((z) => z(E, M, B));
              return C.apply(C, _);
            };
          } else {
            var p = l in u ? ct(u, l) : void 0,
              v = typeof p == "function" && p.rawArgs === !0,
              h = (A) => {
                var E;
                if (A.has(l)) E = A.get(l);
                else if (l in u) E = ct(u, l);
                else return n.onUndefinedFunction(l);
                if (typeof E == "function") return E;
                throw new TypeError(
                  "'"
                    .concat(
                      l,
                      `' is not a function; its value is:
  `
                    )
                    .concat(i(E))
                );
              };
            if (v) {
              var x = this.args;
              return function (E, M, B) {
                var C = h(E);
                return C(x, u, Ia(E, M), E);
              };
            } else
              switch (o.length) {
                case 0:
                  return function (E, M, B) {
                    var C = h(E);
                    return C();
                  };
                case 1:
                  return function (E, M, B) {
                    var C = h(E),
                      _ = o[0];
                    return C(_(E, M, B));
                  };
                case 2:
                  return function (E, M, B) {
                    var C = h(E),
                      _ = o[0],
                      z = o[1];
                    return C(_(E, M, B), z(E, M, B));
                  };
                default:
                  return function (E, M, B) {
                    var C = h(E),
                      _ = o.map((z) => z(E, M, B));
                    return C(..._);
                  };
              }
          }
        } else if (
          En(this.fn) &&
          ga(this.fn.index) &&
          this.fn.index.isObjectProperty()
        ) {
          var N = this.fn.object._compile(u, s),
            d = this.fn.index.getObjectProperty(),
            y = this.args;
          return function (E, M, B) {
            var C = N(E, M, B);
            c1(C, d);
            var _ = C[d] && C[d].rawArgs;
            if (_) return C[d](y, u, Ia(E, M), E);
            var z = o.map((I) => I(E, M, B));
            return C[d].apply(C, z);
          };
        } else {
          var w = this.fn.toString(),
            g = this.fn._compile(u, s),
            S = this.args;
          return function (E, M, B) {
            var C = g(E, M, B);
            if (typeof C != "function")
              throw new TypeError(
                "Expression '".concat(
                  w,
                  "' did not evaluate to a function; value is:"
                ) +
                  `
  `.concat(i(C))
              );
            if (C.rawArgs) return C(S, u, Ia(E, M), E);
            var _ = o.map((z) => z(E, M, B));
            return C.apply(C, _);
          };
        }
      }),
        (n.prototype.forEach = function (u) {
          u(this.fn, "fn", this);
          for (var s = 0; s < this.args.length; s++)
            u(this.args[s], "args[" + s + "]", this);
        }),
        (n.prototype.map = function (u) {
          for (
            var s = this._ifNode(u(this.fn, "fn", this)), o = [], l = 0;
            l < this.args.length;
            l++
          )
            o[l] = this._ifNode(u(this.args[l], "args[" + l + "]", this));
          return new n(s, o);
        }),
        (n.prototype.clone = function () {
          return new n(this.fn, this.args.slice(0));
        }),
        (n.onUndefinedFunction = function (u) {
          throw new Error("Undefined function " + u);
        });
      var c = n.prototype.toString;
      (n.prototype.toString = function (u) {
        var s,
          o = this.fn.toString(u);
        return (
          u &&
            typeof u.handler == "object" &&
            De(u.handler, o) &&
            (s = u.handler[o](this, u)),
          typeof s < "u" ? s : c.call(this, u)
        );
      }),
        (n.prototype._toString = function (u) {
          var s = this.args.map(function (l) {
              return l.toString(u);
            }),
            o = Ja(this.fn)
              ? "(" + this.fn.toString(u) + ")"
              : this.fn.toString(u);
          return o + "(" + s.join(", ") + ")";
        }),
        (n.prototype.toJSON = function () {
          return { mathjs: "FunctionNode", fn: this.fn, args: this.args };
        }),
        (n.fromJSON = function (u) {
          return new n(u.fn, u.args);
        }),
        (n.prototype.toHTML = function (u) {
          var s = this.args.map(function (o) {
            return o.toHTML(u);
          });
          return (
            '<span class="math-function">' +
            lt(this.fn) +
            '</span><span class="math-paranthesis math-round-parenthesis">(</span>' +
            s.join('<span class="math-separator">,</span>') +
            '<span class="math-paranthesis math-round-parenthesis">)</span>'
          );
        });
      function m(u, s, o) {
        for (
          var l = "",
            p = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi,
            v = 0,
            h;
          (h = p.exec(u)) !== null;

        )
          if (((l += u.substring(v, h.index)), (v = h.index), h[0] === "$$"))
            (l += "$"), v++;
          else {
            v += h[0].length;
            var x = s[h[1]];
            if (!x)
              throw new ReferenceError(
                "Template: Property " + h[1] + " does not exist."
              );
            if (h[2] === void 0)
              switch (typeof x) {
                case "string":
                  l += x;
                  break;
                case "object":
                  if (ir(x)) l += x.toTex(o);
                  else if (Array.isArray(x))
                    l += x
                      .map(function (b, N) {
                        if (ir(b)) return b.toTex(o);
                        throw new TypeError(
                          "Template: " + h[1] + "[" + N + "] is not a Node."
                        );
                      })
                      .join(",");
                  else
                    throw new TypeError(
                      "Template: " +
                        h[1] +
                        " has to be a Node, String or array of Nodes"
                    );
                  break;
                default:
                  throw new TypeError(
                    "Template: " +
                      h[1] +
                      " has to be a Node, String or array of Nodes"
                  );
              }
            else if (ir(x[h[2]] && x[h[2]])) l += x[h[2]].toTex(o);
            else
              throw new TypeError(
                "Template: " + h[1] + "[" + h[2] + "] is not a Node."
              );
          }
        return (l += u.slice(v)), l;
      }
      var f = n.prototype.toTex;
      return (
        (n.prototype.toTex = function (u) {
          var s;
          return (
            u &&
              typeof u.handler == "object" &&
              De(u.handler, this.name) &&
              (s = u.handler[this.name](this, u)),
            typeof s < "u" ? s : f.call(this, u)
          );
        }),
        (n.prototype._toTex = function (u) {
          var s = this.args.map(function (p) {
              return p.toTex(u);
            }),
            o;
          Jf[this.name] && (o = Jf[this.name]),
            r[this.name] &&
              (typeof r[this.name].toTex == "function" ||
                typeof r[this.name].toTex == "object" ||
                typeof r[this.name].toTex == "string") &&
              (o = r[this.name].toTex);
          var l;
          switch (typeof o) {
            case "function":
              l = o(this, u);
              break;
            case "string":
              l = m(o, this, u);
              break;
            case "object":
              switch (typeof o[s.length]) {
                case "function":
                  l = o[s.length](this, u);
                  break;
                case "string":
                  l = m(o[s.length], this, u);
                  break;
              }
          }
          return typeof l < "u" ? l : m(iC, this, u);
        }),
        (n.prototype.getIdentifier = function () {
          return this.type + ":" + this.name;
        }),
        n
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  Xf = "parse",
  FC = [
    "typed",
    "numeric",
    "config",
    "AccessorNode",
    "ArrayNode",
    "AssignmentNode",
    "BlockNode",
    "ConditionalNode",
    "ConstantNode",
    "FunctionAssignmentNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "ParenthesisNode",
    "RangeNode",
    "RelationalNode",
    "SymbolNode",
  ],
  PC = P(Xf, FC, (e) => {
    var {
        typed: r,
        numeric: t,
        config: a,
        AccessorNode: n,
        ArrayNode: i,
        AssignmentNode: c,
        BlockNode: m,
        ConditionalNode: f,
        ConstantNode: u,
        FunctionAssignmentNode: s,
        FunctionNode: o,
        IndexNode: l,
        ObjectNode: p,
        OperatorNode: v,
        ParenthesisNode: h,
        RangeNode: x,
        RelationalNode: b,
        SymbolNode: N,
      } = e,
      d = r(Xf, {
        string: function (X) {
          return H(X, {});
        },
        "Array | Matrix": function (X) {
          return y(X, {});
        },
        "string, Object": function (X, ue) {
          var we = ue.nodes !== void 0 ? ue.nodes : {};
          return H(X, we);
        },
        "Array | Matrix, Object": y,
      });
    function y($) {
      var X =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        ue = X.nodes !== void 0 ? X.nodes : {};
      return Oe($, function (we) {
        if (typeof we != "string") throw new TypeError("String expected");
        return H(we, ue);
      });
    }
    var w = { NULL: 0, DELIMITER: 1, NUMBER: 2, SYMBOL: 3, UNKNOWN: 4 },
      g = {
        ",": !0,
        "(": !0,
        ")": !0,
        "[": !0,
        "]": !0,
        "{": !0,
        "}": !0,
        '"': !0,
        "'": !0,
        ";": !0,
        "+": !0,
        "-": !0,
        "*": !0,
        ".*": !0,
        "/": !0,
        "./": !0,
        "%": !0,
        "^": !0,
        ".^": !0,
        "~": !0,
        "!": !0,
        "&": !0,
        "|": !0,
        "^|": !0,
        "=": !0,
        ":": !0,
        "?": !0,
        "==": !0,
        "!=": !0,
        "<": !0,
        ">": !0,
        "<=": !0,
        ">=": !0,
        "<<": !0,
        ">>": !0,
        ">>>": !0,
      },
      S = { mod: !0, to: !0, in: !0, and: !0, xor: !0, or: !0, not: !0 },
      A = { true: !0, false: !1, null: null, undefined: void 0 },
      E = ["NaN", "Infinity"];
    function M() {
      return {
        extraNodes: {},
        expression: "",
        comment: "",
        index: 0,
        token: "",
        tokenType: w.NULL,
        nestingLevel: 0,
        conditionalLevel: null,
      };
    }
    function B($, X) {
      return $.expression.substr($.index, X);
    }
    function C($) {
      return B($, 1);
    }
    function _($) {
      $.index++;
    }
    function z($) {
      return $.expression.charAt($.index - 1);
    }
    function I($) {
      return $.expression.charAt($.index + 1);
    }
    function T($) {
      for ($.tokenType = w.NULL, $.token = "", $.comment = ""; ; ) {
        if (C($) === "#")
          for (
            ;
            C($) !==
              `
` && C($) !== "";

          )
            ($.comment += C($)), _($);
        if (d.isWhitespace(C($), $.nestingLevel)) _($);
        else break;
      }
      if (C($) === "") {
        $.tokenType = w.DELIMITER;
        return;
      }
      if (
        C($) ===
          `
` &&
        !$.nestingLevel
      ) {
        ($.tokenType = w.DELIMITER), ($.token = C($)), _($);
        return;
      }
      var X = C($),
        ue = B($, 2),
        we = B($, 3);
      if (we.length === 3 && g[we]) {
        ($.tokenType = w.DELIMITER), ($.token = we), _($), _($), _($);
        return;
      }
      if (ue.length === 2 && g[ue]) {
        ($.tokenType = w.DELIMITER), ($.token = ue), _($), _($);
        return;
      }
      if (g[X]) {
        ($.tokenType = w.DELIMITER), ($.token = X), _($);
        return;
      }
      if (d.isDigitDot(X)) {
        $.tokenType = w.NUMBER;
        var ke = B($, 2);
        if (ke === "0b" || ke === "0o" || ke === "0x") {
          for (
            $.token += C($), _($), $.token += C($), _($);
            d.isHexDigit(C($));

          )
            ($.token += C($)), _($);
          if (C($) === ".")
            for ($.token += ".", _($); d.isHexDigit(C($)); )
              ($.token += C($)), _($);
          else if (C($) === "i")
            for ($.token += "i", _($); d.isDigit(C($)); )
              ($.token += C($)), _($);
          return;
        }
        if (C($) === ".") {
          if ((($.token += C($)), _($), !d.isDigit(C($)))) {
            $.tokenType = w.DELIMITER;
            return;
          }
        } else {
          for (; d.isDigit(C($)); ) ($.token += C($)), _($);
          d.isDecimalMark(C($), I($)) && (($.token += C($)), _($));
        }
        for (; d.isDigit(C($)); ) ($.token += C($)), _($);
        if (C($) === "E" || C($) === "e") {
          if (d.isDigit(I($)) || I($) === "-" || I($) === "+") {
            if (
              (($.token += C($)),
              _($),
              (C($) === "+" || C($) === "-") && (($.token += C($)), _($)),
              !d.isDigit(C($)))
            )
              throw rr($, 'Digit expected, got "' + C($) + '"');
            for (; d.isDigit(C($)); ) ($.token += C($)), _($);
            if (d.isDecimalMark(C($), I($)))
              throw rr($, 'Digit expected, got "' + C($) + '"');
          } else if (I($) === ".")
            throw (_($), rr($, 'Digit expected, got "' + C($) + '"'));
        }
        return;
      }
      if (d.isAlpha(C($), z($), I($))) {
        for (; d.isAlpha(C($), z($), I($)) || d.isDigit(C($)); )
          ($.token += C($)), _($);
        De(S, $.token) ? ($.tokenType = w.DELIMITER) : ($.tokenType = w.SYMBOL);
        return;
      }
      for ($.tokenType = w.UNKNOWN; C($) !== ""; ) ($.token += C($)), _($);
      throw rr($, 'Syntax error in part "' + $.token + '"');
    }
    function D($) {
      do T($);
      while (
        $.token ===
        `
`
      );
    }
    function Z($) {
      $.nestingLevel++;
    }
    function O($) {
      $.nestingLevel--;
    }
    (d.isAlpha = function (X, ue, we) {
      return (
        d.isValidLatinOrGreek(X) ||
        d.isValidMathSymbol(X, we) ||
        d.isValidMathSymbol(ue, X)
      );
    }),
      (d.isValidLatinOrGreek = function (X) {
        return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(X);
      }),
      (d.isValidMathSymbol = function (X, ue) {
        return (
          /^[\uD835]$/.test(X) &&
          /^[\uDC00-\uDFFF]$/.test(ue) &&
          /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(
            ue
          )
        );
      }),
      (d.isWhitespace = function (X, ue) {
        return (
          X === " " ||
          X === "	" ||
          (X ===
            `
` &&
            ue > 0)
        );
      }),
      (d.isDecimalMark = function (X, ue) {
        return X === "." && ue !== "/" && ue !== "*" && ue !== "^";
      }),
      (d.isDigitDot = function (X) {
        return (X >= "0" && X <= "9") || X === ".";
      }),
      (d.isDigit = function (X) {
        return X >= "0" && X <= "9";
      }),
      (d.isHexDigit = function (X) {
        return (
          (X >= "0" && X <= "9") ||
          (X >= "a" && X <= "f") ||
          (X >= "A" && X <= "F")
        );
      });
    function H($, X) {
      var ue = M();
      Lr(ue, { expression: $, extraNodes: X }), T(ue);
      var we = Q(ue);
      if (ue.token !== "")
        throw ue.tokenType === w.DELIMITER
          ? $t(ue, "Unexpected operator " + ue.token)
          : rr(ue, 'Unexpected part "' + ue.token + '"');
      return we;
    }
    function Q($) {
      var X,
        ue = [],
        we;
      for (
        $.token !== "" &&
        $.token !==
          `
` &&
        $.token !== ";" &&
        ((X = te($)), (X.comment = $.comment));
        $.token ===
          `
` || $.token === ";";

      )
        ue.length === 0 &&
          X &&
          ((we = $.token !== ";"), ue.push({ node: X, visible: we })),
          T($),
          $.token !==
            `
` &&
            $.token !== ";" &&
            $.token !== "" &&
            ((X = te($)),
            (X.comment = $.comment),
            (we = $.token !== ";"),
            ue.push({ node: X, visible: we }));
      return ue.length > 0
        ? new m(ue)
        : (X || ((X = new u(void 0)), (X.comment = $.comment)), X);
    }
    function te($) {
      var X,
        ue,
        we,
        ke,
        Ye = J($);
      if ($.token === "=") {
        if (qr(Ye))
          return (X = Ye.name), D($), (we = te($)), new c(new N(X), we);
        if (En(Ye)) return D($), (we = te($)), new c(Ye.object, Ye.index, we);
        if (
          Cn(Ye) &&
          qr(Ye.fn) &&
          ((ke = !0),
          (ue = []),
          (X = Ye.name),
          Ye.args.forEach(function (Or, Ca) {
            qr(Or) ? (ue[Ca] = Or.name) : (ke = !1);
          }),
          ke)
        )
          return D($), (we = te($)), new s(X, ue, we);
        throw rr($, "Invalid left hand side of assignment operator =");
      }
      return Ye;
    }
    function J($) {
      for (var X = re($); $.token === "?"; ) {
        var ue = $.conditionalLevel;
        ($.conditionalLevel = $.nestingLevel), D($);
        var we = X,
          ke = te($);
        if ($.token !== ":")
          throw rr($, "False part of conditional expression expected");
        ($.conditionalLevel = null), D($);
        var Ye = te($);
        (X = new f(we, ke, Ye)), ($.conditionalLevel = ue);
      }
      return X;
    }
    function re($) {
      for (var X = oe($); $.token === "or"; )
        D($), (X = new v("or", "or", [X, oe($)]));
      return X;
    }
    function oe($) {
      for (var X = ae($); $.token === "xor"; )
        D($), (X = new v("xor", "xor", [X, ae($)]));
      return X;
    }
    function ae($) {
      for (var X = ce($); $.token === "and"; )
        D($), (X = new v("and", "and", [X, ce($)]));
      return X;
    }
    function ce($) {
      for (var X = se($); $.token === "|"; )
        D($), (X = new v("|", "bitOr", [X, se($)]));
      return X;
    }
    function se($) {
      for (var X = pe($); $.token === "^|"; )
        D($), (X = new v("^|", "bitXor", [X, pe($)]));
      return X;
    }
    function pe($) {
      for (var X = ne($); $.token === "&"; )
        D($), (X = new v("&", "bitAnd", [X, ne($)]));
      return X;
    }
    function ne($) {
      for (
        var X = [Ae($)],
          ue = [],
          we = {
            "==": "equal",
            "!=": "unequal",
            "<": "smaller",
            ">": "larger",
            "<=": "smallerEq",
            ">=": "largerEq",
          };
        De(we, $.token);

      ) {
        var ke = { name: $.token, fn: we[$.token] };
        ue.push(ke), D($), X.push(Ae($));
      }
      return X.length === 1
        ? X[0]
        : X.length === 2
        ? new v(ue[0].name, ue[0].fn, X)
        : new b(
            ue.map((Ye) => Ye.fn),
            X
          );
    }
    function Ae($) {
      var X, ue, we, ke;
      X = Ce($);
      for (
        var Ye = {
          "<<": "leftShift",
          ">>": "rightArithShift",
          ">>>": "rightLogShift",
        };
        De(Ye, $.token);

      )
        (ue = $.token),
          (we = Ye[ue]),
          D($),
          (ke = [X, Ce($)]),
          (X = new v(ue, we, ke));
      return X;
    }
    function Ce($) {
      var X, ue, we, ke;
      X = ge($);
      for (var Ye = { to: "to", in: "to" }; De(Ye, $.token); )
        (ue = $.token),
          (we = Ye[ue]),
          D($),
          ue === "in" && $.token === ""
            ? (X = new v("*", "multiply", [X, new N("in")], !0))
            : ((ke = [X, ge($)]), (X = new v(ue, we, ke)));
      return X;
    }
    function ge($) {
      var X,
        ue = [];
      if (
        ($.token === ":" ? (X = new u(1)) : (X = Se($)),
        $.token === ":" && $.conditionalLevel !== $.nestingLevel)
      ) {
        for (ue.push(X); $.token === ":" && ue.length < 3; )
          D($),
            $.token === ")" ||
            $.token === "]" ||
            $.token === "," ||
            $.token === ""
              ? ue.push(new N("end"))
              : ue.push(Se($));
        ue.length === 3
          ? (X = new x(ue[0], ue[2], ue[1]))
          : (X = new x(ue[0], ue[1]));
      }
      return X;
    }
    function Se($) {
      var X, ue, we, ke;
      X = q($);
      for (var Ye = { "+": "add", "-": "subtract" }; De(Ye, $.token); ) {
        (ue = $.token), (we = Ye[ue]), D($);
        var Or = q($);
        Or.isPercentage
          ? (ke = [X, new v("*", "multiply", [X, Or])])
          : (ke = [X, Or]),
          (X = new v(ue, we, ke));
      }
      return X;
    }
    function q($) {
      var X, ue, we, ke;
      (X = Y($)), (ue = X);
      for (
        var Ye = {
          "*": "multiply",
          ".*": "dotMultiply",
          "/": "divide",
          "./": "dotDivide",
        };
        De(Ye, $.token);

      )
        (we = $.token),
          (ke = Ye[we]),
          D($),
          (ue = Y($)),
          (X = new v(we, ke, [X, ue]));
      return X;
    }
    function Y($) {
      var X, ue;
      for (
        X = V($), ue = X;
        $.tokenType === w.SYMBOL ||
        ($.token === "in" && lr(X)) ||
        ($.tokenType === w.NUMBER && !lr(ue) && (!Kr(ue) || ue.op === "!")) ||
        $.token === "(";

      )
        (ue = V($)), (X = new v("*", "multiply", [X, ue], !0));
      return X;
    }
    function V($) {
      for (var X = L($), ue = X, we = []; $.token === "/" && lr(ue); )
        if ((we.push(Lr({}, $)), D($), $.tokenType === w.NUMBER))
          if (
            (we.push(Lr({}, $)),
            D($),
            $.tokenType === w.SYMBOL || $.token === "(")
          )
            Lr($, we.pop()),
              we.pop(),
              (ue = L($)),
              (X = new v("/", "divide", [X, ue]));
          else {
            we.pop(), Lr($, we.pop());
            break;
          }
        else {
          Lr($, we.pop());
          break;
        }
      return X;
    }
    function L($) {
      var X, ue, we, ke;
      X = j($);
      for (var Ye = { "%": "mod", mod: "mod" }; De(Ye, $.token); )
        (ue = $.token),
          (we = Ye[ue]),
          D($),
          ue === "%" && $.tokenType === w.DELIMITER && $.token !== "("
            ? (X = new v("/", "divide", [X, new u(100)], !1, !0))
            : ((ke = [X, j($)]), (X = new v(ue, we, ke)));
      return X;
    }
    function j($) {
      var X,
        ue,
        we,
        ke = { "-": "unaryMinus", "+": "unaryPlus", "~": "bitNot", not: "not" };
      return De(ke, $.token)
        ? ((we = ke[$.token]),
          (X = $.token),
          D($),
          (ue = [j($)]),
          new v(X, we, ue))
        : F($);
    }
    function F($) {
      var X, ue, we, ke;
      return (
        (X = U($)),
        ($.token === "^" || $.token === ".^") &&
          ((ue = $.token),
          (we = ue === "^" ? "pow" : "dotPow"),
          D($),
          (ke = [X, j($)]),
          (X = new v(ue, we, ke))),
        X
      );
    }
    function U($) {
      var X, ue, we, ke;
      X = ee($);
      for (var Ye = { "!": "factorial", "'": "ctranspose" }; De(Ye, $.token); )
        (ue = $.token),
          (we = Ye[ue]),
          T($),
          (ke = [X]),
          (X = new v(ue, we, ke)),
          (X = me($, X));
      return X;
    }
    function ee($) {
      var X = [];
      if ($.tokenType === w.SYMBOL && De($.extraNodes, $.token)) {
        var ue = $.extraNodes[$.token];
        if ((T($), $.token === "(")) {
          if (((X = []), Z($), T($), $.token !== ")"))
            for (X.push(te($)); $.token === ","; ) T($), X.push(te($));
          if ($.token !== ")") throw rr($, "Parenthesis ) expected");
          O($), T($);
        }
        return new ue(X);
      }
      return k($);
    }
    function k($) {
      var X, ue;
      return $.tokenType === w.SYMBOL ||
        ($.tokenType === w.DELIMITER && $.token in S)
        ? ((ue = $.token),
          T($),
          De(A, ue)
            ? (X = new u(A[ue]))
            : E.indexOf(ue) !== -1
            ? (X = new u(t(ue, "number")))
            : (X = new N(ue)),
          (X = me($, X)),
          X)
        : he($);
    }
    function me($, X, ue) {
      for (
        var we;
        ($.token === "(" || $.token === "[" || $.token === ".") &&
        (!ue || ue.indexOf($.token) !== -1);

      )
        if (((we = []), $.token === "("))
          if (qr(X) || En(X)) {
            if ((Z($), T($), $.token !== ")"))
              for (we.push(te($)); $.token === ","; ) T($), we.push(te($));
            if ($.token !== ")") throw rr($, "Parenthesis ) expected");
            O($), T($), (X = new o(X, we));
          } else return X;
        else if ($.token === "[") {
          if ((Z($), T($), $.token !== "]"))
            for (we.push(te($)); $.token === ","; ) T($), we.push(te($));
          if ($.token !== "]") throw rr($, "Parenthesis ] expected");
          O($), T($), (X = new n(X, new l(we)));
        } else {
          if ((T($), $.tokenType !== w.SYMBOL))
            throw rr($, "Property name expected after dot");
          we.push(new u($.token)), T($);
          var ke = !0;
          X = new n(X, new l(we, ke));
        }
      return X;
    }
    function he($) {
      var X, ue;
      return $.token === '"'
        ? ((ue = Me($)), (X = new u(ue)), (X = me($, X)), X)
        : be($);
    }
    function Me($) {
      for (var X = ""; C($) !== "" && C($) !== '"'; )
        C($) === "\\" && ((X += C($)), _($)), (X += C($)), _($);
      if ((T($), $.token !== '"')) throw rr($, 'End of string " expected');
      return T($), JSON.parse('"' + X + '"');
    }
    function be($) {
      var X, ue;
      return $.token === "'"
        ? ((ue = xe($)), (X = new u(ue)), (X = me($, X)), X)
        : Te($);
    }
    function xe($) {
      for (var X = ""; C($) !== "" && C($) !== "'"; )
        C($) === "\\" && ((X += C($)), _($)), (X += C($)), _($);
      if ((T($), $.token !== "'")) throw rr($, "End of string ' expected");
      return T($), JSON.parse('"' + X + '"');
    }
    function Te($) {
      var X, ue, we, ke;
      if ($.token === "[") {
        if ((Z($), T($), $.token !== "]")) {
          var Ye = or($);
          if ($.token === ";") {
            for (we = 1, ue = [Ye]; $.token === ";"; )
              T($), (ue[we] = or($)), we++;
            if ($.token !== "]") throw rr($, "End of matrix ] expected");
            O($), T($), (ke = ue[0].items.length);
            for (var Or = 1; Or < we; Or++)
              if (ue[Or].items.length !== ke)
                throw $t(
                  $,
                  "Column dimensions mismatch (" +
                    ue[Or].items.length +
                    " !== " +
                    ke +
                    ")"
                );
            X = new i(ue);
          } else {
            if ($.token !== "]") throw rr($, "End of matrix ] expected");
            O($), T($), (X = Ye);
          }
        } else O($), T($), (X = new i([]));
        return me($, X);
      }
      return br($);
    }
    function or($) {
      for (var X = [te($)], ue = 1; $.token === ","; )
        T($), (X[ue] = te($)), ue++;
      return new i(X);
    }
    function br($) {
      if ($.token === "{") {
        Z($);
        var X,
          ue = {};
        do
          if ((T($), $.token !== "}")) {
            if ($.token === '"') X = Me($);
            else if ($.token === "'") X = xe($);
            else if (
              $.tokenType === w.SYMBOL ||
              ($.tokenType === w.DELIMITER && $.token in S)
            )
              (X = $.token), T($);
            else throw rr($, "Symbol or string expected as object key");
            if ($.token !== ":")
              throw rr($, "Colon : expected after object key");
            T($), (ue[X] = te($));
          }
        while ($.token === ",");
        if ($.token !== "}")
          throw rr($, "Comma , or bracket } expected after object value");
        O($), T($);
        var we = new p(ue);
        return (we = me($, we)), we;
      }
      return mr($);
    }
    function mr($) {
      var X;
      return $.tokenType === w.NUMBER
        ? ((X = $.token), T($), new u(t(X, a.number)))
        : Jr($);
    }
    function Jr($) {
      var X;
      if ($.token === "(") {
        if ((Z($), T($), (X = te($)), $.token !== ")"))
          throw rr($, "Parenthesis ) expected");
        return O($), T($), (X = new h(X)), (X = me($, X)), X;
      }
      return Wr($);
    }
    function Wr($) {
      throw $.token === ""
        ? rr($, "Unexpected end of expression")
        : rr($, "Value expected");
    }
    function ot($) {
      return $.index - $.token.length + 1;
    }
    function rr($, X) {
      var ue = ot($),
        we = new SyntaxError(X + " (char " + ue + ")");
      return (we.char = ue), we;
    }
    function $t($, X) {
      var ue = ot($),
        we = new SyntaxError(X + " (char " + ue + ")");
      return (we.char = ue), we;
    }
    return d;
  }),
  Yf = "compile",
  qC = ["typed", "parse"],
  zC = P(Yf, qC, (e) => {
    var { typed: r, parse: t } = e;
    return r(Yf, {
      string: function (n) {
        return t(n).compile();
      },
      "Array | Matrix": function (n) {
        return Oe(n, function (i) {
          return t(i).compile();
        });
      },
    });
  }),
  Qf = "evaluate",
  UC = ["typed", "parse"],
  LC = P(Qf, UC, (e) => {
    var { typed: r, parse: t } = e;
    return r(Qf, {
      string: function (n) {
        var i = Gt();
        return t(n).compile().evaluate(i);
      },
      "string, Map | Object": function (n, i) {
        return t(n).compile().evaluate(i);
      },
      "Array | Matrix": function (n) {
        var i = Gt();
        return Oe(n, function (c) {
          return t(c).compile().evaluate(i);
        });
      },
      "Array | Matrix, Map | Object": function (n, i) {
        return Oe(n, function (c) {
          return t(c).compile().evaluate(i);
        });
      },
    });
  }),
  kC = "Parser",
  VC = ["evaluate"],
  GC = P(
    kC,
    VC,
    (e) => {
      var { evaluate: r } = e;
      function t() {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        Object.defineProperty(this, "scope", { value: Gt(), writable: !1 });
      }
      return (
        (t.prototype.type = "Parser"),
        (t.prototype.isParser = !0),
        (t.prototype.evaluate = function (a) {
          return r(a, this.scope);
        }),
        (t.prototype.get = function (a) {
          if (this.scope.has(a)) return this.scope.get(a);
        }),
        (t.prototype.getAll = function () {
          return p1(this.scope);
        }),
        (t.prototype.getAllAsMap = function () {
          return this.scope;
        }),
        (t.prototype.set = function (a, n) {
          return this.scope.set(a, n), n;
        }),
        (t.prototype.remove = function (a) {
          this.scope.delete(a);
        }),
        (t.prototype.clear = function () {
          this.scope.clear();
        }),
        t
      );
    },
    { isClass: !0 }
  ),
  jf = "parser",
  HC = ["typed", "Parser"],
  ZC = P(jf, HC, (e) => {
    var { typed: r, Parser: t } = e;
    return r(jf, {
      "": function () {
        return new t();
      },
    });
  }),
  Kf = "lup",
  JC = [
    "typed",
    "matrix",
    "abs",
    "addScalar",
    "divideScalar",
    "multiplyScalar",
    "subtract",
    "larger",
    "equalScalar",
    "unaryMinus",
    "DenseMatrix",
    "SparseMatrix",
    "Spa",
  ],
  WC = P(Kf, JC, (e) => {
    var {
      typed: r,
      matrix: t,
      abs: a,
      addScalar: n,
      divideScalar: i,
      multiplyScalar: c,
      subtract: m,
      larger: f,
      equalScalar: u,
      unaryMinus: s,
      DenseMatrix: o,
      SparseMatrix: l,
      Spa: p,
    } = e;
    return r(Kf, {
      DenseMatrix: function (b) {
        return v(b);
      },
      SparseMatrix: function (b) {
        return h(b);
      },
      Array: function (b) {
        var N = t(b),
          d = v(N);
        return { L: d.L.valueOf(), U: d.U.valueOf(), p: d.p };
      },
    });
    function v(x) {
      var b = x._size[0],
        N = x._size[1],
        d = Math.min(b, N),
        y = Fe(x._data),
        w = [],
        g = [b, d],
        S = [],
        A = [d, N],
        E,
        M,
        B,
        C = [];
      for (E = 0; E < b; E++) C[E] = E;
      for (M = 0; M < N; M++) {
        if (M > 0)
          for (E = 0; E < b; E++) {
            var _ = Math.min(E, M),
              z = 0;
            for (B = 0; B < _; B++) z = n(z, c(y[E][B], y[B][M]));
            y[E][M] = m(y[E][M], z);
          }
        var I = M,
          T = 0,
          D = 0;
        for (E = M; E < b; E++) {
          var Z = y[E][M],
            O = a(Z);
          f(O, T) && ((I = E), (T = O), (D = Z));
        }
        if (
          (M !== I && ((C[M] = [C[I], (C[I] = C[M])][0]), o._swapRows(M, I, y)),
          M < b)
        )
          for (E = M + 1; E < b; E++) {
            var H = y[E][M];
            u(H, 0) || (y[E][M] = i(y[E][M], D));
          }
      }
      for (M = 0; M < N; M++)
        for (E = 0; E < b; E++) {
          if ((M === 0 && (E < N && (S[E] = []), (w[E] = [])), E < M)) {
            E < N && (S[E][M] = y[E][M]), M < b && (w[E][M] = 0);
            continue;
          }
          if (E === M) {
            E < N && (S[E][M] = y[E][M]), M < b && (w[E][M] = 1);
            continue;
          }
          E < N && (S[E][M] = 0), M < b && (w[E][M] = y[E][M]);
        }
      var Q = new o({ data: w, size: g }),
        te = new o({ data: S, size: A }),
        J = [];
      for (E = 0, d = C.length; E < d; E++) J[C[E]] = E;
      return {
        L: Q,
        U: te,
        p: J,
        toString: function () {
          return (
            "L: " +
            this.L.toString() +
            `
U: ` +
            this.U.toString() +
            `
P: ` +
            this.p
          );
        },
      };
    }
    function h(x) {
      var b = x._size[0],
        N = x._size[1],
        d = Math.min(b, N),
        y = x._values,
        w = x._index,
        g = x._ptr,
        S = [],
        A = [],
        E = [],
        M = [b, d],
        B = [],
        C = [],
        _ = [],
        z = [d, N],
        I,
        T,
        D,
        Z = [],
        O = [];
      for (I = 0; I < b; I++) (Z[I] = I), (O[I] = I);
      var H = function (J, re) {
          var oe = O[J],
            ae = O[re];
          (Z[oe] = re), (Z[ae] = J), (O[J] = ae), (O[re] = oe);
        },
        Q = function () {
          var J = new p();
          T < b && (E.push(S.length), S.push(1), A.push(T)), _.push(B.length);
          var re = g[T],
            oe = g[T + 1];
          for (D = re; D < oe; D++) (I = w[D]), J.set(Z[I], y[D]);
          T > 0 &&
            J.forEach(0, T - 1, function (pe, ne) {
              l._forEachRow(pe, S, A, E, function (Ae, Ce) {
                Ae > pe && J.accumulate(Ae, s(c(Ce, ne)));
              });
            });
          var ae = T,
            ce = J.get(T),
            se = a(ce);
          J.forEach(T + 1, b - 1, function (pe, ne) {
            var Ae = a(ne);
            f(Ae, se) && ((ae = pe), (se = Ae), (ce = ne));
          }),
            T !== ae &&
              (l._swapRows(T, ae, M[1], S, A, E),
              l._swapRows(T, ae, z[1], B, C, _),
              J.swap(T, ae),
              H(T, ae)),
            J.forEach(0, b - 1, function (pe, ne) {
              pe <= T
                ? (B.push(ne), C.push(pe))
                : ((ne = i(ne, ce)), u(ne, 0) || (S.push(ne), A.push(pe)));
            });
        };
      for (T = 0; T < N; T++) Q();
      return (
        _.push(B.length),
        E.push(S.length),
        {
          L: new l({ values: S, index: A, ptr: E, size: M }),
          U: new l({ values: B, index: C, ptr: _, size: z }),
          p: Z,
          toString: function () {
            return (
              "L: " +
              this.L.toString() +
              `
U: ` +
              this.U.toString() +
              `
P: ` +
              this.p
            );
          },
        }
      );
    }
  }),
  em = "qr",
  XC = [
    "typed",
    "matrix",
    "zeros",
    "identity",
    "isZero",
    "equal",
    "sign",
    "sqrt",
    "conj",
    "unaryMinus",
    "addScalar",
    "divideScalar",
    "multiplyScalar",
    "subtract",
    "complex",
  ],
  YC = P(em, XC, (e) => {
    var {
      typed: r,
      matrix: t,
      zeros: a,
      identity: n,
      isZero: i,
      equal: c,
      sign: m,
      sqrt: f,
      conj: u,
      unaryMinus: s,
      addScalar: o,
      divideScalar: l,
      multiplyScalar: p,
      subtract: v,
      complex: h,
    } = e;
    return Lr(
      r(em, {
        DenseMatrix: function (y) {
          return b(y);
        },
        SparseMatrix: function (y) {
          return N();
        },
        Array: function (y) {
          var w = t(y),
            g = b(w);
          return { Q: g.Q.valueOf(), R: g.R.valueOf() };
        },
      }),
      { _denseQRimpl: x }
    );
    function x(d) {
      var y = d._size[0],
        w = d._size[1],
        g = n([y], "dense"),
        S = g._data,
        A = d.clone(),
        E = A._data,
        M,
        B,
        C,
        _ = a([y], "");
      for (C = 0; C < Math.min(w, y); ++C) {
        var z = E[C][C],
          I = s(c(z, 0) ? 1 : m(z)),
          T = u(I),
          D = 0;
        for (M = C; M < y; M++) D = o(D, p(E[M][C], u(E[M][C])));
        var Z = p(I, f(D));
        if (!i(Z)) {
          var O = v(z, Z);
          for (_[C] = 1, M = C + 1; M < y; M++) _[M] = l(E[M][C], O);
          var H = s(u(l(O, Z))),
            Q = void 0;
          for (B = C; B < w; B++) {
            for (Q = 0, M = C; M < y; M++) Q = o(Q, p(u(_[M]), E[M][B]));
            for (Q = p(Q, H), M = C; M < y; M++)
              E[M][B] = p(v(E[M][B], p(_[M], Q)), T);
          }
          for (M = 0; M < y; M++) {
            for (Q = 0, B = C; B < y; B++) Q = o(Q, p(S[M][B], _[B]));
            for (Q = p(Q, H), B = C; B < y; ++B)
              S[M][B] = l(v(S[M][B], p(Q, u(_[B]))), T);
          }
        }
      }
      return {
        Q: g,
        R: A,
        toString: function () {
          return (
            "Q: " +
            this.Q.toString() +
            `
R: ` +
            this.R.toString()
          );
        },
      };
    }
    function b(d) {
      var y = x(d),
        w = y.R._data;
      if (d._data.length > 0)
        for (
          var g = w[0][0].type === "Complex" ? h(0) : 0, S = 0;
          S < w.length;
          ++S
        )
          for (var A = 0; A < S && A < (w[0] || []).length; ++A) w[S][A] = g;
      return y;
    }
    function N(d) {
      throw new Error("qr not implemented for sparse matrices yet");
    }
  });
function QC(e, r, t, a) {
  for (
    var n = e._values,
      i = e._index,
      c = e._ptr,
      m = e._size,
      f = e._datatype,
      u = m[0],
      s = m[1],
      o = a && e._values ? [] : null,
      l = [],
      p = [],
      v = 0,
      h = 0;
    h < s;
    h++
  ) {
    p[h] = v;
    for (var x = t ? t[h] : h, b = c[x], N = c[x + 1], d = b; d < N; d++) {
      var y = r ? r[i[d]] : i[d];
      (l[v] = y), o && (o[v] = n[d]), v++;
    }
  }
  return (
    (p[s] = v),
    e.createSparseMatrix({
      values: o,
      index: l,
      ptr: p,
      size: [u, s],
      datatype: f,
    })
  );
}
function xh(e, r, t, a, n, i, c) {
  var m = 0;
  for (t[c] = e; m >= 0; ) {
    var f = t[c + m],
      u = t[a + f];
    u === -1
      ? (m--, (i[r++] = f))
      : ((t[a + f] = t[n + u]), ++m, (t[c + m] = u));
  }
  return r;
}
function jC(e, r) {
  if (!e) return null;
  var t = 0,
    a,
    n = [],
    i = [],
    c = 0,
    m = r,
    f = 2 * r;
  for (a = 0; a < r; a++) i[c + a] = -1;
  for (a = r - 1; a >= 0; a--)
    e[a] !== -1 && ((i[m + a] = i[c + e[a]]), (i[c + e[a]] = a));
  for (a = 0; a < r; a++) e[a] === -1 && (t = xh(a, t, i, c, m, n, f));
  return n;
}
function KC(e, r) {
  if (!e) return null;
  var t = e._index,
    a = e._ptr,
    n = e._size,
    i = n[0],
    c = n[1],
    m = [],
    f = [],
    u = 0,
    s = c,
    o,
    l;
  if (r) for (o = 0; o < i; o++) f[s + o] = -1;
  for (var p = 0; p < c; p++) {
    (m[p] = -1), (f[u + p] = -1);
    for (var v = a[p], h = a[p + 1], x = v; x < h; x++) {
      var b = t[x];
      for (o = r ? f[s + b] : b; o !== -1 && o < p; o = l)
        (l = f[u + o]), (f[u + o] = p), l === -1 && (m[o] = p);
      r && (f[s + b] = p);
    }
  }
  return m;
}
function e3(e, r, t) {
  for (
    var a = e._values,
      n = e._index,
      i = e._ptr,
      c = e._size,
      m = c[1],
      f = 0,
      u = 0;
    u < m;
    u++
  ) {
    var s = i[u];
    for (i[u] = f; s < i[u + 1]; s++)
      r(n[s], u, a ? a[s] : 1, t) && ((n[f] = n[s]), a && (a[f] = a[s]), f++);
  }
  return (
    (i[m] = f), n.splice(f, n.length - f), a && a.splice(f, a.length - f), f
  );
}
function cn(e) {
  return -e - 2;
}
var r3 = "csAmd",
  t3 = ["add", "multiply", "transpose"],
  n3 = P(r3, t3, (e) => {
    var { add: r, multiply: t, transpose: a } = e;
    return function (s, o) {
      if (!o || s <= 0 || s > 3) return null;
      var l = o._size,
        p = l[0],
        v = l[1],
        h = 0,
        x = Math.max(16, 10 * Math.sqrt(v));
      x = Math.min(v - 2, x);
      var b = n(s, o, p, v, x);
      e3(b, f, null);
      for (
        var N = b._index,
          d = b._ptr,
          y = d[v],
          w = [],
          g = [],
          S = 0,
          A = v + 1,
          E = 2 * (v + 1),
          M = 3 * (v + 1),
          B = 4 * (v + 1),
          C = 5 * (v + 1),
          _ = 6 * (v + 1),
          z = 7 * (v + 1),
          I = w,
          T = i(v, d, g, S, M, I, E, z, A, _, B, C),
          D = c(v, d, g, C, B, _, x, A, M, I, E),
          Z = 0,
          O,
          H,
          Q,
          te,
          J,
          re,
          oe,
          ae,
          ce,
          se,
          pe,
          ne,
          Ae,
          Ce,
          ge,
          Se;
        D < v;

      ) {
        for (Q = -1; Z < v && (Q = g[M + Z]) === -1; Z++);
        g[E + Q] !== -1 && (I[g[E + Q]] = -1), (g[M + Z] = g[E + Q]);
        var q = g[B + Q],
          Y = g[A + Q];
        D += Y;
        var V = 0;
        g[A + Q] = -Y;
        var L = d[Q],
          j = q === 0 ? L : y,
          F = j;
        for (te = 1; te <= q + 1; te++) {
          for (
            te > q
              ? ((re = Q), (oe = L), (ae = g[S + Q] - q))
              : ((re = N[L++]), (oe = d[re]), (ae = g[S + re])),
              J = 1;
            J <= ae;
            J++
          )
            (O = N[oe++]),
              !((ce = g[A + O]) <= 0) &&
                ((V += ce),
                (g[A + O] = -ce),
                (N[F++] = O),
                g[E + O] !== -1 && (I[g[E + O]] = I[O]),
                I[O] !== -1
                  ? (g[E + I[O]] = g[E + O])
                  : (g[M + g[C + O]] = g[E + O]));
          re !== Q && ((d[re] = cn(Q)), (g[_ + re] = 0));
        }
        for (
          q !== 0 && (y = F),
            g[C + Q] = V,
            d[Q] = j,
            g[S + Q] = F - j,
            g[B + Q] = -2,
            T = m(T, h, g, _, v),
            se = j;
          se < F;
          se++
        )
          if (((O = N[se]), !((pe = g[B + O]) <= 0))) {
            ce = -g[A + O];
            var U = T - ce;
            for (L = d[O], ne = d[O] + pe - 1; L <= ne; L++)
              (re = N[L]),
                g[_ + re] >= T
                  ? (g[_ + re] -= ce)
                  : g[_ + re] !== 0 && (g[_ + re] = g[C + re] + U);
          }
        for (se = j; se < F; se++) {
          for (
            O = N[se],
              ne = d[O],
              Ae = ne + g[B + O] - 1,
              Ce = ne,
              ge = 0,
              Se = 0,
              L = ne;
            L <= Ae;
            L++
          )
            if (((re = N[L]), g[_ + re] !== 0)) {
              var ee = g[_ + re] - T;
              ee > 0
                ? ((Se += ee), (N[Ce++] = re), (ge += re))
                : ((d[re] = cn(Q)), (g[_ + re] = 0));
            }
          g[B + O] = Ce - ne + 1;
          var k = Ce,
            me = ne + g[S + O];
          for (L = Ae + 1; L < me; L++) {
            H = N[L];
            var he = g[A + H];
            he <= 0 || ((Se += he), (N[Ce++] = H), (ge += H));
          }
          Se === 0
            ? ((d[O] = cn(Q)),
              (ce = -g[A + O]),
              (V -= ce),
              (Y += ce),
              (D += ce),
              (g[A + O] = 0),
              (g[B + O] = -1))
            : ((g[C + O] = Math.min(g[C + O], Se)),
              (N[Ce] = N[k]),
              (N[k] = N[ne]),
              (N[ne] = Q),
              (g[S + O] = Ce - ne + 1),
              (ge = (ge < 0 ? -ge : ge) % v),
              (g[E + O] = g[z + ge]),
              (g[z + ge] = O),
              (I[O] = ge));
        }
        for (
          g[C + Q] = V, h = Math.max(h, V), T = m(T + h, h, g, _, v), se = j;
          se < F;
          se++
        )
          if (((O = N[se]), !(g[A + O] >= 0)))
            for (
              ge = I[O], O = g[z + ge], g[z + ge] = -1;
              O !== -1 && g[E + O] !== -1;
              O = g[E + O], T++
            ) {
              for (
                ae = g[S + O], pe = g[B + O], L = d[O] + 1;
                L <= d[O] + ae - 1;
                L++
              )
                g[_ + N[L]] = T;
              var Me = O;
              for (H = g[E + O]; H !== -1; ) {
                var be = g[S + H] === ae && g[B + H] === pe;
                for (L = d[H] + 1; be && L <= d[H] + ae - 1; L++)
                  g[_ + N[L]] !== T && (be = 0);
                be
                  ? ((d[H] = cn(O)),
                    (g[A + O] += g[A + H]),
                    (g[A + H] = 0),
                    (g[B + H] = -1),
                    (H = g[E + H]),
                    (g[E + Me] = H))
                  : ((Me = H), (H = g[E + H]));
              }
            }
        for (L = j, se = j; se < F; se++)
          (O = N[se]),
            !((ce = -g[A + O]) <= 0) &&
              ((g[A + O] = ce),
              (Se = g[C + O] + V - ce),
              (Se = Math.min(Se, v - D - ce)),
              g[M + Se] !== -1 && (I[g[M + Se]] = O),
              (g[E + O] = g[M + Se]),
              (I[O] = -1),
              (g[M + Se] = O),
              (Z = Math.min(Z, Se)),
              (g[C + O] = Se),
              (N[L++] = O));
        (g[A + Q] = Y),
          (g[S + Q] = L - j) === 0 && ((d[Q] = -1), (g[_ + Q] = 0)),
          q !== 0 && (y = L);
      }
      for (O = 0; O < v; O++) d[O] = cn(d[O]);
      for (H = 0; H <= v; H++) g[M + H] = -1;
      for (H = v; H >= 0; H--)
        g[A + H] > 0 || ((g[E + H] = g[M + d[H]]), (g[M + d[H]] = H));
      for (re = v; re >= 0; re--)
        g[A + re] <= 0 ||
          (d[re] !== -1 && ((g[E + re] = g[M + d[re]]), (g[M + d[re]] = re)));
      for (Q = 0, O = 0; O <= v; O++)
        d[O] === -1 && (Q = xh(O, Q, g, M, E, w, _));
      return w.splice(w.length - 1, 1), w;
    };
    function n(u, s, o, l, p) {
      var v = a(s);
      if (u === 1 && l === o) return r(s, v);
      if (u === 2) {
        for (var h = v._index, x = v._ptr, b = 0, N = 0; N < o; N++) {
          var d = x[N];
          if (((x[N] = b), !(x[N + 1] - d > p)))
            for (var y = x[N + 1]; d < y; d++) h[b++] = h[d];
        }
        return (x[o] = b), (s = a(v)), t(v, s);
      }
      return t(v, s);
    }
    function i(u, s, o, l, p, v, h, x, b, N, d, y) {
      for (var w = 0; w < u; w++) o[l + w] = s[w + 1] - s[w];
      o[l + u] = 0;
      for (var g = 0; g <= u; g++)
        (o[p + g] = -1),
          (v[g] = -1),
          (o[h + g] = -1),
          (o[x + g] = -1),
          (o[b + g] = 1),
          (o[N + g] = 1),
          (o[d + g] = 0),
          (o[y + g] = o[l + g]);
      var S = m(0, 0, o, N, u);
      return (o[d + u] = -2), (s[u] = -1), (o[N + u] = 0), S;
    }
    function c(u, s, o, l, p, v, h, x, b, N, d) {
      for (var y = 0, w = 0; w < u; w++) {
        var g = o[l + w];
        if (g === 0) (o[p + w] = -2), y++, (s[w] = -1), (o[v + w] = 0);
        else if (g > h)
          (o[x + w] = 0), (o[p + w] = -1), y++, (s[w] = cn(u)), o[x + u]++;
        else {
          var S = o[b + g];
          S !== -1 && (N[S] = w), (o[d + w] = o[b + g]), (o[b + g] = w);
        }
      }
      return y;
    }
    function m(u, s, o, l, p) {
      if (u < 2 || u + s < 0) {
        for (var v = 0; v < p; v++) o[l + v] !== 0 && (o[l + v] = 1);
        u = 2;
      }
      return u;
    }
    function f(u, s) {
      return u !== s;
    }
  });
function a3(e, r, t, a, n, i, c) {
  var m,
    f,
    u = 0,
    s;
  if (e <= r || t[a + r] <= t[n + e]) return -1;
  t[n + e] = t[a + r];
  var o = t[i + e];
  if (((t[i + e] = r), o === -1)) (u = 1), (s = e);
  else {
    for (u = 2, s = o; s !== t[c + s]; s = t[c + s]);
    for (m = o; m !== s; m = f) (f = t[c + m]), (t[c + m] = s);
  }
  return { jleaf: u, q: s };
}
var i3 = "csCounts",
  o3 = ["transpose"],
  s3 = P(i3, o3, (e) => {
    var { transpose: r } = e;
    return function (t, a, n, i) {
      if (!t || !a || !n) return null;
      var c = t._size,
        m = c[0],
        f = c[1],
        u,
        s,
        o,
        l,
        p,
        v,
        h,
        x = 4 * f + (i ? f + m + 1 : 0),
        b = [],
        N = 0,
        d = f,
        y = 2 * f,
        w = 3 * f,
        g = 4 * f,
        S = 5 * f + 1;
      for (o = 0; o < x; o++) b[o] = -1;
      var A = [],
        E = r(t),
        M = E._index,
        B = E._ptr;
      for (o = 0; o < f; o++)
        for (
          s = n[o], A[s] = b[w + s] === -1 ? 1 : 0;
          s !== -1 && b[w + s] === -1;
          s = a[s]
        )
          b[w + s] = o;
      if (i) {
        for (o = 0; o < f; o++) b[n[o]] = o;
        for (u = 0; u < m; u++) {
          for (o = f, v = B[u], h = B[u + 1], p = v; p < h; p++)
            o = Math.min(o, b[M[p]]);
          (b[S + u] = b[g + o]), (b[g + o] = u);
        }
      }
      for (u = 0; u < f; u++) b[N + u] = u;
      for (o = 0; o < f; o++) {
        for (
          s = n[o], a[s] !== -1 && A[a[s]]--, l = i ? b[g + o] : s;
          l !== -1;
          l = i ? b[S + l] : -1
        )
          for (p = B[l]; p < B[l + 1]; p++) {
            u = M[p];
            var C = a3(u, s, b, w, d, y, N);
            C.jleaf >= 1 && A[s]++, C.jleaf === 2 && A[C.q]--;
          }
        a[s] !== -1 && (b[N + s] = a[s]);
      }
      for (s = 0; s < f; s++) a[s] !== -1 && (A[a[s]] += A[s]);
      return A;
    };
  }),
  u3 = "csSqr",
  l3 = ["add", "multiply", "transpose"],
  c3 = P(u3, l3, (e) => {
    var { add: r, multiply: t, transpose: a } = e,
      n = n3({ add: r, multiply: t, transpose: a }),
      i = s3({ transpose: a });
    return function (f, u, s) {
      var o = u._ptr,
        l = u._size,
        p = l[1],
        v,
        h = {};
      if (((h.q = n(f, u)), f && !h.q)) return null;
      if (s) {
        var x = f ? QC(u, null, h.q, 0) : u;
        h.parent = KC(x, 1);
        var b = jC(h.parent, p);
        if (((h.cp = i(x, h.parent, b, 1)), x && h.parent && h.cp && c(x, h)))
          for (h.unz = 0, v = 0; v < p; v++) h.unz += h.cp[v];
      } else (h.unz = 4 * o[p] + p), (h.lnz = h.unz);
      return h;
    };
    function c(m, f) {
      var u = m._ptr,
        s = m._index,
        o = m._size,
        l = o[0],
        p = o[1];
      (f.pinv = []), (f.leftmost = []);
      var v = f.parent,
        h = f.pinv,
        x = f.leftmost,
        b = [],
        N = 0,
        d = l,
        y = l + p,
        w = l + 2 * p,
        g,
        S,
        A,
        E,
        M;
      for (S = 0; S < p; S++) (b[d + S] = -1), (b[y + S] = -1), (b[w + S] = 0);
      for (g = 0; g < l; g++) x[g] = -1;
      for (S = p - 1; S >= 0; S--)
        for (E = u[S], M = u[S + 1], A = E; A < M; A++) x[s[A]] = S;
      for (g = l - 1; g >= 0; g--)
        (h[g] = -1),
          (S = x[g]),
          S !== -1 &&
            (b[w + S]++ === 0 && (b[y + S] = g),
            (b[N + g] = b[d + S]),
            (b[d + S] = g));
      for (f.lnz = 0, f.m2 = l, S = 0; S < p; S++)
        if (
          ((g = b[d + S]),
          f.lnz++,
          g < 0 && (g = f.m2++),
          (h[g] = S),
          !(--w[S] <= 0))
        ) {
          f.lnz += b[w + S];
          var B = v[S];
          B !== -1 &&
            (b[w + B] === 0 && (b[y + B] = b[y + S]),
            (b[N + b[y + S]] = b[d + B]),
            (b[d + B] = b[N + g]),
            (b[w + B] += b[w + S]));
        }
      for (g = 0; g < l; g++) h[g] < 0 && (h[g] = S++);
      return !0;
    }
  });
function Es(e, r) {
  return e[r] < 0;
}
function wh(e, r) {
  e[r] = cn(e[r]);
}
function rm(e) {
  return e < 0 ? cn(e) : e;
}
function f3(e, r, t, a, n) {
  var i = r._index,
    c = r._ptr,
    m = r._size,
    f = m[1],
    u,
    s,
    o,
    l = 0;
  for (a[0] = e; l >= 0; ) {
    e = a[l];
    var p = n ? n[e] : e;
    Es(c, e) || (wh(c, e), (a[f + l] = p < 0 ? 0 : rm(c[p])));
    var v = 1;
    for (s = a[f + l], o = p < 0 ? 0 : rm(c[p + 1]); s < o; s++)
      if (((u = i[s]), !Es(c, u))) {
        (a[f + l] = s), (a[++l] = u), (v = 0);
        break;
      }
    v && (l--, (a[--t] = e));
  }
  return t;
}
function m3(e, r, t, a, n) {
  var i = e._ptr,
    c = e._size,
    m = r._index,
    f = r._ptr,
    u = c[1],
    s,
    o,
    l,
    p = u;
  for (o = f[t], l = f[t + 1], s = o; s < l; s++) {
    var v = m[s];
    Es(i, v) || (p = f3(v, e, p, a, n));
  }
  for (s = p; s < u; s++) wh(i, a[s]);
  return p;
}
var p3 = "csSpsolve",
  v3 = ["divideScalar", "multiply", "subtract"],
  h3 = P(p3, v3, (e) => {
    var { divideScalar: r, multiply: t, subtract: a } = e;
    return function (i, c, m, f, u, s, o) {
      var l = i._values,
        p = i._index,
        v = i._ptr,
        h = i._size,
        x = h[1],
        b = c._values,
        N = c._index,
        d = c._ptr,
        y,
        w,
        g,
        S,
        A = m3(i, c, m, f, s);
      for (y = A; y < x; y++) u[f[y]] = 0;
      for (w = d[m], g = d[m + 1], y = w; y < g; y++) u[N[y]] = b[y];
      for (var E = A; E < x; E++) {
        var M = f[E],
          B = s ? s[M] : M;
        if (!(B < 0))
          for (
            w = v[B],
              g = v[B + 1],
              u[M] = r(u[M], l[o ? w : g - 1]),
              y = o ? w + 1 : w,
              S = o ? g : g - 1;
            y < S;
            y++
          ) {
            var C = p[y];
            u[C] = a(u[C], t(l[y], u[M]));
          }
      }
      return A;
    };
  }),
  d3 = "csLu",
  g3 = [
    "abs",
    "divideScalar",
    "multiply",
    "subtract",
    "larger",
    "largerEq",
    "SparseMatrix",
  ],
  y3 = P(d3, g3, (e) => {
    var {
        abs: r,
        divideScalar: t,
        multiply: a,
        subtract: n,
        larger: i,
        largerEq: c,
        SparseMatrix: m,
      } = e,
      f = h3({ divideScalar: t, multiply: a, subtract: n });
    return function (s, o, l) {
      if (!s) return null;
      var p = s._size,
        v = p[1],
        h,
        x = 100,
        b = 100;
      o && ((h = o.q), (x = o.lnz || x), (b = o.unz || b));
      var N = [],
        d = [],
        y = [],
        w = new m({ values: N, index: d, ptr: y, size: [v, v] }),
        g = [],
        S = [],
        A = [],
        E = new m({ values: g, index: S, ptr: A, size: [v, v] }),
        M = [],
        B,
        C,
        _ = [],
        z = [];
      for (B = 0; B < v; B++) (_[B] = 0), (M[B] = -1), (y[B + 1] = 0);
      (x = 0), (b = 0);
      for (var I = 0; I < v; I++) {
        (y[I] = x), (A[I] = b);
        var T = h ? h[I] : I,
          D = f(w, s, T, z, _, M, 1),
          Z = -1,
          O = -1;
        for (C = D; C < v; C++)
          if (((B = z[C]), M[B] < 0)) {
            var H = r(_[B]);
            i(H, O) && ((O = H), (Z = B));
          } else (S[b] = M[B]), (g[b++] = _[B]);
        if (Z === -1 || O <= 0) return null;
        M[T] < 0 && c(r(_[T]), a(O, l)) && (Z = T);
        var Q = _[Z];
        for (
          S[b] = I, g[b++] = Q, M[Z] = I, d[x] = Z, N[x++] = 1, C = D;
          C < v;
          C++
        )
          (B = z[C]),
            M[B] < 0 && ((d[x] = B), (N[x++] = t(_[B], Q))),
            (_[B] = 0);
      }
      for (y[v] = x, A[v] = b, C = 0; C < x; C++) d[C] = M[d[C]];
      return (
        N.splice(x, N.length - x),
        d.splice(x, d.length - x),
        g.splice(b, g.length - b),
        S.splice(b, S.length - b),
        { L: w, U: E, pinv: M }
      );
    };
  }),
  tm = "slu",
  b3 = [
    "typed",
    "abs",
    "add",
    "multiply",
    "transpose",
    "divideScalar",
    "subtract",
    "larger",
    "largerEq",
    "SparseMatrix",
  ],
  x3 = P(tm, b3, (e) => {
    var {
        typed: r,
        abs: t,
        add: a,
        multiply: n,
        transpose: i,
        divideScalar: c,
        subtract: m,
        larger: f,
        largerEq: u,
        SparseMatrix: s,
      } = e,
      o = c3({ add: a, multiply: n, transpose: i }),
      l = y3({
        abs: t,
        divideScalar: c,
        multiply: n,
        subtract: m,
        larger: f,
        largerEq: u,
        SparseMatrix: s,
      });
    return r(tm, {
      "SparseMatrix, number, number": function (v, h, x) {
        if (!Be(h) || h < 0 || h > 3)
          throw new Error(
            "Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]"
          );
        if (x < 0 || x > 1)
          throw new Error(
            "Partial pivoting threshold must be a number from 0 to 1"
          );
        var b = o(h, v, !1),
          N = l(v, b, x);
        return {
          L: N.L,
          U: N.U,
          p: N.pinv,
          q: b.q,
          toString: function () {
            return (
              "L: " +
              this.L.toString() +
              `
U: ` +
              this.U.toString() +
              `
p: ` +
              this.p.toString() +
              (this.q
                ? `
q: ` + this.q.toString()
                : "") +
              `
`
            );
          },
        };
      },
    });
  });
function nm(e, r) {
  var t,
    a = r.length,
    n = [];
  if (e) for (t = 0; t < a; t++) n[e[t]] = r[t];
  else for (t = 0; t < a; t++) n[t] = r[t];
  return n;
}
var am = "lusolve",
  w3 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"],
  N3 = P(am, w3, (e) => {
    var {
        typed: r,
        matrix: t,
        lup: a,
        slu: n,
        usolve: i,
        lsolve: c,
        DenseMatrix: m,
      } = e,
      f = Ya({ DenseMatrix: m });
    return r(am, {
      "Array, Array | Matrix": function (l, p) {
        l = t(l);
        var v = a(l),
          h = s(v.L, v.U, v.p, null, p);
        return h.valueOf();
      },
      "DenseMatrix, Array | Matrix": function (l, p) {
        var v = a(l);
        return s(v.L, v.U, v.p, null, p);
      },
      "SparseMatrix, Array | Matrix": function (l, p) {
        var v = a(l);
        return s(v.L, v.U, v.p, null, p);
      },
      "SparseMatrix, Array | Matrix, number, number": function (l, p, v, h) {
        var x = n(l, v, h);
        return s(x.L, x.U, x.p, x.q, p);
      },
      "Object, Array | Matrix": function (l, p) {
        return s(l.L, l.U, l.p, l.q, p);
      },
    });
    function u(o) {
      if (ze(o)) return o;
      if (sr(o)) return t(o);
      throw new TypeError("Invalid Matrix LU decomposition");
    }
    function s(o, l, p, v, h) {
      (o = u(o)),
        (l = u(l)),
        p && ((h = f(o, h, !0)), (h._data = nm(p, h._data)));
      var x = c(o, h),
        b = i(l, x);
      return v && (b._data = nm(v, b._data)), b;
    }
  }),
  M3 = "Help",
  A3 = ["parse"],
  S3 = P(
    M3,
    A3,
    (e) => {
      var { parse: r } = e;
      function t(a) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!a) throw new Error('Argument "doc" missing');
        this.doc = a;
      }
      return (
        (t.prototype.type = "Help"),
        (t.prototype.isHelp = !0),
        (t.prototype.toString = function () {
          var a = this.doc || {},
            n = `
`;
          if (
            (a.name &&
              (n +=
                "Name: " +
                a.name +
                `

`),
            a.category &&
              (n +=
                "Category: " +
                a.category +
                `

`),
            a.description &&
              (n +=
                `Description:
    ` +
                a.description +
                `

`),
            a.syntax &&
              (n +=
                `Syntax:
    ` +
                a.syntax.join(`
    `) +
                `

`),
            a.examples)
          ) {
            n += `Examples:
`;
            for (var i = {}, c = 0; c < a.examples.length; c++) {
              var m = a.examples[c];
              n +=
                "    " +
                m +
                `
`;
              var f = void 0;
              try {
                f = r(m).compile().evaluate(i);
              } catch (u) {
                f = u;
              }
              f !== void 0 &&
                !qs(f) &&
                (n +=
                  "        " +
                  Ze(f, { precision: 14 }) +
                  `
`);
            }
            n += `
`;
          }
          return (
            a.mayThrow &&
              a.mayThrow.length &&
              (n +=
                "Throws: " +
                a.mayThrow.join(", ") +
                `

`),
            a.seealso &&
              a.seealso.length &&
              (n +=
                "See also: " +
                a.seealso.join(", ") +
                `
`),
            n
          );
        }),
        (t.prototype.toJSON = function () {
          var a = Fe(this.doc);
          return (a.mathjs = "Help"), a;
        }),
        (t.fromJSON = function (a) {
          var n = {};
          return (
            Object.keys(a)
              .filter((i) => i !== "mathjs")
              .forEach((i) => {
                n[i] = a[i];
              }),
            new t(n)
          );
        }),
        (t.prototype.valueOf = t.prototype.toString),
        t
      );
    },
    { isClass: !0 }
  ),
  E3 = "Chain",
  C3 = ["?on", "math"],
  $3 = P(
    E3,
    C3,
    (e) => {
      var { on: r, math: t } = e;
      function a(f) {
        if (!(this instanceof a))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        Us(f) ? (this.value = f.value) : (this.value = f);
      }
      (a.prototype.type = "Chain"),
        (a.prototype.isChain = !0),
        (a.prototype.done = function () {
          return this.value;
        }),
        (a.prototype.valueOf = function () {
          return this.value;
        }),
        (a.prototype.toString = function () {
          return Ze(this.value);
        }),
        (a.prototype.toJSON = function () {
          return { mathjs: "Chain", value: this.value };
        }),
        (a.fromJSON = function (f) {
          return new a(f.value);
        });
      function n(f, u) {
        typeof u == "function" && (a.prototype[f] = c(u));
      }
      function i(f, u) {
        B0(a.prototype, f, function () {
          var o = u();
          if (typeof o == "function") return c(o);
        });
      }
      function c(f) {
        return function () {
          for (var u = [this.value], s = 0; s < arguments.length; s++)
            u[s + 1] = arguments[s];
          return new a(f.apply(f, u));
        };
      }
      a.createProxy = function (f, u) {
        if (typeof f == "string") n(f, u);
        else {
          var s = function (p) {
            De(f, p) && m[p] === void 0 && i(p, () => f[p]);
          };
          for (var o in f) s(o);
        }
      };
      var m = {
        expression: !0,
        docs: !0,
        type: !0,
        classes: !0,
        json: !0,
        error: !0,
        isChain: !0,
      };
      return (
        a.createProxy(t),
        r &&
          r("import", function (f, u, s) {
            s || i(f, u);
          }),
        a
      );
    },
    { isClass: !0 }
  ),
  im = {
    name: "e",
    category: "Constants",
    syntax: ["e"],
    description:
      "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
    examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
    seealso: ["exp"],
  },
  O3 = {
    name: "false",
    category: "Constants",
    syntax: ["false"],
    description: "Boolean value false",
    examples: ["false"],
    seealso: ["true"],
  },
  T3 = {
    name: "i",
    category: "Constants",
    syntax: ["i"],
    description:
      "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
    examples: ["i", "i * i", "sqrt(-1)"],
    seealso: [],
  },
  D3 = {
    name: "Infinity",
    category: "Constants",
    syntax: ["Infinity"],
    description:
      "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
    examples: ["Infinity", "1 / 0"],
    seealso: [],
  },
  B3 = {
    name: "LN10",
    category: "Constants",
    syntax: ["LN10"],
    description:
      "Returns the natural logarithm of 10, approximately equal to 2.302",
    examples: ["LN10", "log(10)"],
    seealso: [],
  },
  _3 = {
    name: "LN2",
    category: "Constants",
    syntax: ["LN2"],
    description:
      "Returns the natural logarithm of 2, approximately equal to 0.693",
    examples: ["LN2", "log(2)"],
    seealso: [],
  },
  I3 = {
    name: "LOG10E",
    category: "Constants",
    syntax: ["LOG10E"],
    description:
      "Returns the base-10 logarithm of E, approximately equal to 0.434",
    examples: ["LOG10E", "log(e, 10)"],
    seealso: [],
  },
  R3 = {
    name: "LOG2E",
    category: "Constants",
    syntax: ["LOG2E"],
    description:
      "Returns the base-2 logarithm of E, approximately equal to 1.442",
    examples: ["LOG2E", "log(e, 2)"],
    seealso: [],
  },
  F3 = {
    name: "NaN",
    category: "Constants",
    syntax: ["NaN"],
    description: "Not a number",
    examples: ["NaN", "0 / 0"],
    seealso: [],
  },
  P3 = {
    name: "null",
    category: "Constants",
    syntax: ["null"],
    description: "Value null",
    examples: ["null"],
    seealso: ["true", "false"],
  },
  q3 = {
    name: "phi",
    category: "Constants",
    syntax: ["phi"],
    description:
      "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
    examples: ["phi"],
    seealso: [],
  },
  om = {
    name: "pi",
    category: "Constants",
    syntax: ["pi"],
    description:
      "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
    examples: ["pi", "sin(pi/2)"],
    seealso: ["tau"],
  },
  z3 = {
    name: "SQRT1_2",
    category: "Constants",
    syntax: ["SQRT1_2"],
    description: "Returns the square root of 1/2, approximately equal to 0.707",
    examples: ["SQRT1_2", "sqrt(1/2)"],
    seealso: [],
  },
  U3 = {
    name: "SQRT2",
    category: "Constants",
    syntax: ["SQRT2"],
    description: "Returns the square root of 2, approximately equal to 1.414",
    examples: ["SQRT2", "sqrt(2)"],
    seealso: [],
  },
  L3 = {
    name: "tau",
    category: "Constants",
    syntax: ["tau"],
    description:
      "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
    examples: ["tau", "2 * pi"],
    seealso: ["pi"],
  },
  k3 = {
    name: "true",
    category: "Constants",
    syntax: ["true"],
    description: "Boolean value true",
    examples: ["true"],
    seealso: ["false"],
  },
  V3 = {
    name: "version",
    category: "Constants",
    syntax: ["version"],
    description: "A string with the version number of math.js",
    examples: ["version"],
    seealso: [],
  },
  G3 = {
    name: "bignumber",
    category: "Construction",
    syntax: ["bignumber(x)"],
    description: "Create a big number from a number or string.",
    examples: [
      "0.1 + 0.2",
      "bignumber(0.1) + bignumber(0.2)",
      'bignumber("7.2")',
      'bignumber("7.2e500")',
      "bignumber([0.1, 0.2, 0.3])",
    ],
    seealso: [
      "boolean",
      "complex",
      "fraction",
      "index",
      "matrix",
      "string",
      "unit",
    ],
  },
  H3 = {
    name: "boolean",
    category: "Construction",
    syntax: ["x", "boolean(x)"],
    description: "Convert a string or number into a boolean.",
    examples: [
      "boolean(0)",
      "boolean(1)",
      "boolean(3)",
      'boolean("true")',
      'boolean("false")',
      "boolean([1, 0, 1, 1])",
    ],
    seealso: [
      "bignumber",
      "complex",
      "index",
      "matrix",
      "number",
      "string",
      "unit",
    ],
  },
  Z3 = {
    name: "complex",
    category: "Construction",
    syntax: ["complex()", "complex(re, im)", "complex(string)"],
    description: "Create a complex number.",
    examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
    seealso: [
      "bignumber",
      "boolean",
      "index",
      "matrix",
      "number",
      "string",
      "unit",
    ],
  },
  J3 = {
    name: "createUnit",
    category: "Construction",
    syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
    description:
      "Create a user-defined unit and register it with the Unit type.",
    examples: [
      'createUnit("foo")',
      'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})',
      'createUnit("mph", "1 mile/hour")',
    ],
    seealso: ["unit", "splitUnit"],
  },
  W3 = {
    name: "fraction",
    category: "Construction",
    syntax: [
      "fraction(num)",
      "fraction(matrix)",
      "fraction(num,den)",
      "fraction({n: num, d: den})",
    ],
    description:
      "Create a fraction from a number or from integer numerator and denominator.",
    examples: [
      "fraction(0.125)",
      "fraction(1, 3) + fraction(2, 5)",
      "fraction({n: 333, d: 53})",
      "fraction([sqrt(9), sqrt(10), sqrt(11)])",
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "matrix",
      "string",
      "unit",
    ],
  },
  X3 = {
    name: "index",
    category: "Construction",
    syntax: [
      "[start]",
      "[start:end]",
      "[start:step:end]",
      "[start1, start 2, ...]",
      "[start1:end1, start2:end2, ...]",
      "[start1:step1:end1, start2:step2:end2, ...]",
    ],
    description: "Create an index to get or replace a subset of a matrix",
    examples: [
      "[]",
      "[1, 2, 3]",
      "A = [1, 2, 3; 4, 5, 6]",
      "A[1, :]",
      "A[1, 2] = 50",
      "A[0:2, 0:2] = ones(2, 2)",
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "matrix,",
      "number",
      "range",
      "string",
      "unit",
    ],
  },
  Y3 = {
    name: "matrix",
    category: "Construction",
    syntax: [
      "[]",
      "[a1, b1, ...; a2, b2, ...]",
      "matrix()",
      'matrix("dense")',
      "matrix([...])",
    ],
    description: "Create a matrix.",
    examples: [
      "[]",
      "[1, 2, 3]",
      "[1, 2, 3; 4, 5, 6]",
      "matrix()",
      "matrix([3, 4])",
      'matrix([3, 4; 5, 6], "sparse")',
      'matrix([3, 4; 5, 6], "sparse", "number")',
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "number",
      "string",
      "unit",
      "sparse",
    ],
  },
  Q3 = {
    name: "number",
    category: "Construction",
    syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
    description:
      "Create a number or convert a string or boolean into a number.",
    examples: [
      "2",
      "2e3",
      "4.05",
      "number(2)",
      'number("7.2")',
      "number(true)",
      "number([true, false, true, true])",
      'number(unit("52cm"), "m")',
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "fraction",
      "index",
      "matrix",
      "string",
      "unit",
    ],
  },
  j3 = {
    name: "sparse",
    category: "Construction",
    syntax: [
      "sparse()",
      "sparse([a1, b1, ...; a1, b2, ...])",
      'sparse([a1, b1, ...; a1, b2, ...], "number")',
    ],
    description: "Create a sparse matrix.",
    examples: [
      "sparse()",
      "sparse([3, 4; 5, 6])",
      'sparse([3, 0; 5, 0], "number")',
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "number",
      "string",
      "unit",
      "matrix",
    ],
  },
  K3 = {
    name: "splitUnit",
    category: "Construction",
    syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
    description:
      "Split a unit in an array of units whose sum is equal to the original unit.",
    examples: ['splitUnit(1 m, ["feet", "inch"])'],
    seealso: ["unit", "createUnit"],
  },
  e$ = {
    name: "string",
    category: "Construction",
    syntax: ['"text"', "string(x)"],
    description: "Create a string or convert a value to a string",
    examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "matrix",
      "number",
      "unit",
    ],
  },
  r$ = {
    name: "unit",
    category: "Construction",
    syntax: ["value unit", "unit(value, unit)", "unit(string)"],
    description: "Create a unit.",
    examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "matrix",
      "number",
      "string",
    ],
  },
  t$ = {
    name: "config",
    category: "Core",
    syntax: ["config()", "config(options)"],
    description: "Get configuration or change configuration.",
    examples: [
      "config()",
      "1/3 + 1/4",
      'config({number: "Fraction"})',
      "1/3 + 1/4",
    ],
    seealso: [],
  },
  n$ = {
    name: "import",
    category: "Core",
    syntax: ["import(functions)", "import(functions, options)"],
    description: "Import functions or constants from an object.",
    examples: [
      "import({myFn: f(x)=x^2, myConstant: 32 })",
      "myFn(2)",
      "myConstant",
    ],
    seealso: [],
  },
  a$ = {
    name: "typed",
    category: "Core",
    syntax: ["typed(signatures)", "typed(name, signatures)"],
    description: "Create a typed function.",
    examples: [
      'double = typed({ "number": f(x)=x+x })',
      "double(2)",
      'double("hello")',
    ],
    seealso: [],
  },
  i$ = {
    name: "derivative",
    category: "Algebra",
    syntax: [
      "derivative(expr, variable)",
      "derivative(expr, variable, {simplify: boolean})",
    ],
    description:
      "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
    examples: [
      'derivative("2x^3", "x")',
      'derivative("2x^3", "x", {simplify: false})',
      'derivative("2x^2 + 3x + 4", "x")',
      'derivative("sin(2x)", "x")',
      'f = parse("x^2 + x")',
      'x = parse("x")',
      "df = derivative(f, x)",
      "df.evaluate({x: 3})",
    ],
    seealso: ["simplify", "parse", "evaluate"],
  },
  o$ = {
    name: "leafCount",
    category: "Algebra",
    syntax: ["leafCount(expr)"],
    description:
      "Computes the number of leaves in the parse tree of the given expression",
    examples: [
      'leafCount("e^(i*pi)-1")',
      'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))',
    ],
    seealso: ["simplify"],
  },
  s$ = {
    name: "lsolve",
    category: "Algebra",
    syntax: ["x=lsolve(L, b)"],
    description:
      "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"],
  },
  u$ = {
    name: "lsolveAll",
    category: "Algebra",
    syntax: ["x=lsolveAll(L, b)"],
    description:
      "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"],
  },
  l$ = {
    name: "lup",
    category: "Algebra",
    syntax: ["lup(m)"],
    description:
      "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
    examples: [
      "lup([[2, 1], [1, 4]])",
      "lup(matrix([[2, 1], [1, 4]]))",
      "lup(sparse([[2, 1], [1, 4]]))",
    ],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"],
  },
  c$ = {
    name: "lusolve",
    category: "Algebra",
    syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
    description:
      "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
    seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"],
  },
  f$ = {
    name: "qr",
    category: "Algebra",
    syntax: ["qr(A)"],
    description:
      "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
    examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
    seealso: ["lup", "slu", "matrix"],
  },
  m$ = {
    name: "rationalize",
    category: "Algebra",
    syntax: [
      "rationalize(expr)",
      "rationalize(expr, scope)",
      "rationalize(expr, scope, detailed)",
    ],
    description:
      "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
    examples: [
      'rationalize("2x/y - y/(x+1)")',
      'rationalize("2x/y - y/(x+1)", true)',
    ],
    seealso: ["simplify"],
  },
  p$ = {
    name: "resolve",
    category: "Algebra",
    syntax: ["resolve(node, scope)"],
    description: "Recursively substitute variables in an expression tree.",
    examples: [
      'resolve(parse("1 + x"), { x: 7 })',
      'resolve(parse("size(text)"), { text: "Hello World" })',
      'resolve(parse("x + y"), { x: parse("3z") })',
      'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })',
    ],
    seealso: ["simplify", "evaluate"],
    mayThrow: ["ReferenceError"],
  },
  v$ = {
    name: "simplify",
    category: "Algebra",
    syntax: ["simplify(expr)", "simplify(expr, rules)"],
    description: "Simplify an expression tree.",
    examples: [
      'simplify("3 + 2 / 4")',
      'simplify("2x + x")',
      'f = parse("x * (x + 2 + x)")',
      "simplified = simplify(f)",
      "simplified.evaluate({x: 2})",
    ],
    seealso: [
      "simplifyCore",
      "derivative",
      "evaluate",
      "parse",
      "rationalize",
      "resolve",
    ],
  },
  h$ = {
    name: "simplifyCore",
    category: "Algebra",
    syntax: ["simplifyCore(node)"],
    description:
      "Perform simple one-pass simplifications on an expression tree.",
    examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
    seealso: ["simplify", "evaluate"],
  },
  d$ = {
    name: "slu",
    category: "Algebra",
    syntax: ["slu(A, order, threshold)"],
    description:
      "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
    examples: [
      "slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)",
    ],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"],
  },
  g$ = {
    name: "symbolicEqual",
    category: "Algebra",
    syntax: [
      "symbolicEqual(expr1, expr2)",
      "symbolicEqual(expr1, expr2, options)",
    ],
    description:
      "Returns true if the difference of the expressions simplifies to 0",
    examples: [
      'symbolicEqual("x*y","y*x")',
      'symbolicEqual("abs(x^2)", "x^2")',
      'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})',
    ],
    seealso: ["simplify", "evaluate"],
  },
  y$ = {
    name: "usolve",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description:
      "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: [
      "x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])",
    ],
    seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"],
  },
  b$ = {
    name: "usolveAll",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description:
      "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: [
      "x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])",
    ],
    seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"],
  },
  x$ = {
    name: "abs",
    category: "Arithmetic",
    syntax: ["abs(x)"],
    description: "Compute the absolute value.",
    examples: ["abs(3.5)", "abs(-4.2)"],
    seealso: ["sign"],
  },
  w$ = {
    name: "add",
    category: "Operators",
    syntax: ["x + y", "add(x, y)"],
    description: "Add two values.",
    examples: [
      "a = 2.1 + 3.6",
      "a - 3.6",
      "3 + 2i",
      "3 cm + 2 inch",
      '"2.3" + "4"',
    ],
    seealso: ["subtract"],
  },
  N$ = {
    name: "cbrt",
    category: "Arithmetic",
    syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
    description:
      "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
    examples: [
      "cbrt(64)",
      "cube(4)",
      "cbrt(-8)",
      "cbrt(2 + 3i)",
      "cbrt(8i)",
      "cbrt(8i, true)",
      "cbrt(27 m^3)",
    ],
    seealso: ["square", "sqrt", "cube", "multiply"],
  },
  M$ = {
    name: "ceil",
    category: "Arithmetic",
    syntax: ["ceil(x)"],
    description:
      "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
    examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
    seealso: ["floor", "fix", "round"],
  },
  A$ = {
    name: "cube",
    category: "Arithmetic",
    syntax: ["cube(x)"],
    description: "Compute the cube of a value. The cube of x is x * x * x.",
    examples: ["cube(2)", "2^3", "2 * 2 * 2"],
    seealso: ["multiply", "square", "pow"],
  },
  S$ = {
    name: "divide",
    category: "Operators",
    syntax: ["x / y", "divide(x, y)"],
    description: "Divide two values.",
    examples: [
      "a = 2 / 3",
      "a * 3",
      "4.5 / 2",
      "3 + 4 / 2",
      "(3 + 4) / 2",
      "18 km / 4.5",
    ],
    seealso: ["multiply"],
  },
  E$ = {
    name: "dotDivide",
    category: "Operators",
    syntax: ["x ./ y", "dotDivide(x, y)"],
    description: "Divide two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
    seealso: ["multiply", "dotMultiply", "divide"],
  },
  C$ = {
    name: "dotMultiply",
    category: "Operators",
    syntax: ["x .* y", "dotMultiply(x, y)"],
    description: "Multiply two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
    seealso: ["multiply", "divide", "dotDivide"],
  },
  $$ = {
    name: "dotPow",
    category: "Operators",
    syntax: ["x .^ y", "dotPow(x, y)"],
    description: "Calculates the power of x to y element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
    seealso: ["pow"],
  },
  O$ = {
    name: "exp",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Calculate the exponent of a value.",
    examples: [
      "exp(1.3)",
      "e ^ 1.3",
      "log(exp(1.3))",
      "x = 2.4",
      "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula",
    ],
    seealso: ["expm", "expm1", "pow", "log"],
  },
  T$ = {
    name: "expm",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description:
      "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
    examples: ["expm([[0,2],[0,0]])"],
    seealso: ["exp"],
  },
  D$ = {
    name: "expm1",
    category: "Arithmetic",
    syntax: ["expm1(x)"],
    description:
      "Calculate the value of subtracting 1 from the exponential value.",
    examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
    seealso: ["exp", "pow", "log"],
  },
  B$ = {
    name: "fix",
    category: "Arithmetic",
    syntax: ["fix(x)"],
    description:
      "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
    examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
    seealso: ["ceil", "floor", "round"],
  },
  _$ = {
    name: "floor",
    category: "Arithmetic",
    syntax: ["floor(x)"],
    description:
      "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
    examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
    seealso: ["ceil", "fix", "round"],
  },
  I$ = {
    name: "gcd",
    category: "Arithmetic",
    syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
    description: "Compute the greatest common divisor.",
    examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
    seealso: ["lcm", "xgcd"],
  },
  R$ = {
    name: "hypot",
    category: "Arithmetic",
    syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
    description: "Calculate the hypotenusa of a list with values. ",
    examples: [
      "hypot(3, 4)",
      "sqrt(3^2 + 4^2)",
      "hypot(-2)",
      "hypot([3, 4, 5])",
    ],
    seealso: ["abs", "norm"],
  },
  F$ = {
    name: "invmod",
    category: "Arithmetic",
    syntax: ["invmod(a, b)"],
    description:
      "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)",
    examples: [
      "invmod(8, 12)=NaN",
      "invmod(7, 13)=2",
      "math.invmod(15151, 15122)=10429",
    ],
    seealso: ["gcd", "xgcd"],
  },
  P$ = {
    name: "lcm",
    category: "Arithmetic",
    syntax: ["lcm(x, y)"],
    description: "Compute the least common multiple.",
    examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
    seealso: ["gcd"],
  },
  q$ = {
    name: "log",
    category: "Arithmetic",
    syntax: ["log(x)", "log(x, base)"],
    description:
      "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
    examples: [
      "log(3.5)",
      "a = log(2.4)",
      "exp(a)",
      "10 ^ 4",
      "log(10000, 10)",
      "log(10000) / log(10)",
      "b = log(1024, 2)",
      "2 ^ b",
    ],
    seealso: ["exp", "log1p", "log2", "log10"],
  },
  z$ = {
    name: "log10",
    category: "Arithmetic",
    syntax: ["log10(x)"],
    description: "Compute the 10-base logarithm of a value.",
    examples: [
      "log10(0.00001)",
      "log10(10000)",
      "10 ^ 4",
      "log(10000) / log(10)",
      "log(10000, 10)",
    ],
    seealso: ["exp", "log"],
  },
  U$ = {
    name: "log1p",
    category: "Arithmetic",
    syntax: ["log1p(x)", "log1p(x, base)"],
    description: "Calculate the logarithm of a `value+1`",
    examples: [
      "log1p(2.5)",
      "exp(log1p(1.4))",
      "pow(10, 4)",
      "log1p(9999, 10)",
      "log1p(9999) / log(10)",
    ],
    seealso: ["exp", "log", "log2", "log10"],
  },
  L$ = {
    name: "log2",
    category: "Arithmetic",
    syntax: ["log2(x)"],
    description:
      "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
    examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
    seealso: ["exp", "log1p", "log", "log10"],
  },
  k$ = {
    name: "mod",
    category: "Operators",
    syntax: ["x % y", "x mod y", "mod(x, y)"],
    description:
      "Calculates the modulus, the remainder of an integer division.",
    examples: [
      "7 % 3",
      "11 % 2",
      "10 mod 4",
      "isOdd(x) = x % 2",
      "isOdd(2)",
      "isOdd(3)",
    ],
    seealso: ["divide"],
  },
  V$ = {
    name: "multiply",
    category: "Operators",
    syntax: ["x * y", "multiply(x, y)"],
    description: "multiply two values.",
    examples: [
      "a = 2.1 * 3.4",
      "a / 3.4",
      "2 * 3 + 4",
      "2 * (3 + 4)",
      "3 * 2.1 km",
    ],
    seealso: ["divide"],
  },
  G$ = {
    name: "norm",
    category: "Arithmetic",
    syntax: ["norm(x)", "norm(x, p)"],
    description: "Calculate the norm of a number, vector or matrix.",
    examples: [
      "abs(-3.5)",
      "norm(-3.5)",
      "norm(3 - 4i)",
      "norm([1, 2, -3], Infinity)",
      "norm([1, 2, -3], -Infinity)",
      "norm([3, 4], 2)",
      "norm([[1, 2], [3, 4]], 1)",
      'norm([[1, 2], [3, 4]], "inf")',
      'norm([[1, 2], [3, 4]], "fro")',
    ],
  },
  H$ = {
    name: "nthRoot",
    category: "Arithmetic",
    syntax: ["nthRoot(a)", "nthRoot(a, root)"],
    description:
      'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
    examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
    seealso: ["nthRoots", "pow", "sqrt"],
  },
  Z$ = {
    name: "nthRoots",
    category: "Arithmetic",
    syntax: ["nthRoots(A)", "nthRoots(A, root)"],
    description:
      'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
    examples: ["nthRoots(1)", "nthRoots(1, 3)"],
    seealso: ["sqrt", "pow", "nthRoot"],
  },
  J$ = {
    name: "pow",
    category: "Operators",
    syntax: ["x ^ y", "pow(x, y)"],
    description: "Calculates the power of x to y, x^y.",
    examples: [
      "2^3",
      "2*2*2",
      "1 + e ^ (pi * i)",
      "math.pow([[1, 2], [4, 3]], 2)",
      "math.pow([[1, 2], [4, 3]], -1)",
    ],
    seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"],
  },
  W$ = {
    name: "round",
    category: "Arithmetic",
    syntax: ["round(x)", "round(x, n)"],
    description:
      "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
    examples: [
      "round(3.2)",
      "round(3.8)",
      "round(-4.2)",
      "round(-4.8)",
      "round(pi, 3)",
      "round(123.45678, 2)",
    ],
    seealso: ["ceil", "floor", "fix"],
  },
  X$ = {
    name: "sign",
    category: "Arithmetic",
    syntax: ["sign(x)"],
    description:
      "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
    examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
    seealso: ["abs"],
  },
  Y$ = {
    name: "sqrt",
    category: "Arithmetic",
    syntax: ["sqrt(x)"],
    description:
      "Compute the square root value. If x = y * y, then y is the square root of x.",
    examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
    seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"],
  },
  Q$ = {
    name: "sqrtm",
    category: "Arithmetic",
    syntax: ["sqrtm(x)"],
    description:
      "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
    examples: ["sqrtm([[1, 2], [3, 4]])"],
    seealso: ["sqrt", "abs", "square", "multiply"],
  },
  j$ = {
    name: "square",
    category: "Arithmetic",
    syntax: ["square(x)"],
    description: "Compute the square of a value. The square of x is x * x.",
    examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
    seealso: ["multiply", "pow", "sqrt", "cube"],
  },
  K$ = {
    name: "subtract",
    category: "Operators",
    syntax: ["x - y", "subtract(x, y)"],
    description: "subtract two values.",
    examples: [
      "a = 5.3 - 2",
      "a + 2",
      "2/3 - 1/6",
      "2 * 3 - 3",
      "2.1 km - 500m",
    ],
    seealso: ["add"],
  },
  eO = {
    name: "unaryMinus",
    category: "Operators",
    syntax: ["-x", "unaryMinus(x)"],
    description:
      "Inverse the sign of a value. Converts booleans and strings to numbers.",
    examples: ["-4.5", "-(-5.6)", '-"22"'],
    seealso: ["add", "subtract", "unaryPlus"],
  },
  rO = {
    name: "unaryPlus",
    category: "Operators",
    syntax: ["+x", "unaryPlus(x)"],
    description: "Converts booleans and strings to numbers.",
    examples: ["+true", '+"2"'],
    seealso: ["add", "subtract", "unaryMinus"],
  },
  tO = {
    name: "xgcd",
    category: "Arithmetic",
    syntax: ["xgcd(a, b)"],
    description:
      "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
    examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
    seealso: ["gcd", "lcm"],
  },
  nO = {
    name: "bitAnd",
    category: "Bitwise",
    syntax: ["x & y", "bitAnd(x, y)"],
    description:
      "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
    examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
    seealso: [
      "bitNot",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  aO = {
    name: "bitNot",
    category: "Bitwise",
    syntax: ["~x", "bitNot(x)"],
    description:
      "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
    examples: ["~1", "~2", "bitNot([2, -3, 4])"],
    seealso: [
      "bitAnd",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  iO = {
    name: "bitOr",
    category: "Bitwise",
    syntax: ["x | y", "bitOr(x, y)"],
    description:
      "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
    examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitXor",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  oO = {
    name: "bitXor",
    category: "Bitwise",
    syntax: ["bitXor(x, y)"],
    description:
      "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
    examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  sO = {
    name: "leftShift",
    category: "Bitwise",
    syntax: ["x << y", "leftShift(x, y)"],
    description: "Bitwise left logical shift of a value x by y number of bits.",
    examples: ["4 << 1", "8 >> 1"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "bitXor",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  uO = {
    name: "rightArithShift",
    category: "Bitwise",
    syntax: ["x >> y", "rightArithShift(x, y)"],
    description:
      "Bitwise right arithmetic shift of a value x by y number of bits.",
    examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightLogShift",
    ],
  },
  lO = {
    name: "rightLogShift",
    category: "Bitwise",
    syntax: ["x >>> y", "rightLogShift(x, y)"],
    description:
      "Bitwise right logical shift of a value x by y number of bits.",
    examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightArithShift",
    ],
  },
  cO = {
    name: "bellNumbers",
    category: "Combinatorics",
    syntax: ["bellNumbers(n)"],
    description:
      "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["bellNumbers(3)", "bellNumbers(8)"],
    seealso: ["stirlingS2"],
  },
  fO = {
    name: "catalan",
    category: "Combinatorics",
    syntax: ["catalan(n)"],
    description:
      "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["catalan(3)", "catalan(8)"],
    seealso: ["bellNumbers"],
  },
  mO = {
    name: "composition",
    category: "Combinatorics",
    syntax: ["composition(n, k)"],
    description:
      "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
    examples: ["composition(5, 3)"],
    seealso: ["combinations"],
  },
  pO = {
    name: "stirlingS2",
    category: "Combinatorics",
    syntax: ["stirlingS2(n, k)"],
    description:
      "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
    examples: ["stirlingS2(5, 3)"],
    seealso: ["bellNumbers"],
  },
  vO = {
    name: "arg",
    category: "Complex",
    syntax: ["arg(x)"],
    description:
      "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
    examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
    seealso: ["re", "im", "conj", "abs"],
  },
  hO = {
    name: "conj",
    category: "Complex",
    syntax: ["conj(x)"],
    description:
      "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
    examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
    seealso: ["re", "im", "abs", "arg"],
  },
  dO = {
    name: "im",
    category: "Complex",
    syntax: ["im(x)"],
    description: "Get the imaginary part of a complex number.",
    examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
    seealso: ["re", "conj", "abs", "arg"],
  },
  gO = {
    name: "re",
    category: "Complex",
    syntax: ["re(x)"],
    description: "Get the real part of a complex number.",
    examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
    seealso: ["im", "conj", "abs", "arg"],
  },
  yO = {
    name: "evaluate",
    category: "Expression",
    syntax: ["evaluate(expression)", "evaluate([expr1, expr2, expr3, ...])"],
    description: "Evaluate an expression or an array with expressions.",
    examples: ['evaluate("2 + 3")', 'evaluate("sqrt(" + 4 + ")")'],
    seealso: [],
  },
  bO = {
    name: "help",
    category: "Expression",
    syntax: ["help(object)", "help(string)"],
    description: "Display documentation on a function or data type.",
    examples: ["help(sqrt)", 'help("complex")'],
    seealso: [],
  },
  xO = {
    name: "distance",
    category: "Geometry",
    syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
    description: "Calculates the Euclidean distance between two points.",
    examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
    seealso: [],
  },
  wO = {
    name: "intersect",
    category: "Geometry",
    syntax: [
      "intersect(expr1, expr2, expr3, expr4)",
      "intersect(expr1, expr2, expr3)",
    ],
    description: "Computes the intersection point of lines and/or planes.",
    examples: [
      "intersect([0, 0], [10, 10], [10, 0], [0, 10])",
      "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])",
    ],
    seealso: [],
  },
  NO = {
    name: "and",
    category: "Logical",
    syntax: ["x and y", "and(x, y)"],
    description:
      "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
    examples: ["true and false", "true and true", "2 and 4"],
    seealso: ["not", "or", "xor"],
  },
  MO = {
    name: "not",
    category: "Logical",
    syntax: ["not x", "not(x)"],
    description: "Logical not. Flips the boolean value of given argument.",
    examples: ["not true", "not false", "not 2", "not 0"],
    seealso: ["and", "or", "xor"],
  },
  AO = {
    name: "or",
    category: "Logical",
    syntax: ["x or y", "or(x, y)"],
    description:
      "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
    examples: ["true or false", "false or false", "0 or 4"],
    seealso: ["not", "and", "xor"],
  },
  SO = {
    name: "xor",
    category: "Logical",
    syntax: ["x xor y", "xor(x, y)"],
    description:
      "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
    examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
    seealso: ["not", "and", "or"],
  },
  EO = {
    name: "column",
    category: "Matrix",
    syntax: ["column(x, index)"],
    description: "Return a column from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
    seealso: ["row", "matrixFromColumns"],
  },
  CO = {
    name: "concat",
    category: "Matrix",
    syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
    description:
      "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
    examples: [
      "A = [1, 2; 5, 6]",
      "B = [3, 4; 7, 8]",
      "concat(A, B)",
      "concat(A, B, 1)",
      "concat(A, B, 2)",
    ],
    seealso: [
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  $O = {
    name: "count",
    category: "Matrix",
    syntax: ["count(x)"],
    description: "Count the number of elements of a matrix, array or string.",
    examples: [
      "a = [1, 2; 3, 4; 5, 6]",
      "count(a)",
      "size(a)",
      'count("hello world")',
    ],
    seealso: ["size"],
  },
  OO = {
    name: "cross",
    category: "Matrix",
    syntax: ["cross(A, B)"],
    description:
      "Calculate the cross product for two vectors in three dimensional space.",
    examples: [
      "cross([1, 1, 0],  [0, 1, 1])",
      "cross([3, -3, 1], [4, 9, 2])",
      "cross([2, 3, 4],  [5, 6, 7])",
    ],
    seealso: ["multiply", "dot"],
  },
  TO = {
    name: "ctranspose",
    category: "Matrix",
    syntax: ["x'", "ctranspose(x)"],
    description: "Complex Conjugate and Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "zeros",
    ],
  },
  DO = {
    name: "det",
    category: "Matrix",
    syntax: ["det(x)"],
    description: "Calculate the determinant of a matrix",
    examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
    seealso: [
      "concat",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  BO = {
    name: "diag",
    category: "Matrix",
    syntax: ["diag(x)", "diag(x, k)"],
    description:
      "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
    examples: [
      "diag(1:3)",
      "diag(1:3, 1)",
      "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]",
      "diag(a)",
    ],
    seealso: [
      "concat",
      "det",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  _O = {
    name: "diff",
    category: "Matrix",
    syntax: ["diff(arr)", "diff(arr, dim)"],
    description: [
      "Create a new matrix or array with the difference of the passed matrix or array.",
      "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference",
      "If no dimension parameter is passed it is assumed as dimension 0",
      "Dimension is zero-based in javascript and one-based in the parser",
      "Arrays must be 'rectangular' meaning arrays like [1, 2]",
      "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays",
    ],
    examples: [
      "diff([1, 2, 4, 7, 0])",
      "diff([1, 2, 4, 7, 0], 0)",
      "diff(matrix([1, 2, 4, 7, 0]))",
      "diff([[1, 2], [3, 4]])",
      "diff([[1, 2], [3, 4]], 0)",
      "diff([[1, 2], [3, 4]], 1)",
      "diff([[1, 2], [3, 4]], bignumber(1))",
      "diff(matrix([[1, 2], [3, 4]]), 1)",
      "diff([[1, 2], matrix([3, 4])], 1)",
    ],
    seealso: ["subtract", "partitionSelect"],
  },
  IO = {
    name: "dot",
    category: "Matrix",
    syntax: ["dot(A, B)", "A * B"],
    description:
      "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
    examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
    seealso: ["multiply", "cross"],
  },
  RO = {
    name: "eigs",
    category: "Matrix",
    syntax: ["eigs(x)"],
    description:
      "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
    examples: ["eigs([[5, 2.3], [2.3, 1]])"],
    seealso: ["inv"],
  },
  FO = {
    name: "filter",
    category: "Matrix",
    syntax: ["filter(x, test)"],
    description: "Filter items in a matrix.",
    examples: [
      "isPositive(x) = x > 0",
      "filter([6, -2, -1, 4, 3], isPositive)",
      "filter([6, -2, 0, 1, 0], x != 0)",
    ],
    seealso: ["sort", "map", "forEach"],
  },
  PO = {
    name: "flatten",
    category: "Matrix",
    syntax: ["flatten(x)"],
    description:
      "Flatten a multi dimensional matrix into a single dimensional matrix.",
    examples: [
      "a = [1, 2, 3; 4, 5, 6]",
      "size(a)",
      "b = flatten(a)",
      "size(b)",
    ],
    seealso: ["concat", "resize", "size", "squeeze"],
  },
  qO = {
    name: "forEach",
    category: "Matrix",
    syntax: ["forEach(x, callback)"],
    description:
      "Iterates over all elements of a matrix/array, and executes the given callback function.",
    examples: [
      "numberOfPets = {}",
      "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;",
      'forEach(["Dog","Cat","Cat"], addPet)',
      "numberOfPets",
    ],
    seealso: ["map", "sort", "filter"],
  },
  zO = {
    name: "getMatrixDataType",
    category: "Matrix",
    syntax: ["getMatrixDataType(x)"],
    description:
      'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
    examples: [
      "getMatrixDataType([1, 2, 3])",
      "getMatrixDataType([[5 cm], [2 inch]])",
      'getMatrixDataType([1, "text"])',
      "getMatrixDataType([1, bignumber(4)])",
    ],
    seealso: ["matrix", "sparse", "typeOf"],
  },
  UO = {
    name: "identity",
    category: "Matrix",
    syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
    description:
      "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
    examples: [
      "identity(3)",
      "identity(3, 5)",
      "a = [1, 2, 3; 4, 5, 6]",
      "identity(size(a))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  LO = {
    name: "inv",
    category: "Matrix",
    syntax: ["inv(x)"],
    description: "Calculate the inverse of a matrix",
    examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  kO = {
    name: "pinv",
    category: "Matrix",
    syntax: ["pinv(x)"],
    description: "Calculate the Moore–Penrose inverse of a matrix",
    examples: [
      "pinv([1, 2; 3, 4])",
      "pinv([[1, 0], [0, 1], [0, 1]])",
      "pinv(4)",
    ],
    seealso: ["inv"],
  },
  VO = {
    name: "kron",
    category: "Matrix",
    syntax: ["kron(x, y)"],
    description: "Calculates the kronecker product of 2 matrices or vectors.",
    examples: [
      "kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])",
      "kron([1,1], [2,3,4])",
    ],
    seealso: ["multiply", "dot", "cross"],
  },
  GO = {
    name: "map",
    category: "Matrix",
    syntax: ["map(x, callback)"],
    description:
      "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
    examples: ["map([1, 2, 3], square)"],
    seealso: ["filter", "forEach"],
  },
  HO = {
    name: "matrixFromColumns",
    category: "Matrix",
    syntax: [
      "math.matrixFromColumns(...arr)",
      "math.matrixFromColumns(row1, row2)",
      "math.matrixFromColumns(row1, row2, row3)",
    ],
    description: "Create a dense matrix from vectors as individual columns.",
    examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"],
  },
  ZO = {
    name: "matrixFromFunction",
    category: "Matrix",
    syntax: [
      "math.matrixFromFunction(size, fn)",
      "math.matrixFromFunction(size, fn, format)",
      "math.matrixFromFunction(size, fn, format, datatype)",
      "math.matrixFromFunction(size, format, fn)",
      "math.matrixFromFunction(size, format, datatype, fn)",
    ],
    description:
      "Create a matrix by evaluating a generating function at each index.",
    examples: [
      "f(I) = I[1] - I[2]",
      "matrixFromFunction([3,3], f)",
      "g(I) = I[1] - I[2] == 1 ? 4 : 0",
      'matrixFromFunction([100, 100], "sparse", g)',
      "matrixFromFunction([5], random)",
    ],
    seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"],
  },
  JO = {
    name: "matrixFromRows",
    category: "Matrix",
    syntax: [
      "math.matrixFromRows(...arr)",
      "math.matrixFromRows(row1, row2)",
      "math.matrixFromRows(row1, row2, row3)",
    ],
    description: "Create a dense matrix from vectors as individual rows.",
    examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"],
  },
  WO = {
    name: "ones",
    category: "Matrix",
    syntax: [
      "ones(m)",
      "ones(m, n)",
      "ones(m, n, p, ...)",
      "ones([m])",
      "ones([m, n])",
      "ones([m, n, p, ...])",
    ],
    description: "Create a matrix containing ones.",
    examples: [
      "ones(3)",
      "ones(3, 5)",
      "ones([2,3]) * 4.5",
      "a = [1, 2, 3; 4, 5, 6]",
      "ones(size(a))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  XO = {
    name: "partitionSelect",
    category: "Matrix",
    syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
    description:
      "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
    examples: [
      "partitionSelect([5, 10, 1], 2)",
      'partitionSelect(["C", "B", "A", "D"], 1)',
    ],
    seealso: ["sort"],
  },
  YO = {
    name: "range",
    category: "Type",
    syntax: [
      "start:end",
      "start:step:end",
      "range(start, end)",
      "range(start, end, step)",
      "range(string)",
    ],
    description:
      "Create a range. Lower bound of the range is included, upper bound is excluded.",
    examples: [
      "1:5",
      "3:-1:-3",
      "range(3, 7)",
      "range(0, 12, 2)",
      'range("4:10")',
      "a = [1, 2, 3, 4; 5, 6, 7, 8]",
      "a[1:2, 1:2]",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  QO = {
    name: "reshape",
    category: "Matrix",
    syntax: ["reshape(x, sizes)"],
    description:
      "Reshape a multi dimensional array to fit the specified dimensions.",
    examples: [
      "reshape([1, 2, 3, 4, 5, 6], [2, 3])",
      "reshape([[1, 2], [3, 4]], [1, 4])",
      "reshape([[1, 2], [3, 4]], [4])",
    ],
    seealso: ["size", "squeeze", "resize"],
  },
  jO = {
    name: "resize",
    category: "Matrix",
    syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
    description: "Resize a matrix.",
    examples: [
      "resize([1,2,3,4,5], [3])",
      "resize([1,2,3], [5])",
      "resize([1,2,3], [5], -1)",
      "resize(2, [2, 3])",
      'resize("hello", [8], "!")',
    ],
    seealso: ["size", "subset", "squeeze", "reshape"],
  },
  KO = {
    name: "rotate",
    category: "Matrix",
    syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
    description:
      "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: [
      "rotate([1, 0], math.pi / 2)",
      'rotate(matrix([1, 0]), unit("35deg"))',
      'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])',
      'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))',
    ],
    seealso: ["matrix", "rotationMatrix"],
  },
  eT = {
    name: "rotationMatrix",
    category: "Matrix",
    syntax: [
      "rotationMatrix(theta)",
      "rotationMatrix(theta, v)",
      "rotationMatrix(theta, v, format)",
    ],
    description:
      "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: [
      "rotationMatrix(pi / 2)",
      'rotationMatrix(unit("45deg"), [0, 0, 1])',
      'rotationMatrix(1, matrix([0, 0, 1]), "sparse")',
    ],
    seealso: ["cos", "sin"],
  },
  rT = {
    name: "row",
    category: "Matrix",
    syntax: ["row(x, index)"],
    description: "Return a row from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
    seealso: ["column", "matrixFromRows"],
  },
  tT = {
    name: "size",
    category: "Matrix",
    syntax: ["size(x)"],
    description: "Calculate the size of a matrix.",
    examples: [
      "size(2.3)",
      'size("hello world")',
      "a = [1, 2; 3, 4; 5, 6]",
      "size(a)",
      "size(1:6)",
    ],
    seealso: [
      "concat",
      "count",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  nT = {
    name: "sort",
    category: "Matrix",
    syntax: ["sort(x)", "sort(x, compare)"],
    description:
      'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
    examples: [
      "sort([5, 10, 1])",
      'sort(["C", "B", "A", "D"])',
      "sortByLength(a, b) = size(a)[1] - size(b)[1]",
      'sort(["Langdon", "Tom", "Sara"], sortByLength)',
      'sort(["10", "1", "2"], "natural")',
    ],
    seealso: ["map", "filter", "forEach"],
  },
  aT = {
    name: "squeeze",
    category: "Matrix",
    syntax: ["squeeze(x)"],
    description: "Remove inner and outer singleton dimensions from a matrix.",
    examples: [
      "a = zeros(3,2,1)",
      "size(squeeze(a))",
      "b = zeros(1,1,3)",
      "size(squeeze(b))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  iT = {
    name: "subset",
    category: "Matrix",
    syntax: [
      "value(index)",
      "value(index) = replacement",
      "subset(value, [index])",
      "subset(value, [index], replacement)",
    ],
    description:
      "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
    examples: [
      "d = [1, 2; 3, 4]",
      "e = []",
      "e[1, 1:2] = [5, 6]",
      "e[2, :] = [7, 8]",
      "f = d * e",
      "f[2, 1]",
      "f[:, 1]",
      "f[[1,2], [1,3]] = [9, 10; 11, 12]",
      "f",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  oT = {
    name: "trace",
    category: "Matrix",
    syntax: ["trace(A)"],
    description:
      "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
    examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "transpose",
      "zeros",
    ],
  },
  sT = {
    name: "transpose",
    category: "Matrix",
    syntax: ["x'", "transpose(x)"],
    description: "Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "zeros",
    ],
  },
  uT = {
    name: "zeros",
    category: "Matrix",
    syntax: [
      "zeros(m)",
      "zeros(m, n)",
      "zeros(m, n, p, ...)",
      "zeros([m])",
      "zeros([m, n])",
      "zeros([m, n, p, ...])",
    ],
    description: "Create a matrix containing zeros.",
    examples: [
      "zeros(3)",
      "zeros(3, 5)",
      "a = [1, 2, 3; 4, 5, 6]",
      "zeros(size(a))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
    ],
  },
  lT = {
    name: "fft",
    category: "Matrix",
    syntax: ["fft(x)"],
    description: "Calculate N-dimensional fourier transform",
    examples: ["fft([[1, 0], [1, 0]])"],
    seealso: ["ifft"],
  },
  cT = {
    name: "ifft",
    category: "Matrix",
    syntax: ["ifft(x)"],
    description: "Calculate N-dimensional inverse fourier transform",
    examples: ["ifft([[2, 2], [0, 0]])"],
    seealso: ["fft"],
  },
  fT = {
    name: "combinations",
    category: "Probability",
    syntax: ["combinations(n, k)"],
    description:
      "Compute the number of combinations of n items taken k at a time",
    examples: ["combinations(7, 5)"],
    seealso: ["combinationsWithRep", "permutations", "factorial"],
  },
  mT = {
    name: "combinationsWithRep",
    category: "Probability",
    syntax: ["combinationsWithRep(n, k)"],
    description:
      "Compute the number of combinations of n items taken k at a time with replacements.",
    examples: ["combinationsWithRep(7, 5)"],
    seealso: ["combinations", "permutations", "factorial"],
  },
  pT = {
    name: "factorial",
    category: "Probability",
    syntax: ["n!", "factorial(n)"],
    description: "Compute the factorial of a value",
    examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
    seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"],
  },
  vT = {
    name: "gamma",
    category: "Probability",
    syntax: ["gamma(n)"],
    description:
      "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
    examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
    seealso: ["factorial"],
  },
  hT = {
    name: "lgamma",
    category: "Probability",
    syntax: ["lgamma(n)"],
    description:
      "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
    examples: [
      "lgamma(4)",
      "lgamma(1/2)",
      "lgamma(math.i)",
      "lgamma(complex(1.1, 2))",
    ],
    seealso: ["gamma"],
  },
  dT = {
    name: "kldivergence",
    category: "Probability",
    syntax: ["kldivergence(x, y)"],
    description:
      "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
    examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
    seealso: [],
  },
  gT = {
    name: "multinomial",
    category: "Probability",
    syntax: ["multinomial(A)"],
    description:
      "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
    examples: ["multinomial([1, 2, 1])"],
    seealso: ["combinations", "factorial"],
  },
  yT = {
    name: "permutations",
    category: "Probability",
    syntax: ["permutations(n)", "permutations(n, k)"],
    description:
      "Compute the number of permutations of n items taken k at a time",
    examples: ["permutations(5)", "permutations(5, 3)"],
    seealso: ["combinations", "combinationsWithRep", "factorial"],
  },
  bT = {
    name: "pickRandom",
    category: "Probability",
    syntax: [
      "pickRandom(array)",
      "pickRandom(array, number)",
      "pickRandom(array, weights)",
      "pickRandom(array, number, weights)",
      "pickRandom(array, weights, number)",
    ],
    description: "Pick a random entry from a given array.",
    examples: [
      "pickRandom(0:10)",
      "pickRandom([1, 3, 1, 6])",
      "pickRandom([1, 3, 1, 6], 2)",
      "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])",
      "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])",
      "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)",
    ],
    seealso: ["random", "randomInt"],
  },
  xT = {
    name: "random",
    category: "Probability",
    syntax: [
      "random()",
      "random(max)",
      "random(min, max)",
      "random(size)",
      "random(size, max)",
      "random(size, min, max)",
    ],
    description: "Return a random number.",
    examples: ["random()", "random(10, 20)", "random([2, 3])"],
    seealso: ["pickRandom", "randomInt"],
  },
  wT = {
    name: "randomInt",
    category: "Probability",
    syntax: [
      "randomInt(max)",
      "randomInt(min, max)",
      "randomInt(size)",
      "randomInt(size, max)",
      "randomInt(size, min, max)",
    ],
    description: "Return a random integer number",
    examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
    seealso: ["pickRandom", "random"],
  },
  NT = {
    name: "compare",
    category: "Relational",
    syntax: ["compare(x, y)"],
    description:
      "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: [
      "compare(2, 3)",
      "compare(3, 2)",
      "compare(2, 2)",
      "compare(5cm, 40mm)",
      "compare(2, [1, 2, 3])",
    ],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "smallerEq",
      "largerEq",
      "compareNatural",
      "compareText",
    ],
  },
  MT = {
    name: "compareNatural",
    category: "Relational",
    syntax: ["compareNatural(x, y)"],
    description:
      "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: [
      "compareNatural(2, 3)",
      "compareNatural(3, 2)",
      "compareNatural(2, 2)",
      "compareNatural(5cm, 40mm)",
      'compareNatural("2", "10")',
      "compareNatural(2 + 3i, 2 + 4i)",
      "compareNatural([1, 2, 4], [1, 2, 3])",
      "compareNatural([1, 5], [1, 2, 3])",
      "compareNatural([1, 2], [1, 2])",
      "compareNatural({a: 2}, {a: 4})",
    ],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "smallerEq",
      "largerEq",
      "compare",
      "compareText",
    ],
  },
  AT = {
    name: "compareText",
    category: "Relational",
    syntax: ["compareText(x, y)"],
    description:
      "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: [
      'compareText("B", "A")',
      'compareText("A", "B")',
      'compareText("A", "A")',
      'compareText("2", "10")',
      'compare("2", "10")',
      "compare(2, 10)",
      'compareNatural("2", "10")',
      'compareText("B", ["A", "B", "C"])',
    ],
    seealso: ["compare", "compareNatural"],
  },
  ST = {
    name: "deepEqual",
    category: "Relational",
    syntax: ["deepEqual(x, y)"],
    description:
      "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
    examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "larger",
      "smallerEq",
      "largerEq",
      "compare",
    ],
  },
  ET = {
    name: "equal",
    category: "Relational",
    syntax: ["x == y", "equal(x, y)"],
    description:
      "Check equality of two values. Returns true if the values are equal, and false if not.",
    examples: [
      "2+2 == 3",
      "2+2 == 4",
      "a = 3.2",
      "b = 6-2.8",
      "a == b",
      "50cm == 0.5m",
    ],
    seealso: [
      "unequal",
      "smaller",
      "larger",
      "smallerEq",
      "largerEq",
      "compare",
      "deepEqual",
      "equalText",
    ],
  },
  CT = {
    name: "equalText",
    category: "Relational",
    syntax: ["equalText(x, y)"],
    description:
      "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
    examples: [
      'equalText("Hello", "Hello")',
      'equalText("a", "A")',
      'equal("2e3", "2000")',
      'equalText("2e3", "2000")',
      'equalText("B", ["A", "B", "C"])',
    ],
    seealso: ["compare", "compareNatural", "compareText", "equal"],
  },
  $T = {
    name: "larger",
    category: "Relational",
    syntax: ["x > y", "larger(x, y)"],
    description:
      "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
    examples: [
      "2 > 3",
      "5 > 2*2",
      "a = 3.3",
      "b = 6-2.8",
      "(a > b)",
      "(b < a)",
      "5 cm > 2 inch",
    ],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "smallerEq",
      "largerEq",
      "compare",
    ],
  },
  OT = {
    name: "largerEq",
    category: "Relational",
    syntax: ["x >= y", "largerEq(x, y)"],
    description:
      "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
    examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
    seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"],
  },
  TT = {
    name: "smaller",
    category: "Relational",
    syntax: ["x < y", "smaller(x, y)"],
    description:
      "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
    examples: [
      "2 < 3",
      "5 < 2*2",
      "a = 3.3",
      "b = 6-2.8",
      "(a < b)",
      "5 cm < 2 inch",
    ],
    seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"],
  },
  DT = {
    name: "smallerEq",
    category: "Relational",
    syntax: ["x <= y", "smallerEq(x, y)"],
    description:
      "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
    seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"],
  },
  BT = {
    name: "unequal",
    category: "Relational",
    syntax: ["x != y", "unequal(x, y)"],
    description:
      "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
    examples: [
      "2+2 != 3",
      "2+2 != 4",
      "a = 3.2",
      "b = 6-2.8",
      "a != b",
      "50cm != 0.5m",
      "5 cm != 2 inch",
    ],
    seealso: [
      "equal",
      "smaller",
      "larger",
      "smallerEq",
      "largerEq",
      "compare",
      "deepEqual",
    ],
  },
  _T = {
    name: "setCartesian",
    category: "Set",
    syntax: ["setCartesian(set1, set2)"],
    description:
      "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
    examples: ["setCartesian([1, 2], [3, 4])"],
    seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"],
  },
  IT = {
    name: "setDifference",
    category: "Set",
    syntax: ["setDifference(set1, set2)"],
    description:
      "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setDifference([1, 2, 3, 4], [3, 4, 5, 6])",
      "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setUnion", "setIntersect", "setSymDifference"],
  },
  RT = {
    name: "setDistinct",
    category: "Set",
    syntax: ["setDistinct(set)"],
    description:
      "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
    seealso: ["setMultiplicity"],
  },
  FT = {
    name: "setIntersect",
    category: "Set",
    syntax: ["setIntersect(set1, set2)"],
    description:
      "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setIntersect([1, 2, 3, 4], [3, 4, 5, 6])",
      "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setUnion", "setDifference"],
  },
  PT = {
    name: "setIsSubset",
    category: "Set",
    syntax: ["setIsSubset(set1, set2)"],
    description:
      "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setIsSubset([1, 2], [3, 4, 5, 6])",
      "setIsSubset([3, 4], [3, 4, 5, 6])",
    ],
    seealso: ["setUnion", "setIntersect", "setDifference"],
  },
  qT = {
    name: "setMultiplicity",
    category: "Set",
    syntax: ["setMultiplicity(element, set)"],
    description:
      "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: [
      "setMultiplicity(1, [1, 2, 2, 4])",
      "setMultiplicity(2, [1, 2, 2, 4])",
    ],
    seealso: ["setDistinct", "setSize"],
  },
  zT = {
    name: "setPowerset",
    category: "Set",
    syntax: ["setPowerset(set)"],
    description:
      "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setPowerset([1, 2, 3])"],
    seealso: ["setCartesian"],
  },
  UT = {
    name: "setSize",
    category: "Set",
    syntax: ["setSize(set)", "setSize(set, unique)"],
    description:
      'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
    seealso: ["setUnion", "setIntersect", "setDifference"],
  },
  LT = {
    name: "setSymDifference",
    category: "Set",
    syntax: ["setSymDifference(set1, set2)"],
    description:
      "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])",
      "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setUnion", "setIntersect", "setDifference"],
  },
  kT = {
    name: "setUnion",
    category: "Set",
    syntax: ["setUnion(set1, set2)"],
    description:
      "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setUnion([1, 2, 3, 4], [3, 4, 5, 6])",
      "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setIntersect", "setDifference"],
  },
  VT = {
    name: "erf",
    category: "Special",
    syntax: ["erf(x)"],
    description:
      "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
    examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
    seealso: [],
  },
  GT = {
    name: "mad",
    category: "Statistics",
    syntax: ["mad(a, b, c, ...)", "mad(A)"],
    description:
      "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
    examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
    seealso: ["mean", "median", "std", "abs"],
  },
  HT = {
    name: "max",
    category: "Statistics",
    syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dim)"],
    description: "Compute the maximum value of a list of values.",
    examples: [
      "max(2, 3, 4, 1)",
      "max([2, 3, 4, 1])",
      "max([2, 5; 4, 3])",
      "max([2, 5; 4, 3], 1)",
      "max([2, 5; 4, 3], 2)",
      "max(2.7, 7.1, -4.5, 2.0, 4.1)",
      "min(2.7, 7.1, -4.5, 2.0, 4.1)",
    ],
    seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"],
  },
  ZT = {
    name: "mean",
    category: "Statistics",
    syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dim)"],
    description: "Compute the arithmetic mean of a list of values.",
    examples: [
      "mean(2, 3, 4, 1)",
      "mean([2, 3, 4, 1])",
      "mean([2, 5; 4, 3])",
      "mean([2, 5; 4, 3], 1)",
      "mean([2, 5; 4, 3], 2)",
      "mean([1.0, 2.7, 3.2, 4.0])",
    ],
    seealso: ["max", "median", "min", "prod", "std", "sum", "variance"],
  },
  JT = {
    name: "median",
    category: "Statistics",
    syntax: ["median(a, b, c, ...)", "median(A)"],
    description:
      "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
    examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
    seealso: [
      "max",
      "mean",
      "min",
      "prod",
      "std",
      "sum",
      "variance",
      "quantileSeq",
    ],
  },
  WT = {
    name: "min",
    category: "Statistics",
    syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dim)"],
    description: "Compute the minimum value of a list of values.",
    examples: [
      "min(2, 3, 4, 1)",
      "min([2, 3, 4, 1])",
      "min([2, 5; 4, 3])",
      "min([2, 5; 4, 3], 1)",
      "min([2, 5; 4, 3], 2)",
      "min(2.7, 7.1, -4.5, 2.0, 4.1)",
      "max(2.7, 7.1, -4.5, 2.0, 4.1)",
    ],
    seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"],
  },
  XT = {
    name: "mode",
    category: "Statistics",
    syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
    description:
      "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
    examples: [
      "mode(2, 1, 4, 3, 1)",
      "mode([1, 2.7, 3.2, 4, 2.7])",
      "mode(1, 4, 6, 1, 6)",
    ],
    seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"],
  },
  YT = {
    name: "prod",
    category: "Statistics",
    syntax: ["prod(a, b, c, ...)", "prod(A)"],
    description: "Compute the product of all values.",
    examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
    seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"],
  },
  QT = {
    name: "quantileSeq",
    category: "Statistics",
    syntax: [
      "quantileSeq(A, prob[, sorted])",
      "quantileSeq(A, [prob1, prob2, ...][, sorted])",
      "quantileSeq(A, N[, sorted])",
    ],
    description: `Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. 

In case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.`,
    examples: [
      "quantileSeq([3, -1, 5, 7], 0.5)",
      "quantileSeq([3, -1, 5, 7], [1/3, 2/3])",
      "quantileSeq([3, -1, 5, 7], 2)",
      "quantileSeq([-1, 3, 5, 7], 0.5, true)",
    ],
    seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"],
  },
  jT = {
    name: "std",
    category: "Statistics",
    syntax: ["std(a, b, c, ...)", "std(A)", "std(A, normalization)"],
    description:
      'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: [
      "std(2, 4, 6)",
      "std([2, 4, 6, 8])",
      'std([2, 4, 6, 8], "uncorrected")',
      'std([2, 4, 6, 8], "biased")',
      "std([1, 2, 3; 4, 5, 6])",
    ],
    seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"],
  },
  KT = {
    name: "cumsum",
    category: "Statistics",
    syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
    description: "Compute the cumulative sum of all values.",
    examples: [
      "cumsum(2, 3, 4, 1)",
      "cumsum([2, 3, 4, 1])",
      "cumsum([1, 2; 3, 4])",
      "cumsum([1, 2; 3, 4], 1)",
      "cumsum([1, 2; 3, 4], 2)",
    ],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"],
  },
  e4 = {
    name: "sum",
    category: "Statistics",
    syntax: ["sum(a, b, c, ...)", "sum(A)"],
    description: "Compute the sum of all values.",
    examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"],
  },
  r4 = {
    name: "variance",
    category: "Statistics",
    syntax: [
      "variance(a, b, c, ...)",
      "variance(A)",
      "variance(A, normalization)",
    ],
    description:
      'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: [
      "variance(2, 4, 6)",
      "variance([2, 4, 6, 8])",
      'variance([2, 4, 6, 8], "uncorrected")',
      'variance([2, 4, 6, 8], "biased")',
      "variance([1, 2, 3; 4, 5, 6])",
    ],
    seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"],
  },
  t4 = {
    name: "acos",
    category: "Trigonometry",
    syntax: ["acos(x)"],
    description: "Compute the inverse cosine of a value in radians.",
    examples: ["acos(0.5)", "acos(cos(2.3))"],
    seealso: ["cos", "atan", "asin"],
  },
  n4 = {
    name: "acosh",
    category: "Trigonometry",
    syntax: ["acosh(x)"],
    description:
      "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
    examples: ["acosh(1.5)"],
    seealso: ["cosh", "asinh", "atanh"],
  },
  a4 = {
    name: "acot",
    category: "Trigonometry",
    syntax: ["acot(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
    seealso: ["cot", "atan"],
  },
  i4 = {
    name: "acoth",
    category: "Trigonometry",
    syntax: ["acoth(x)"],
    description:
      "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
    examples: ["acoth(2)", "acoth(0.5)"],
    seealso: ["acsch", "asech"],
  },
  o4 = {
    name: "acsc",
    category: "Trigonometry",
    syntax: ["acsc(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
    seealso: ["csc", "asin", "asec"],
  },
  s4 = {
    name: "acsch",
    category: "Trigonometry",
    syntax: ["acsch(x)"],
    description:
      "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
    examples: ["acsch(0.5)"],
    seealso: ["asech", "acoth"],
  },
  u4 = {
    name: "asec",
    category: "Trigonometry",
    syntax: ["asec(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
    seealso: ["acos", "acot", "acsc"],
  },
  l4 = {
    name: "asech",
    category: "Trigonometry",
    syntax: ["asech(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asech(0.5)"],
    seealso: ["acsch", "acoth"],
  },
  c4 = {
    name: "asin",
    category: "Trigonometry",
    syntax: ["asin(x)"],
    description: "Compute the inverse sine of a value in radians.",
    examples: ["asin(0.5)", "asin(sin(0.5))"],
    seealso: ["sin", "acos", "atan"],
  },
  f4 = {
    name: "asinh",
    category: "Trigonometry",
    syntax: ["asinh(x)"],
    description:
      "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
    examples: ["asinh(0.5)"],
    seealso: ["acosh", "atanh"],
  },
  m4 = {
    name: "atan",
    category: "Trigonometry",
    syntax: ["atan(x)"],
    description: "Compute the inverse tangent of a value in radians.",
    examples: ["atan(0.5)", "atan(tan(0.5))"],
    seealso: ["tan", "acos", "asin"],
  },
  p4 = {
    name: "atan2",
    category: "Trigonometry",
    syntax: ["atan2(y, x)"],
    description:
      "Computes the principal value of the arc tangent of y/x in radians.",
    examples: [
      "atan2(2, 2) / pi",
      "angle = 60 deg in rad",
      "x = cos(angle)",
      "y = sin(angle)",
      "atan2(y, x)",
    ],
    seealso: ["sin", "cos", "tan"],
  },
  v4 = {
    name: "atanh",
    category: "Trigonometry",
    syntax: ["atanh(x)"],
    description:
      "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
    examples: ["atanh(0.5)"],
    seealso: ["acosh", "asinh"],
  },
  h4 = {
    name: "cos",
    category: "Trigonometry",
    syntax: ["cos(x)"],
    description: "Compute the cosine of x in radians.",
    examples: [
      "cos(2)",
      "cos(pi / 4) ^ 2",
      "cos(180 deg)",
      "cos(60 deg)",
      "sin(0.2)^2 + cos(0.2)^2",
    ],
    seealso: ["acos", "sin", "tan"],
  },
  d4 = {
    name: "cosh",
    category: "Trigonometry",
    syntax: ["cosh(x)"],
    description: "Compute the hyperbolic cosine of x in radians.",
    examples: ["cosh(0.5)"],
    seealso: ["sinh", "tanh", "coth"],
  },
  g4 = {
    name: "cot",
    category: "Trigonometry",
    syntax: ["cot(x)"],
    description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
    examples: ["cot(2)", "1 / tan(2)"],
    seealso: ["sec", "csc", "tan"],
  },
  y4 = {
    name: "coth",
    category: "Trigonometry",
    syntax: ["coth(x)"],
    description: "Compute the hyperbolic cotangent of x in radians.",
    examples: ["coth(2)", "1 / tanh(2)"],
    seealso: ["sech", "csch", "tanh"],
  },
  b4 = {
    name: "csc",
    category: "Trigonometry",
    syntax: ["csc(x)"],
    description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
    examples: ["csc(2)", "1 / sin(2)"],
    seealso: ["sec", "cot", "sin"],
  },
  x4 = {
    name: "csch",
    category: "Trigonometry",
    syntax: ["csch(x)"],
    description:
      "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
    examples: ["csch(2)", "1 / sinh(2)"],
    seealso: ["sech", "coth", "sinh"],
  },
  w4 = {
    name: "sec",
    category: "Trigonometry",
    syntax: ["sec(x)"],
    description: "Compute the secant of x in radians. Defined as 1/cos(x)",
    examples: ["sec(2)", "1 / cos(2)"],
    seealso: ["cot", "csc", "cos"],
  },
  N4 = {
    name: "sech",
    category: "Trigonometry",
    syntax: ["sech(x)"],
    description:
      "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
    examples: ["sech(2)", "1 / cosh(2)"],
    seealso: ["coth", "csch", "cosh"],
  },
  M4 = {
    name: "sin",
    category: "Trigonometry",
    syntax: ["sin(x)"],
    description: "Compute the sine of x in radians.",
    examples: [
      "sin(2)",
      "sin(pi / 4) ^ 2",
      "sin(90 deg)",
      "sin(30 deg)",
      "sin(0.2)^2 + cos(0.2)^2",
    ],
    seealso: ["asin", "cos", "tan"],
  },
  A4 = {
    name: "sinh",
    category: "Trigonometry",
    syntax: ["sinh(x)"],
    description: "Compute the hyperbolic sine of x in radians.",
    examples: ["sinh(0.5)"],
    seealso: ["cosh", "tanh"],
  },
  S4 = {
    name: "tan",
    category: "Trigonometry",
    syntax: ["tan(x)"],
    description: "Compute the tangent of x in radians.",
    examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
    seealso: ["atan", "sin", "cos"],
  },
  E4 = {
    name: "tanh",
    category: "Trigonometry",
    syntax: ["tanh(x)"],
    description: "Compute the hyperbolic tangent of x in radians.",
    examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
    seealso: ["sinh", "cosh"],
  },
  C4 = {
    name: "to",
    category: "Units",
    syntax: ["x to unit", "to(x, unit)"],
    description: "Change the unit of a value.",
    examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
    seealso: [],
  },
  $4 = {
    name: "bin",
    category: "Utils",
    syntax: ["bin(value)"],
    description: "Format a number as binary",
    examples: ["bin(2)"],
    seealso: ["oct", "hex"],
  },
  O4 = {
    name: "clone",
    category: "Utils",
    syntax: ["clone(x)"],
    description:
      "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
    examples: [
      "clone(3.5)",
      "clone(2 - 4i)",
      "clone(45 deg)",
      "clone([1, 2; 3, 4])",
      'clone("hello world")',
    ],
    seealso: [],
  },
  T4 = {
    name: "format",
    category: "Utils",
    syntax: ["format(value)", "format(value, precision)"],
    description: "Format a value of any type as string.",
    examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
    seealso: ["print"],
  },
  D4 = {
    name: "hasNumericValue",
    category: "Utils",
    syntax: ["hasNumericValue(x)"],
    description:
      "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
    examples: [
      "hasNumericValue(2)",
      'hasNumericValue("2")',
      'isNumeric("2")',
      "hasNumericValue(0)",
      "hasNumericValue(bignumber(500))",
      "hasNumericValue(fraction(0.125))",
      "hasNumericValue(2 + 3i)",
      'hasNumericValue([2.3, "foo", false])',
    ],
    seealso: [
      "isInteger",
      "isZero",
      "isNegative",
      "isPositive",
      "isNaN",
      "isNumeric",
    ],
  },
  B4 = {
    name: "hex",
    category: "Utils",
    syntax: ["hex(value)"],
    description: "Format a number as hexadecimal",
    examples: ["hex(240)"],
    seealso: ["bin", "oct"],
  },
  _4 = {
    name: "isInteger",
    category: "Utils",
    syntax: ["isInteger(x)"],
    description: "Test whether a value is an integer number.",
    examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"],
  },
  I4 = {
    name: "isNaN",
    category: "Utils",
    syntax: ["isNaN(x)"],
    description: "Test whether a value is NaN (not a number)",
    examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"],
  },
  R4 = {
    name: "isNegative",
    category: "Utils",
    syntax: ["isNegative(x)"],
    description: "Test whether a value is negative: smaller than zero.",
    examples: [
      "isNegative(2)",
      "isNegative(0)",
      "isNegative(-4)",
      "isNegative([3, 0.5, -2])",
    ],
    seealso: ["isInteger", "isNumeric", "isPositive", "isZero"],
  },
  F4 = {
    name: "isNumeric",
    category: "Utils",
    syntax: ["isNumeric(x)"],
    description:
      "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
    examples: [
      "isNumeric(2)",
      'isNumeric("2")',
      'hasNumericValue("2")',
      "isNumeric(0)",
      "isNumeric(bignumber(500))",
      "isNumeric(fraction(0.125))",
      "isNumeric(2 + 3i)",
      'isNumeric([2.3, "foo", false])',
    ],
    seealso: [
      "isInteger",
      "isZero",
      "isNegative",
      "isPositive",
      "isNaN",
      "hasNumericValue",
    ],
  },
  P4 = {
    name: "isPositive",
    category: "Utils",
    syntax: ["isPositive(x)"],
    description: "Test whether a value is positive: larger than zero.",
    examples: [
      "isPositive(2)",
      "isPositive(0)",
      "isPositive(-4)",
      "isPositive([3, 0.5, -2])",
    ],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"],
  },
  q4 = {
    name: "isPrime",
    category: "Utils",
    syntax: ["isPrime(x)"],
    description:
      "Test whether a value is prime: has no divisors other than itself and one.",
    examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"],
  },
  z4 = {
    name: "isZero",
    category: "Utils",
    syntax: ["isZero(x)"],
    description: "Test whether a value is zero.",
    examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"],
  },
  U4 = {
    name: "numeric",
    category: "Utils",
    syntax: ["numeric(x)"],
    description:
      "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
    examples: [
      'numeric("4")',
      'numeric("4", "number")',
      'numeric("4", "BigNumber")',
      'numeric("4", "Fraction)',
      'numeric(4, "Fraction")',
      'numeric(fraction(2, 5), "number)',
    ],
    seealso: ["number", "fraction", "bignumber", "string", "format"],
  },
  L4 = {
    name: "oct",
    category: "Utils",
    syntax: ["oct(value)"],
    description: "Format a number as octal",
    examples: ["oct(56)"],
    seealso: ["bin", "hex"],
  },
  k4 = {
    name: "print",
    category: "Utils",
    syntax: ["print(template, values)", "print(template, values, precision)"],
    description: "Interpolate values into a string template.",
    examples: [
      'print("Lucy is $age years old", {age: 5})',
      'print("The value of pi is $pi", {pi: pi}, 3)',
      'print("Hello, $user.name!", {user: {name: "John"}})',
      'print("Values: $0, $1, $2", [6, 9, 4])',
    ],
    seealso: ["format"],
  },
  V4 = {
    name: "typeOf",
    category: "Utils",
    syntax: ["typeOf(x)"],
    description: "Get the type of a variable.",
    examples: [
      "typeOf(3.5)",
      "typeOf(2 - 4i)",
      "typeOf(45 deg)",
      'typeOf("hello world")',
    ],
    seealso: ["getMatrixDataType"],
  },
  G4 = {
    bignumber: G3,
    boolean: H3,
    complex: Z3,
    createUnit: J3,
    fraction: W3,
    index: X3,
    matrix: Y3,
    number: Q3,
    sparse: j3,
    splitUnit: K3,
    string: e$,
    unit: r$,
    e: im,
    E: im,
    false: O3,
    i: T3,
    Infinity: D3,
    LN2: _3,
    LN10: B3,
    LOG2E: R3,
    LOG10E: I3,
    NaN: F3,
    null: P3,
    pi: om,
    PI: om,
    phi: q3,
    SQRT1_2: z3,
    SQRT2: U3,
    tau: L3,
    true: k3,
    version: V3,
    speedOfLight: {
      description: "Speed of light in vacuum",
      examples: ["speedOfLight"],
    },
    gravitationConstant: {
      description: "Newtonian constant of gravitation",
      examples: ["gravitationConstant"],
    },
    planckConstant: {
      description: "Planck constant",
      examples: ["planckConstant"],
    },
    reducedPlanckConstant: {
      description: "Reduced Planck constant",
      examples: ["reducedPlanckConstant"],
    },
    magneticConstant: {
      description: "Magnetic constant (vacuum permeability)",
      examples: ["magneticConstant"],
    },
    electricConstant: {
      description: "Electric constant (vacuum permeability)",
      examples: ["electricConstant"],
    },
    vacuumImpedance: {
      description: "Characteristic impedance of vacuum",
      examples: ["vacuumImpedance"],
    },
    coulomb: { description: "Coulomb's constant", examples: ["coulomb"] },
    elementaryCharge: {
      description: "Elementary charge",
      examples: ["elementaryCharge"],
    },
    bohrMagneton: { description: "Borh magneton", examples: ["bohrMagneton"] },
    conductanceQuantum: {
      description: "Conductance quantum",
      examples: ["conductanceQuantum"],
    },
    inverseConductanceQuantum: {
      description: "Inverse conductance quantum",
      examples: ["inverseConductanceQuantum"],
    },
    magneticFluxQuantum: {
      description: "Magnetic flux quantum",
      examples: ["magneticFluxQuantum"],
    },
    nuclearMagneton: {
      description: "Nuclear magneton",
      examples: ["nuclearMagneton"],
    },
    klitzing: { description: "Von Klitzing constant", examples: ["klitzing"] },
    bohrRadius: { description: "Borh radius", examples: ["bohrRadius"] },
    classicalElectronRadius: {
      description: "Classical electron radius",
      examples: ["classicalElectronRadius"],
    },
    electronMass: { description: "Electron mass", examples: ["electronMass"] },
    fermiCoupling: {
      description: "Fermi coupling constant",
      examples: ["fermiCoupling"],
    },
    fineStructure: {
      description: "Fine-structure constant",
      examples: ["fineStructure"],
    },
    hartreeEnergy: {
      description: "Hartree energy",
      examples: ["hartreeEnergy"],
    },
    protonMass: { description: "Proton mass", examples: ["protonMass"] },
    deuteronMass: { description: "Deuteron Mass", examples: ["deuteronMass"] },
    neutronMass: { description: "Neutron mass", examples: ["neutronMass"] },
    quantumOfCirculation: {
      description: "Quantum of circulation",
      examples: ["quantumOfCirculation"],
    },
    rydberg: { description: "Rydberg constant", examples: ["rydberg"] },
    thomsonCrossSection: {
      description: "Thomson cross section",
      examples: ["thomsonCrossSection"],
    },
    weakMixingAngle: {
      description: "Weak mixing angle",
      examples: ["weakMixingAngle"],
    },
    efimovFactor: { description: "Efimov factor", examples: ["efimovFactor"] },
    atomicMass: {
      description: "Atomic mass constant",
      examples: ["atomicMass"],
    },
    avogadro: { description: "Avogadro's number", examples: ["avogadro"] },
    boltzmann: { description: "Boltzmann constant", examples: ["boltzmann"] },
    faraday: { description: "Faraday constant", examples: ["faraday"] },
    firstRadiation: {
      description: "First radiation constant",
      examples: ["firstRadiation"],
    },
    loschmidt: {
      description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
      examples: ["loschmidt"],
    },
    gasConstant: { description: "Gas constant", examples: ["gasConstant"] },
    molarPlanckConstant: {
      description: "Molar Planck constant",
      examples: ["molarPlanckConstant"],
    },
    molarVolume: {
      description:
        "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
      examples: ["molarVolume"],
    },
    sackurTetrode: {
      description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
      examples: ["sackurTetrode"],
    },
    secondRadiation: {
      description: "Second radiation constant",
      examples: ["secondRadiation"],
    },
    stefanBoltzmann: {
      description: "Stefan-Boltzmann constant",
      examples: ["stefanBoltzmann"],
    },
    wienDisplacement: {
      description: "Wien displacement law constant",
      examples: ["wienDisplacement"],
    },
    molarMass: { description: "Molar mass constant", examples: ["molarMass"] },
    molarMassC12: {
      description: "Molar mass constant of carbon-12",
      examples: ["molarMassC12"],
    },
    gravity: {
      description:
        "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
      examples: ["gravity"],
    },
    planckLength: { description: "Planck length", examples: ["planckLength"] },
    planckMass: { description: "Planck mass", examples: ["planckMass"] },
    planckTime: { description: "Planck time", examples: ["planckTime"] },
    planckCharge: { description: "Planck charge", examples: ["planckCharge"] },
    planckTemperature: {
      description: "Planck temperature",
      examples: ["planckTemperature"],
    },
    derivative: i$,
    lsolve: s$,
    lsolveAll: u$,
    lup: l$,
    lusolve: c$,
    leafCount: o$,
    resolve: p$,
    simplify: v$,
    simplifyCore: h$,
    symbolicEqual: g$,
    rationalize: m$,
    slu: d$,
    usolve: y$,
    usolveAll: b$,
    qr: f$,
    abs: x$,
    add: w$,
    cbrt: N$,
    ceil: M$,
    cube: A$,
    divide: S$,
    dotDivide: E$,
    dotMultiply: C$,
    dotPow: $$,
    exp: O$,
    expm: T$,
    expm1: D$,
    fix: B$,
    floor: _$,
    gcd: I$,
    hypot: R$,
    lcm: P$,
    log: q$,
    log2: L$,
    log1p: U$,
    log10: z$,
    mod: k$,
    multiply: V$,
    norm: G$,
    nthRoot: H$,
    nthRoots: Z$,
    pow: J$,
    round: W$,
    sign: X$,
    sqrt: Y$,
    sqrtm: Q$,
    square: j$,
    subtract: K$,
    unaryMinus: eO,
    unaryPlus: rO,
    xgcd: tO,
    invmod: F$,
    bitAnd: nO,
    bitNot: aO,
    bitOr: iO,
    bitXor: oO,
    leftShift: sO,
    rightArithShift: uO,
    rightLogShift: lO,
    bellNumbers: cO,
    catalan: fO,
    composition: mO,
    stirlingS2: pO,
    config: t$,
    import: n$,
    typed: a$,
    arg: vO,
    conj: hO,
    re: gO,
    im: dO,
    evaluate: yO,
    help: bO,
    distance: xO,
    intersect: wO,
    and: NO,
    not: MO,
    or: AO,
    xor: SO,
    concat: CO,
    count: $O,
    cross: OO,
    column: EO,
    ctranspose: TO,
    det: DO,
    diag: BO,
    diff: _O,
    dot: IO,
    getMatrixDataType: zO,
    identity: UO,
    filter: FO,
    flatten: PO,
    forEach: qO,
    inv: LO,
    pinv: kO,
    eigs: RO,
    kron: VO,
    matrixFromFunction: ZO,
    matrixFromRows: JO,
    matrixFromColumns: HO,
    map: GO,
    ones: WO,
    partitionSelect: XO,
    range: YO,
    resize: jO,
    reshape: QO,
    rotate: KO,
    rotationMatrix: eT,
    row: rT,
    size: tT,
    sort: nT,
    squeeze: aT,
    subset: iT,
    trace: oT,
    transpose: sT,
    zeros: uT,
    fft: lT,
    ifft: cT,
    combinations: fT,
    combinationsWithRep: mT,
    factorial: pT,
    gamma: vT,
    kldivergence: dT,
    lgamma: hT,
    multinomial: gT,
    permutations: yT,
    pickRandom: bT,
    random: xT,
    randomInt: wT,
    compare: NT,
    compareNatural: MT,
    compareText: AT,
    deepEqual: ST,
    equal: ET,
    equalText: CT,
    larger: $T,
    largerEq: OT,
    smaller: TT,
    smallerEq: DT,
    unequal: BT,
    setCartesian: _T,
    setDifference: IT,
    setDistinct: RT,
    setIntersect: FT,
    setIsSubset: PT,
    setMultiplicity: qT,
    setPowerset: zT,
    setSize: UT,
    setSymDifference: LT,
    setUnion: kT,
    erf: VT,
    cumsum: KT,
    mad: GT,
    max: HT,
    mean: ZT,
    median: JT,
    min: WT,
    mode: XT,
    prod: YT,
    quantileSeq: QT,
    std: jT,
    sum: e4,
    variance: r4,
    acos: t4,
    acosh: n4,
    acot: a4,
    acoth: i4,
    acsc: o4,
    acsch: s4,
    asec: u4,
    asech: l4,
    asin: c4,
    asinh: f4,
    atan: m4,
    atanh: v4,
    atan2: p4,
    cos: h4,
    cosh: d4,
    cot: g4,
    coth: y4,
    csc: b4,
    csch: x4,
    sec: w4,
    sech: N4,
    sin: M4,
    sinh: A4,
    tan: S4,
    tanh: E4,
    to: C4,
    clone: O4,
    format: T4,
    bin: $4,
    oct: L4,
    hex: B4,
    isNaN: I4,
    isInteger: _4,
    isNegative: R4,
    isNumeric: F4,
    hasNumericValue: D4,
    isPositive: P4,
    isPrime: q4,
    isZero: z4,
    print: k4,
    typeOf: V4,
    numeric: U4,
  },
  sm = "help",
  H4 = ["typed", "mathWithTransform", "Help"],
  Z4 = P(sm, H4, (e) => {
    var { typed: r, mathWithTransform: t, Help: a } = e;
    return r(sm, {
      any: function (i) {
        var c,
          m = i;
        if (typeof i != "string") {
          for (c in t)
            if (De(t, c) && i === t[c]) {
              m = c;
              break;
            }
        }
        var f = ct(G4, m);
        if (!f) {
          var u = typeof m == "function" ? m.name : m;
          throw new Error('No documentation found on "' + u + '"');
        }
        return new a(f);
      },
    });
  }),
  um = "chain",
  J4 = ["typed", "Chain"],
  W4 = P(um, J4, (e) => {
    var { typed: r, Chain: t } = e;
    return r(um, {
      "": function () {
        return new t();
      },
      any: function (n) {
        return new t(n);
      },
    });
  }),
  lm = "det",
  X4 = [
    "typed",
    "matrix",
    "subtract",
    "multiply",
    "divideScalar",
    "isZero",
    "unaryMinus",
  ],
  Y4 = P(lm, X4, (e) => {
    var {
      typed: r,
      matrix: t,
      subtract: a,
      multiply: n,
      divideScalar: i,
      isZero: c,
      unaryMinus: m,
    } = e;
    return r(lm, {
      any: function (s) {
        return Fe(s);
      },
      "Array | Matrix": function (s) {
        var o;
        switch (
          (ze(s)
            ? (o = s.size())
            : Array.isArray(s)
            ? ((s = t(s)), (o = s.size()))
            : (o = []),
          o.length)
        ) {
          case 0:
            return Fe(s);
          case 1:
            if (o[0] === 1) return Fe(s.valueOf()[0]);
            throw new RangeError("Matrix must be square (size: " + Ze(o) + ")");
          case 2: {
            var l = o[0],
              p = o[1];
            if (l === p) return f(s.clone().valueOf(), l);
            throw new RangeError("Matrix must be square (size: " + Ze(o) + ")");
          }
          default:
            throw new RangeError(
              "Matrix must be two dimensional (size: " + Ze(o) + ")"
            );
        }
      },
    });
    function f(u, s, o) {
      if (s === 1) return Fe(u[0][0]);
      if (s === 2) return a(n(u[0][0], u[1][1]), n(u[1][0], u[0][1]));
      for (
        var l = !1, p = new Array(s).fill(0).map((S, A) => A), v = 0;
        v < s;
        v++
      ) {
        var h = p[v];
        if (c(u[h][v])) {
          var x = void 0;
          for (x = v + 1; x < s; x++)
            if (!c(u[p[x]][v])) {
              (h = p[x]), (p[x] = p[v]), (p[v] = h), (l = !l);
              break;
            }
          if (x === s) return u[h][v];
        }
        for (
          var b = u[h][v], N = v === 0 ? 1 : u[p[v - 1]][v - 1], d = v + 1;
          d < s;
          d++
        )
          for (var y = p[d], w = v + 1; w < s; w++)
            u[y][w] = i(a(n(u[y][w], b), n(u[y][v], u[h][w])), N);
      }
      var g = u[p[s - 1]][s - 1];
      return l ? m(g) : g;
    }
  }),
  cm = "inv",
  Q4 = [
    "typed",
    "matrix",
    "divideScalar",
    "addScalar",
    "multiply",
    "unaryMinus",
    "det",
    "identity",
    "abs",
  ],
  j4 = P(cm, Q4, (e) => {
    var {
      typed: r,
      matrix: t,
      divideScalar: a,
      addScalar: n,
      multiply: i,
      unaryMinus: c,
      det: m,
      identity: f,
      abs: u,
    } = e;
    return r(cm, {
      "Array | Matrix": function (l) {
        var p = ze(l) ? l.size() : Xe(l);
        switch (p.length) {
          case 1:
            if (p[0] === 1)
              return ze(l) ? t([a(1, l.valueOf()[0])]) : [a(1, l[0])];
            throw new RangeError("Matrix must be square (size: " + Ze(p) + ")");
          case 2: {
            var v = p[0],
              h = p[1];
            if (v === h)
              return ze(l) ? t(s(l.valueOf(), v, h), l.storage()) : s(l, v, h);
            throw new RangeError("Matrix must be square (size: " + Ze(p) + ")");
          }
          default:
            throw new RangeError(
              "Matrix must be two dimensional (size: " + Ze(p) + ")"
            );
        }
      },
      any: function (l) {
        return a(1, l);
      },
    });
    function s(o, l, p) {
      var v, h, x, b, N;
      if (l === 1) {
        if (((b = o[0][0]), b === 0))
          throw Error("Cannot calculate inverse, determinant is zero");
        return [[a(1, b)]];
      } else if (l === 2) {
        var d = m(o);
        if (d === 0)
          throw Error("Cannot calculate inverse, determinant is zero");
        return [
          [a(o[1][1], d), a(c(o[0][1]), d)],
          [a(c(o[1][0]), d), a(o[0][0], d)],
        ];
      } else {
        var y = o.concat();
        for (v = 0; v < l; v++) y[v] = y[v].concat();
        for (var w = f(l).valueOf(), g = 0; g < p; g++) {
          var S = u(y[g][g]),
            A = g;
          for (v = g + 1; v < l; )
            u(y[v][g]) > S && ((S = u(y[v][g])), (A = v)), v++;
          if (S === 0)
            throw Error("Cannot calculate inverse, determinant is zero");
          (v = A),
            v !== g &&
              ((N = y[g]),
              (y[g] = y[v]),
              (y[v] = N),
              (N = w[g]),
              (w[g] = w[v]),
              (w[v] = N));
          var E = y[g],
            M = w[g];
          for (v = 0; v < l; v++) {
            var B = y[v],
              C = w[v];
            if (v !== g) {
              if (B[g] !== 0) {
                for (x = a(c(B[g]), E[g]), h = g; h < p; h++)
                  B[h] = n(B[h], i(x, E[h]));
                for (h = 0; h < p; h++) C[h] = n(C[h], i(x, M[h]));
              }
            } else {
              for (x = E[g], h = g; h < p; h++) B[h] = a(B[h], x);
              for (h = 0; h < p; h++) C[h] = a(C[h], x);
            }
          }
        }
        return w;
      }
    }
  }),
  fm = "pinv",
  K4 = [
    "typed",
    "matrix",
    "inv",
    "deepEqual",
    "equal",
    "dotDivide",
    "dot",
    "ctranspose",
    "divideScalar",
    "multiply",
    "add",
    "Complex",
  ],
  eD = P(fm, K4, (e) => {
    var {
      typed: r,
      matrix: t,
      inv: a,
      deepEqual: n,
      equal: i,
      dotDivide: c,
      dot: m,
      ctranspose: f,
      divideScalar: u,
      multiply: s,
      add: o,
      Complex: l,
    } = e;
    return r(fm, {
      "Array | Matrix": function (d) {
        var y = ze(d) ? d.size() : Xe(d);
        switch (y.length) {
          case 1:
            return b(d) ? f(d) : y[0] === 1 ? a(d) : c(f(d), m(d, d));
          case 2: {
            if (b(d)) return f(d);
            var w = y[0],
              g = y[1];
            if (w === g)
              try {
                return a(d);
              } catch (S) {
                if (
                  !(
                    S instanceof Error &&
                    S.message.match(
                      /Cannot calculate inverse, determinant is zero/
                    )
                  )
                )
                  throw S;
              }
            return ze(d) ? t(p(d.valueOf(), w, g), d.storage()) : p(d, w, g);
          }
          default:
            throw new RangeError(
              "Matrix must be two dimensional (size: " + Ze(y) + ")"
            );
        }
      },
      any: function (d) {
        return i(d, 0) ? Fe(d) : u(1, d);
      },
    });
    function p(N, d, y) {
      var { C: w, F: g } = h(N, d, y),
        S = s(a(s(f(w), w)), f(w)),
        A = s(f(g), a(s(g, f(g))));
      return s(A, S);
    }
    function v(N, d, y) {
      for (var w = Fe(N), g = 0, S = 0; S < d; S++) {
        if (y <= g) return w;
        for (var A = S; x(w[A][g]); )
          if ((A++, d === A && ((A = S), g++, y === g))) return w;
        [w[A], w[S]] = [w[S], w[A]];
        for (var E = w[S][g], M = 0; M < y; M++) w[S][M] = c(w[S][M], E);
        for (var B = 0; B < d; B++)
          if (B !== S) {
            E = w[B][g];
            for (var C = 0; C < y; C++)
              w[B][C] = o(w[B][C], s(-1, s(E, w[S][C])));
          }
        g++;
      }
      return w;
    }
    function h(N, d, y) {
      var w = v(N, d, y),
        g = N.map((A, E) => A.filter((M, B) => B < d && !x(m(w[B], w[B])))),
        S = w.filter((A, E) => !x(m(w[E], w[E])));
      return { C: g, F: S };
    }
    function x(N) {
      return i(o(N, l(1, 1)), o(0, l(1, 1)));
    }
    function b(N) {
      return n(o(N, l(1, 1)), o(s(N, 0), l(1, 1)));
    }
  });
function rD(e) {
  var {
    addScalar: r,
    subtract: t,
    flatten: a,
    multiply: n,
    multiplyScalar: i,
    divideScalar: c,
    sqrt: m,
    abs: f,
    bignumber: u,
    diag: s,
    inv: o,
    qr: l,
    usolve: p,
    usolveAll: v,
    equal: h,
    complex: x,
    larger: b,
    smaller: N,
    matrixFromColumns: d,
    dot: y,
  } = e;
  function w(H, Q, te, J, re) {
    re === void 0 && (re = !0);
    var oe = g(H, Q, te, J, re);
    S(H, Q, te, J, re, oe);
    var { values: ae, C: ce } = A(H, Q, te, J, re),
      se;
    return (
      re && ((se = E(H, Q, ce, oe, ae, te, J)), (se = d(...se))),
      { values: ae, vectors: se }
    );
  }
  function g(H, Q, te, J, re) {
    var oe = J === "BigNumber",
      ae = J === "Complex",
      ce = oe ? u(0) : 0,
      se = oe ? u(1) : ae ? x(1) : 1,
      pe = oe ? u(1) : 1,
      ne = oe ? u(10) : 2,
      Ae = i(ne, ne),
      Ce;
    re && (Ce = Array(Q).fill(se));
    for (var ge = !1; !ge; ) {
      ge = !0;
      for (var Se = 0; Se < Q; Se++) {
        for (var q = ce, Y = ce, V = 0; V < Q; V++)
          if (Se !== V) {
            var L = f(H[Se][V]);
            (q = r(q, L)), (Y = r(Y, L));
          }
        if (!h(q, 0) && !h(Y, 0)) {
          for (var j = pe, F = q, U = c(Y, ne), ee = i(Y, ne); N(F, U); )
            (F = i(F, Ae)), (j = i(j, ne));
          for (; b(F, ee); ) (F = c(F, Ae)), (j = c(j, ne));
          var k = N(c(r(F, Y), j), i(r(q, Y), 0.95));
          if (k) {
            ge = !1;
            for (var me = c(1, j), he = 0; he < Q; he++)
              Se !== he &&
                ((H[Se][he] = i(H[Se][he], j)), (H[he][Se] = i(H[he][Se], me)));
            re && (Ce[Se] = i(Ce[Se], j));
          }
        }
      }
    }
    return s(Ce);
  }
  function S(H, Q, te, J, re, oe) {
    var ae = J === "BigNumber",
      ce = J === "Complex",
      se = ae ? u(0) : ce ? x(0) : 0;
    ae && (te = u(te));
    for (var pe = 0; pe < Q - 2; pe++) {
      for (var ne = 0, Ae = se, Ce = pe + 1; Ce < Q; Ce++) {
        var ge = H[Ce][pe];
        N(f(Ae), f(ge)) && ((Ae = ge), (ne = Ce));
      }
      if (!N(f(Ae), te)) {
        if (ne !== pe + 1) {
          var Se = H[ne];
          (H[ne] = H[pe + 1]), (H[pe + 1] = Se);
          for (var q = 0; q < Q; q++) {
            var Y = H[q][ne];
            (H[q][ne] = H[q][pe + 1]), (H[q][pe + 1] = Y);
          }
          if (re) {
            var V = oe[ne];
            (oe[ne] = oe[pe + 1]), (oe[pe + 1] = V);
          }
        }
        for (var L = pe + 2; L < Q; L++) {
          var j = c(H[L][pe], Ae);
          if (j !== 0) {
            for (var F = 0; F < Q; F++)
              H[L][F] = t(H[L][F], i(j, H[pe + 1][F]));
            for (var U = 0; U < Q; U++)
              H[U][pe + 1] = r(H[U][pe + 1], i(j, H[U][L]));
            if (re)
              for (var ee = 0; ee < Q; ee++)
                oe[L][ee] = t(oe[L][ee], i(j, oe[pe + 1][ee]));
          }
        }
      }
    }
    return oe;
  }
  function A(H, Q, te, J, re) {
    var oe = J === "BigNumber",
      ae = J === "Complex",
      ce = oe ? u(1) : ae ? x(1) : 1;
    oe && (te = u(te));
    for (
      var se = Fe(H),
        pe = [],
        ne = Q,
        Ae = [],
        Ce = re ? s(Array(Q).fill(ce)) : void 0,
        ge = re ? s(Array(ne).fill(ce)) : void 0,
        Se = 0;
      Se <= 100;

    ) {
      Se += 1;
      for (var q = 0, Y = 0; Y < ne; Y++) se[Y][Y] = t(se[Y][Y], q);
      var { Q: V, R: L } = l(se);
      se = n(L, V);
      for (var j = 0; j < ne; j++) se[j][j] = r(se[j][j], q);
      if ((re && (ge = n(ge, V)), ne === 1 || N(f(se[ne - 1][ne - 2]), te))) {
        (Se = 0),
          pe.push(se[ne - 1][ne - 1]),
          re &&
            (Ae.unshift([[1]]),
            C(ge, Q),
            (Ce = n(Ce, ge)),
            ne > 1 && (ge = s(Array(ne - 1).fill(ce)))),
          (ne -= 1),
          se.pop();
        for (var F = 0; F < ne; F++) se[F].pop();
      } else if (ne === 2 || N(f(se[ne - 2][ne - 3]), te)) {
        Se = 0;
        var U = M(
          se[ne - 2][ne - 2],
          se[ne - 2][ne - 1],
          se[ne - 1][ne - 2],
          se[ne - 1][ne - 1]
        );
        pe.push(...U),
          re &&
            (Ae.unshift(
              B(
                se[ne - 2][ne - 2],
                se[ne - 2][ne - 1],
                se[ne - 1][ne - 2],
                se[ne - 1][ne - 1],
                U[0],
                U[1],
                te,
                J
              )
            ),
            C(ge, Q),
            (Ce = n(Ce, ge)),
            ne > 2 && (ge = s(Array(ne - 2).fill(ce)))),
          (ne -= 2),
          se.pop(),
          se.pop();
        for (var ee = 0; ee < ne; ee++) se[ee].pop(), se[ee].pop();
      }
      if (ne === 0) break;
    }
    if ((pe.sort((he, Me) => +t(f(he), f(Me))), Se > 100)) {
      var k = Error(
        "The eigenvalues failed to converge. Only found these eigenvalues: " +
          pe.join(", ")
      );
      throw ((k.values = pe), (k.vectors = []), k);
    }
    var me = re ? n(Ce, _(Ae, Q)) : void 0;
    return { values: pe, C: me };
  }
  function E(H, Q, te, J, re, oe, ae) {
    var ce = o(te),
      se = n(ce, H, te),
      pe = ae === "BigNumber",
      ne = ae === "Complex",
      Ae = pe ? u(0) : ne ? x(0) : 0,
      Ce = pe ? u(1) : ne ? x(1) : 1,
      ge = [],
      Se = [];
    for (var q of re) {
      var Y = z(ge, q, h);
      Y === -1 ? (ge.push(q), Se.push(1)) : (Se[Y] += 1);
    }
    for (
      var V = [],
        L = ge.length,
        j = Array(Q).fill(Ae),
        F = s(Array(Q).fill(Ce)),
        U = [],
        ee = function (Me) {
          var be = ge[Me],
            xe = t(se, n(be, F)),
            Te = v(xe, j);
          for (Te.shift(); Te.length < Se[Me]; ) {
            var or = I(xe, Q, Te, oe, ae);
            if (or == null) {
              U.push(be);
              break;
            }
            Te.push(or);
          }
          var br = n(o(J), te);
          (Te = Te.map((mr) => n(br, mr))), V.push(...Te.map((mr) => a(mr)));
        },
        k = 0;
      k < L;
      k++
    )
      ee(k);
    if (U.length !== 0) {
      var me = new Error(
        "Failed to find eigenvectors for the following eigenvalues: " +
          U.join(", ")
      );
      throw ((me.values = re), (me.vectors = V), me);
    }
    return V;
  }
  function M(H, Q, te, J) {
    var re = r(H, J),
      oe = t(i(H, J), i(Q, te)),
      ae = i(re, 0.5),
      ce = i(m(t(i(re, re), i(4, oe))), 0.5);
    return [r(ae, ce), t(ae, ce)];
  }
  function B(H, Q, te, J, re, oe, ae, ce) {
    var se = ce === "BigNumber",
      pe = ce === "Complex",
      ne = se ? u(0) : pe ? x(0) : 0,
      Ae = se ? u(1) : pe ? x(1) : 1;
    if (N(f(te), ae))
      return [
        [Ae, ne],
        [ne, Ae],
      ];
    if (b(f(t(re, oe)), ae))
      return [
        [t(re, J), t(oe, J)],
        [te, te],
      ];
    var Ce = t(H, re),
      ge = t(Q, re),
      Se = t(te, re),
      q = t(J, re);
    return N(f(ge), ae)
      ? [
          [Ce, Ae],
          [Se, ne],
        ]
      : [
          [ge, ne],
          [q, Ae],
        ];
  }
  function C(H, Q) {
    for (var te = 0; te < H.length; te++)
      H[te].push(...Array(Q - H[te].length).fill(0));
    for (var J = H.length; J < Q; J++) H.push(Array(Q).fill(0)), (H[J][J] = 1);
    return H;
  }
  function _(H, Q) {
    for (var te = [], J = 0; J < Q; J++) te[J] = Array(Q).fill(0);
    var re = 0;
    for (var oe of H) {
      for (var ae = oe.length, ce = 0; ce < ae; ce++)
        for (var se = 0; se < ae; se++) te[re + ce][re + se] = oe[ce][se];
      re += ae;
    }
    return te;
  }
  function z(H, Q, te) {
    for (var J = 0; J < H.length; J++) if (te(H[J], Q)) return J;
    return -1;
  }
  function I(H, Q, te, J, re) {
    for (
      var oe = re === "BigNumber" ? u(1e3) : 1e3, ae, ce = 0;
      (ae = T(Q, te, re)), (ae = p(H, ae)), !b(Z(ae), oe);

    )
      if (++ce >= 5) return null;
    for (ce = 0; ; ) {
      var se = p(H, ae);
      if (N(Z(D(ae, [se])), J)) break;
      if (++ce >= 10) return null;
      ae = O(se);
    }
    return ae;
  }
  function T(H, Q, te) {
    var J = te === "BigNumber",
      re = te === "Complex",
      oe = Array(H)
        .fill(0)
        .map((ae) => 2 * Math.random() - 1);
    return (
      J && (oe = oe.map((ae) => u(ae))),
      re && (oe = oe.map((ae) => x(ae))),
      (oe = D(oe, Q)),
      O(oe, te)
    );
  }
  function D(H, Q) {
    for (var te of Q) H = t(H, n(c(y(te, H), y(te, te)), te));
    return H;
  }
  function Z(H) {
    return f(m(y(H, H)));
  }
  function O(H, Q) {
    var te = Q === "BigNumber",
      J = Q === "Complex",
      re = te ? u(1) : J ? x(1) : 1;
    return n(c(re, Z(H)), H);
  }
  return w;
}
function tD(e) {
  var {
    config: r,
    addScalar: t,
    subtract: a,
    abs: n,
    atan: i,
    cos: c,
    sin: m,
    multiplyScalar: f,
    inv: u,
    bignumber: s,
    multiply: o,
    add: l,
  } = e;
  function p(M, B) {
    var C =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : r.epsilon,
      _ = arguments.length > 3 ? arguments[3] : void 0;
    if (_ === "number") return v(M, C);
    if (_ === "BigNumber") return h(M, C);
    throw TypeError("Unsupported data type: " + _);
  }
  function v(M, B) {
    for (
      var C = M.length, _ = Math.abs(B / C), z, I = new Array(C), T = 0;
      T < C;
      T++
    )
      (I[T] = E(C, 0)), (I[T][T] = 1);
    for (var D = g(M); Math.abs(D[1]) >= Math.abs(_); ) {
      var Z = D[0][0],
        O = D[0][1];
      (z = x(M[Z][Z], M[O][O], M[Z][O])),
        (M = w(M, z, Z, O)),
        (I = N(I, z, Z, O)),
        (D = g(M));
    }
    for (var H = E(C, 0), Q = 0; Q < C; Q++) H[Q] = M[Q][Q];
    return A(Fe(H), Fe(I));
  }
  function h(M, B) {
    for (var C = M.length, _ = n(B / C), z, I = new Array(C), T = 0; T < C; T++)
      (I[T] = E(C, 0)), (I[T][T] = 1);
    for (var D = S(M); n(D[1]) >= n(_); ) {
      var Z = D[0][0],
        O = D[0][1];
      (z = b(M[Z][Z], M[O][O], M[Z][O])),
        (M = y(M, z, Z, O)),
        (I = d(I, z, Z, O)),
        (D = S(M));
    }
    for (var H = E(C, 0), Q = 0; Q < C; Q++) H[Q] = M[Q][Q];
    return A(Fe(H), Fe(I));
  }
  function x(M, B, C) {
    var _ = B - M;
    return Math.abs(_) <= r.epsilon
      ? Math.PI / 4
      : 0.5 * Math.atan((2 * C) / (B - M));
  }
  function b(M, B, C) {
    var _ = a(B, M);
    return n(_) <= r.epsilon ? s(-1).acos().div(4) : f(0.5, i(o(2, C, u(_))));
  }
  function N(M, B, C, _) {
    for (
      var z = M.length,
        I = Math.cos(B),
        T = Math.sin(B),
        D = E(z, 0),
        Z = E(z, 0),
        O = 0;
      O < z;
      O++
    )
      (D[O] = I * M[O][C] - T * M[O][_]), (Z[O] = T * M[O][C] + I * M[O][_]);
    for (var H = 0; H < z; H++) (M[H][C] = D[H]), (M[H][_] = Z[H]);
    return M;
  }
  function d(M, B, C, _) {
    for (
      var z = M.length,
        I = c(B),
        T = m(B),
        D = E(z, s(0)),
        Z = E(z, s(0)),
        O = 0;
      O < z;
      O++
    )
      (D[O] = a(f(I, M[O][C]), f(T, M[O][_]))),
        (Z[O] = t(f(T, M[O][C]), f(I, M[O][_])));
    for (var H = 0; H < z; H++) (M[H][C] = D[H]), (M[H][_] = Z[H]);
    return M;
  }
  function y(M, B, C, _) {
    for (
      var z = M.length,
        I = s(c(B)),
        T = s(m(B)),
        D = f(I, I),
        Z = f(T, T),
        O = E(z, s(0)),
        H = E(z, s(0)),
        Q = o(s(2), I, T, M[C][_]),
        te = t(a(f(D, M[C][C]), Q), f(Z, M[_][_])),
        J = l(f(Z, M[C][C]), Q, f(D, M[_][_])),
        re = 0;
      re < z;
      re++
    )
      (O[re] = a(f(I, M[C][re]), f(T, M[_][re]))),
        (H[re] = t(f(T, M[C][re]), f(I, M[_][re])));
    (M[C][C] = te), (M[_][_] = J), (M[C][_] = s(0)), (M[_][C] = s(0));
    for (var oe = 0; oe < z; oe++)
      oe !== C &&
        oe !== _ &&
        ((M[C][oe] = O[oe]),
        (M[oe][C] = O[oe]),
        (M[_][oe] = H[oe]),
        (M[oe][_] = H[oe]));
    return M;
  }
  function w(M, B, C, _) {
    for (
      var z = M.length,
        I = Math.cos(B),
        T = Math.sin(B),
        D = I * I,
        Z = T * T,
        O = E(z, 0),
        H = E(z, 0),
        Q = D * M[C][C] - 2 * I * T * M[C][_] + Z * M[_][_],
        te = Z * M[C][C] + 2 * I * T * M[C][_] + D * M[_][_],
        J = 0;
      J < z;
      J++
    )
      (O[J] = I * M[C][J] - T * M[_][J]), (H[J] = T * M[C][J] + I * M[_][J]);
    (M[C][C] = Q), (M[_][_] = te), (M[C][_] = 0), (M[_][C] = 0);
    for (var re = 0; re < z; re++)
      re !== C &&
        re !== _ &&
        ((M[C][re] = O[re]),
        (M[re][C] = O[re]),
        (M[_][re] = H[re]),
        (M[re][_] = H[re]));
    return M;
  }
  function g(M) {
    for (var B = M.length, C = 0, _ = [0, 1], z = 0; z < B; z++)
      for (var I = z + 1; I < B; I++)
        Math.abs(C) < Math.abs(M[z][I]) &&
          ((C = Math.abs(M[z][I])), (_ = [z, I]));
    return [_, C];
  }
  function S(M) {
    for (var B = M.length, C = 0, _ = [0, 1], z = 0; z < B; z++)
      for (var I = z + 1; I < B; I++)
        n(C) < n(M[z][I]) && ((C = n(M[z][I])), (_ = [z, I]));
    return [_, C];
  }
  function A(M, B) {
    for (var C = M.length, _ = Array(C), z = Array(C), I = 0; I < C; I++)
      z[I] = Array(C);
    for (var T = 0; T < C; T++) {
      for (var D = 0, Z = M[0], O = 0; O < M.length; O++)
        n(M[O]) < n(Z) && ((D = O), (Z = M[D]));
      _[T] = M.splice(D, 1)[0];
      for (var H = 0; H < C; H++) (z[H][T] = B[H][D]), B[H].splice(D, 1);
    }
    return { values: _, vectors: z };
  }
  function E(M, B) {
    for (var C = new Array(M), _ = 0; _ < M; _++) C[_] = B;
    return C;
  }
  return p;
}
var nD = "eigs",
  aD = [
    "config",
    "typed",
    "matrix",
    "addScalar",
    "equal",
    "subtract",
    "abs",
    "atan",
    "cos",
    "sin",
    "multiplyScalar",
    "divideScalar",
    "inv",
    "bignumber",
    "multiply",
    "add",
    "larger",
    "column",
    "flatten",
    "number",
    "complex",
    "sqrt",
    "diag",
    "qr",
    "usolve",
    "usolveAll",
    "im",
    "re",
    "smaller",
    "matrixFromColumns",
    "dot",
  ],
  iD = P(nD, aD, (e) => {
    var {
        config: r,
        typed: t,
        matrix: a,
        addScalar: n,
        subtract: i,
        equal: c,
        abs: m,
        atan: f,
        cos: u,
        sin: s,
        multiplyScalar: o,
        divideScalar: l,
        inv: p,
        bignumber: v,
        multiply: h,
        add: x,
        larger: b,
        column: N,
        flatten: d,
        number: y,
        complex: w,
        sqrt: g,
        diag: S,
        qr: A,
        usolve: E,
        usolveAll: M,
        im: B,
        re: C,
        smaller: _,
        matrixFromColumns: z,
        dot: I,
      } = e,
      T = tD({
        config: r,
        addScalar: n,
        subtract: i,
        column: N,
        flatten: d,
        equal: c,
        abs: m,
        atan: f,
        cos: u,
        sin: s,
        multiplyScalar: o,
        inv: p,
        bignumber: v,
        complex: w,
        multiply: h,
        add: x,
      }),
      D = rD({
        config: r,
        addScalar: n,
        subtract: i,
        multiply: h,
        multiplyScalar: o,
        flatten: d,
        divideScalar: l,
        sqrt: g,
        abs: m,
        bignumber: v,
        diag: S,
        qr: A,
        inv: p,
        usolve: E,
        usolveAll: M,
        equal: c,
        complex: w,
        larger: b,
        smaller: _,
        matrixFromColumns: z,
        dot: I,
      });
    return t("eigs", {
      Array: function (re) {
        var oe = a(re);
        return Z(oe);
      },
      "Array, number|BigNumber": function (re, oe) {
        var ae = a(re);
        return Z(ae, oe);
      },
      Matrix: function (re) {
        var { values: oe, vectors: ae } = Z(re);
        return { values: a(oe), vectors: a(ae) };
      },
      "Matrix, number|BigNumber": function (re, oe) {
        var { values: ae, vectors: ce } = Z(re, oe);
        return { values: a(ae), vectors: a(ce) };
      },
    });
    function Z(J, re) {
      re === void 0 && (re = r.epsilon);
      var oe = J.size();
      if (oe.length !== 2 || oe[0] !== oe[1])
        throw new RangeError("Matrix must be square (size: " + Ze(oe) + ")");
      var ae = J.toArray(),
        ce = oe[0];
      if (H(ae, ce, re) && (Q(ae, ce), O(ae, ce, re))) {
        var se = te(J, ae, ce);
        return T(ae, ce, re, se);
      }
      var pe = te(J, ae, ce);
      return D(ae, ce, re, pe);
    }
    function O(J, re, oe) {
      for (var ae = 0; ae < re; ae++)
        for (var ce = ae; ce < re; ce++)
          if (b(v(m(i(J[ae][ce], J[ce][ae]))), oe)) return !1;
      return !0;
    }
    function H(J, re, oe) {
      for (var ae = 0; ae < re; ae++)
        for (var ce = 0; ce < re; ce++)
          if (b(v(m(B(J[ae][ce]))), oe)) return !1;
      return !0;
    }
    function Q(J, re) {
      for (var oe = 0; oe < re; oe++)
        for (var ae = 0; ae < re; ae++) J[oe][ae] = C(J[oe][ae]);
    }
    function te(J, re, oe) {
      var ae = J.datatype();
      if (ae === "number" || ae === "BigNumber" || ae === "Complex") return ae;
      for (var ce = !1, se = !1, pe = !1, ne = 0; ne < oe; ne++)
        for (var Ae = 0; Ae < oe; Ae++) {
          var Ce = re[ne][Ae];
          if (je(Ce) || ha(Ce)) ce = !0;
          else if (Qe(Ce)) se = !0;
          else if (Wt(Ce)) pe = !0;
          else throw TypeError("Unsupported type in Matrix: " + vr(Ce));
        }
      if (
        (se &&
          pe &&
          console.warn(
            "Complex BigNumbers not supported, this operation will lose precission."
          ),
        pe)
      ) {
        for (var ge = 0; ge < oe; ge++)
          for (var Se = 0; Se < oe; Se++) re[ge][Se] = w(re[ge][Se]);
        return "Complex";
      }
      if (se) {
        for (var q = 0; q < oe; q++)
          for (var Y = 0; Y < oe; Y++) re[q][Y] = v(re[q][Y]);
        return "BigNumber";
      }
      if (ce) {
        for (var V = 0; V < oe; V++)
          for (var L = 0; L < oe; L++) re[V][L] = y(re[V][L]);
        return "number";
      } else throw TypeError("Matrix contains unsupported types only.");
    }
  }),
  mm = "expm",
  oD = ["typed", "abs", "add", "identity", "inv", "multiply"],
  sD = P(mm, oD, (e) => {
    var { typed: r, abs: t, add: a, identity: n, inv: i, multiply: c } = e;
    return r(mm, {
      Matrix: function (o) {
        var l = o.size();
        if (l.length !== 2 || l[0] !== l[1])
          throw new RangeError("Matrix must be square (size: " + Ze(l) + ")");
        for (
          var p = l[0],
            v = 1e-15,
            h = m(o),
            x = f(h, v),
            b = x.q,
            N = x.j,
            d = c(o, Math.pow(2, -N)),
            y = n(p),
            w = n(p),
            g = 1,
            S = d,
            A = -1,
            E = 1;
          E <= b;
          E++
        )
          E > 1 && ((S = c(S, d)), (A = -A)),
            (g = (g * (b - E + 1)) / ((2 * b - E + 1) * E)),
            (y = a(y, c(g, S))),
            (w = a(w, c(g * A, S)));
        for (var M = c(i(w), y), B = 0; B < N; B++) M = c(M, M);
        return An(o) ? o.createSparseMatrix(M) : M;
      },
    });
    function m(s) {
      for (var o = s.size()[0], l = 0, p = 0; p < o; p++) {
        for (var v = 0, h = 0; h < o; h++) v += t(s.get([p, h]));
        l = Math.max(v, l);
      }
      return l;
    }
    function f(s, o) {
      for (var l = 30, p = 0; p < l; p++)
        for (var v = 0; v <= p; v++) {
          var h = p - v;
          if (u(s, v, h) < o) return { q: v, j: h };
        }
      throw new Error(
        "Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)"
      );
    }
    function u(s, o, l) {
      for (var p = 1, v = 2; v <= o; v++) p *= v;
      for (var h = p, x = o + 1; x <= 2 * o; x++) h *= x;
      var b = h * (2 * o + 1);
      return (8 * Math.pow(s / Math.pow(2, l), 2 * o) * p * p) / (h * b);
    }
  }),
  pm = "sqrtm",
  uD = [
    "typed",
    "abs",
    "add",
    "multiply",
    "sqrt",
    "subtract",
    "inv",
    "size",
    "max",
    "identity",
  ],
  lD = P(pm, uD, (e) => {
    var {
        typed: r,
        abs: t,
        add: a,
        multiply: n,
        sqrt: i,
        subtract: c,
        inv: m,
        size: f,
        max: u,
        identity: s,
      } = e,
      o = 1e3,
      l = 1e-6;
    function p(v) {
      var h,
        x = 0,
        b = v,
        N = s(f(v));
      do {
        var d = b;
        if (
          ((b = n(0.5, a(d, m(N)))),
          (N = n(0.5, a(N, m(d)))),
          (h = u(t(c(b, d)))),
          h > l && ++x > o)
        )
          throw new Error(
            "computing square root of matrix: iterative method could not converge"
          );
      } while (h > l);
      return b;
    }
    return r(pm, {
      "Array | Matrix": function (h) {
        var x = ze(h) ? h.size() : Xe(h);
        switch (x.length) {
          case 1:
            if (x[0] === 1) return i(h);
            throw new RangeError("Matrix must be square (size: " + Ze(x) + ")");
          case 2: {
            var b = x[0],
              N = x[1];
            if (b === N) return p(h);
            throw new RangeError("Matrix must be square (size: " + Ze(x) + ")");
          }
          default:
            throw new RangeError(
              "Matrix must be at most two dimensional (size: " + Ze(x) + ")"
            );
        }
      },
    });
  }),
  cD = "divide",
  fD = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"],
  mD = P(cD, fD, (e) => {
    var {
        typed: r,
        matrix: t,
        multiply: a,
        equalScalar: n,
        divideScalar: i,
        inv: c,
      } = e,
      m = Ur({ typed: r, equalScalar: n }),
      f = ar({ typed: r });
    return r(
      "divide",
      Ls(
        {
          "Array | Matrix, Array | Matrix": function (s, o) {
            return a(s, c(o));
          },
          "DenseMatrix, any": function (s, o) {
            return f(s, o, i, !1);
          },
          "SparseMatrix, any": function (s, o) {
            return m(s, o, i, !1);
          },
          "Array, any": function (s, o) {
            return f(t(s), o, i, !1).valueOf();
          },
          "any, Array | Matrix": function (s, o) {
            return a(s, c(o));
          },
        },
        i.signatures
      )
    );
  }),
  vm = "distance",
  pD = [
    "typed",
    "addScalar",
    "subtract",
    "divideScalar",
    "multiplyScalar",
    "unaryMinus",
    "sqrt",
    "abs",
  ],
  vD = P(vm, pD, (e) => {
    var {
      typed: r,
      addScalar: t,
      subtract: a,
      multiplyScalar: n,
      divideScalar: i,
      unaryMinus: c,
      sqrt: m,
      abs: f,
    } = e;
    return r(vm, {
      "Array, Array, Array": function (w, g, S) {
        if (w.length === 2 && g.length === 2 && S.length === 2) {
          if (!s(w))
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for first argument"
            );
          if (!s(g))
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for second argument"
            );
          if (!s(S))
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for third argument"
            );
          var A = i(a(S[1], S[0]), a(g[1], g[0])),
            E = n(n(A, A), g[0]),
            M = c(n(A, g[0])),
            B = w[1];
          return x(w[0], w[1], E, M, B);
        } else throw new TypeError("Invalid Arguments: Try again");
      },
      "Object, Object, Object": function (w, g, S) {
        if (
          Object.keys(w).length === 2 &&
          Object.keys(g).length === 2 &&
          Object.keys(S).length === 2
        ) {
          if (!s(w))
            throw new TypeError(
              "Values of pointX and pointY should be numbers or BigNumbers"
            );
          if (!s(g))
            throw new TypeError(
              "Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers"
            );
          if (!s(S))
            throw new TypeError(
              "Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers"
            );
          if (
            "pointX" in w &&
            "pointY" in w &&
            "lineOnePtX" in g &&
            "lineOnePtY" in g &&
            "lineTwoPtX" in S &&
            "lineTwoPtY" in S
          ) {
            var A = i(
                a(S.lineTwoPtY, S.lineTwoPtX),
                a(g.lineOnePtY, g.lineOnePtX)
              ),
              E = n(n(A, A), g.lineOnePtX),
              M = c(n(A, g.lineOnePtX)),
              B = w.pointX;
            return x(w.pointX, w.pointY, E, M, B);
          } else throw new TypeError("Key names do not match");
        } else throw new TypeError("Invalid Arguments: Try again");
      },
      "Array, Array": function (w, g) {
        if (w.length === 2 && g.length === 3) {
          if (!s(w))
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for first argument"
            );
          if (!o(g))
            throw new TypeError(
              "Array with 3 numbers or BigNumbers expected for second argument"
            );
          return x(w[0], w[1], g[0], g[1], g[2]);
        } else if (w.length === 3 && g.length === 6) {
          if (!o(w))
            throw new TypeError(
              "Array with 3 numbers or BigNumbers expected for first argument"
            );
          if (!p(g))
            throw new TypeError(
              "Array with 6 numbers or BigNumbers expected for second argument"
            );
          return b(w[0], w[1], w[2], g[0], g[1], g[2], g[3], g[4], g[5]);
        } else if (w.length === g.length && w.length > 0) {
          if (!l(w))
            throw new TypeError(
              "All values of an array should be numbers or BigNumbers"
            );
          if (!l(g))
            throw new TypeError(
              "All values of an array should be numbers or BigNumbers"
            );
          return N(w, g);
        } else throw new TypeError("Invalid Arguments: Try again");
      },
      "Object, Object": function (w, g) {
        if (Object.keys(w).length === 2 && Object.keys(g).length === 3) {
          if (!s(w))
            throw new TypeError(
              "Values of pointX and pointY should be numbers or BigNumbers"
            );
          if (!o(g))
            throw new TypeError(
              "Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers"
            );
          if (
            "pointX" in w &&
            "pointY" in w &&
            "xCoeffLine" in g &&
            "yCoeffLine" in g &&
            "constant" in g
          )
            return x(
              w.pointX,
              w.pointY,
              g.xCoeffLine,
              g.yCoeffLine,
              g.constant
            );
          throw new TypeError("Key names do not match");
        } else if (Object.keys(w).length === 3 && Object.keys(g).length === 6) {
          if (!o(w))
            throw new TypeError(
              "Values of pointX, pointY and pointZ should be numbers or BigNumbers"
            );
          if (!p(g))
            throw new TypeError(
              "Values of x0, y0, z0, a, b and c should be numbers or BigNumbers"
            );
          if (
            "pointX" in w &&
            "pointY" in w &&
            "x0" in g &&
            "y0" in g &&
            "z0" in g &&
            "a" in g &&
            "b" in g &&
            "c" in g
          )
            return b(
              w.pointX,
              w.pointY,
              w.pointZ,
              g.x0,
              g.y0,
              g.z0,
              g.a,
              g.b,
              g.c
            );
          throw new TypeError("Key names do not match");
        } else if (Object.keys(w).length === 2 && Object.keys(g).length === 2) {
          if (!s(w))
            throw new TypeError(
              "Values of pointOneX and pointOneY should be numbers or BigNumbers"
            );
          if (!s(g))
            throw new TypeError(
              "Values of pointTwoX and pointTwoY should be numbers or BigNumbers"
            );
          if (
            "pointOneX" in w &&
            "pointOneY" in w &&
            "pointTwoX" in g &&
            "pointTwoY" in g
          )
            return N([w.pointOneX, w.pointOneY], [g.pointTwoX, g.pointTwoY]);
          throw new TypeError("Key names do not match");
        } else if (Object.keys(w).length === 3 && Object.keys(g).length === 3) {
          if (!o(w))
            throw new TypeError(
              "Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers"
            );
          if (!o(g))
            throw new TypeError(
              "Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers"
            );
          if (
            "pointOneX" in w &&
            "pointOneY" in w &&
            "pointOneZ" in w &&
            "pointTwoX" in g &&
            "pointTwoY" in g &&
            "pointTwoZ" in g
          )
            return N(
              [w.pointOneX, w.pointOneY, w.pointOneZ],
              [g.pointTwoX, g.pointTwoY, g.pointTwoZ]
            );
          throw new TypeError("Key names do not match");
        } else throw new TypeError("Invalid Arguments: Try again");
      },
      Array: function (w) {
        if (!h(w))
          throw new TypeError(
            "Incorrect array format entered for pairwise distance calculation"
          );
        return d(w);
      },
    });
    function u(y) {
      return typeof y == "number" || Qe(y);
    }
    function s(y) {
      return y.constructor !== Array && (y = v(y)), u(y[0]) && u(y[1]);
    }
    function o(y) {
      return (
        y.constructor !== Array && (y = v(y)), u(y[0]) && u(y[1]) && u(y[2])
      );
    }
    function l(y) {
      return Array.isArray(y) || (y = v(y)), y.every(u);
    }
    function p(y) {
      return (
        y.constructor !== Array && (y = v(y)),
        u(y[0]) && u(y[1]) && u(y[2]) && u(y[3]) && u(y[4]) && u(y[5])
      );
    }
    function v(y) {
      for (var w = Object.keys(y), g = [], S = 0; S < w.length; S++)
        g.push(y[w[S]]);
      return g;
    }
    function h(y) {
      if (y[0].length === 2 && u(y[0][0]) && u(y[0][1])) {
        if (y.some((w) => w.length !== 2 || !u(w[0]) || !u(w[1]))) return !1;
      } else if (y[0].length === 3 && u(y[0][0]) && u(y[0][1]) && u(y[0][2])) {
        if (y.some((w) => w.length !== 3 || !u(w[0]) || !u(w[1]) || !u(w[2])))
          return !1;
      } else return !1;
      return !0;
    }
    function x(y, w, g, S, A) {
      var E = f(t(t(n(g, y), n(S, w)), A)),
        M = m(t(n(g, g), n(S, S)));
      return i(E, M);
    }
    function b(y, w, g, S, A, E, M, B, C) {
      var _ = [
        a(n(a(A, w), C), n(a(E, g), B)),
        a(n(a(E, g), M), n(a(S, y), C)),
        a(n(a(S, y), B), n(a(A, w), M)),
      ];
      _ = m(t(t(n(_[0], _[0]), n(_[1], _[1])), n(_[2], _[2])));
      var z = m(t(t(n(M, M), n(B, B)), n(C, C)));
      return i(_, z);
    }
    function N(y, w) {
      for (var g = y.length, S = 0, A = 0, E = 0; E < g; E++)
        (A = a(y[E], w[E])), (S = t(n(A, A), S));
      return m(S);
    }
    function d(y) {
      for (var w = [], g = [], S = [], A = 0; A < y.length - 1; A++)
        for (var E = A + 1; E < y.length; E++)
          y[0].length === 2
            ? ((g = [y[A][0], y[A][1]]), (S = [y[E][0], y[E][1]]))
            : y[0].length === 3 &&
              ((g = [y[A][0], y[A][1], y[A][2]]),
              (S = [y[E][0], y[E][1], y[E][2]])),
            w.push(N(g, S));
      return w;
    }
  }),
  hD = "intersect",
  dD = [
    "typed",
    "config",
    "abs",
    "add",
    "addScalar",
    "matrix",
    "multiply",
    "multiplyScalar",
    "divideScalar",
    "subtract",
    "smaller",
    "equalScalar",
    "flatten",
    "isZero",
    "isNumeric",
  ],
  gD = P(hD, dD, (e) => {
    var {
      typed: r,
      config: t,
      abs: a,
      add: n,
      addScalar: i,
      matrix: c,
      multiply: m,
      multiplyScalar: f,
      divideScalar: u,
      subtract: s,
      smaller: o,
      equalScalar: l,
      flatten: p,
      isZero: v,
      isNumeric: h,
    } = e;
    return r("intersect", {
      "Array, Array, Array": x,
      "Array, Array, Array, Array": b,
      "Matrix, Matrix, Matrix": function (B, C, _) {
        var z = x(B.valueOf(), C.valueOf(), _.valueOf());
        return z === null ? null : c(z);
      },
      "Matrix, Matrix, Matrix, Matrix": function (B, C, _, z) {
        var I = b(B.valueOf(), C.valueOf(), _.valueOf(), z.valueOf());
        return I === null ? null : c(I);
      },
    });
    function x(M, B, C) {
      if (((M = N(M)), (B = N(B)), (C = N(C)), !y(M)))
        throw new TypeError(
          "Array with 3 numbers or BigNumbers expected for first argument"
        );
      if (!y(B))
        throw new TypeError(
          "Array with 3 numbers or BigNumbers expected for second argument"
        );
      if (!w(C))
        throw new TypeError("Array with 4 numbers expected as third argument");
      return E(M[0], M[1], M[2], B[0], B[1], B[2], C[0], C[1], C[2], C[3]);
    }
    function b(M, B, C, _) {
      if (((M = N(M)), (B = N(B)), (C = N(C)), (_ = N(_)), M.length === 2)) {
        if (!d(M))
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for first argument"
          );
        if (!d(B))
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for second argument"
          );
        if (!d(C))
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for third argument"
          );
        if (!d(_))
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for fourth argument"
          );
        return g(M, B, C, _);
      } else if (M.length === 3) {
        if (!y(M))
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for first argument"
          );
        if (!y(B))
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for second argument"
          );
        if (!y(C))
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for third argument"
          );
        if (!y(_))
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for fourth argument"
          );
        return A(
          M[0],
          M[1],
          M[2],
          B[0],
          B[1],
          B[2],
          C[0],
          C[1],
          C[2],
          _[0],
          _[1],
          _[2]
        );
      } else
        throw new TypeError(
          "Arrays with two or thee dimensional points expected"
        );
    }
    function N(M) {
      return M.length === 1
        ? M[0]
        : M.length > 1 &&
          Array.isArray(M[0]) &&
          M.every((B) => Array.isArray(B) && B.length === 1)
        ? p(M)
        : M;
    }
    function d(M) {
      return M.length === 2 && h(M[0]) && h(M[1]);
    }
    function y(M) {
      return M.length === 3 && h(M[0]) && h(M[1]) && h(M[2]);
    }
    function w(M) {
      return M.length === 4 && h(M[0]) && h(M[1]) && h(M[2]) && h(M[3]);
    }
    function g(M, B, C, _) {
      var z = M,
        I = C,
        T = s(z, B),
        D = s(I, _),
        Z = s(f(T[0], D[1]), f(D[0], T[1]));
      if (v(Z) || o(a(Z), t.epsilon)) return null;
      var O = f(D[0], z[1]),
        H = f(D[1], z[0]),
        Q = f(D[0], I[1]),
        te = f(D[1], I[0]),
        J = u(i(s(s(O, H), Q), te), Z);
      return n(m(T, J), z);
    }
    function S(M, B, C, _, z, I, T, D, Z, O, H, Q) {
      var te = f(s(M, B), s(C, _)),
        J = f(s(z, I), s(T, D)),
        re = f(s(Z, O), s(H, Q));
      return i(i(te, J), re);
    }
    function A(M, B, C, _, z, I, T, D, Z, O, H, Q) {
      var te = S(M, T, O, T, B, D, H, D, C, Z, Q, Z),
        J = S(O, T, _, M, H, D, z, B, Q, Z, I, C),
        re = S(M, T, _, M, B, D, z, B, C, Z, I, C),
        oe = S(O, T, O, T, H, D, H, D, Q, Z, Q, Z),
        ae = S(_, M, _, M, z, B, z, B, I, C, I, C),
        ce = s(f(te, J), f(re, oe)),
        se = s(f(ae, oe), f(J, J));
      if (v(se)) return null;
      var pe = u(ce, se),
        ne = u(i(te, f(pe, J)), oe),
        Ae = i(M, f(pe, s(_, M))),
        Ce = i(B, f(pe, s(z, B))),
        ge = i(C, f(pe, s(I, C))),
        Se = i(T, f(ne, s(O, T))),
        q = i(D, f(ne, s(H, D))),
        Y = i(Z, f(ne, s(Q, Z)));
      return l(Ae, Se) && l(Ce, q) && l(ge, Y) ? [Ae, Ce, ge] : null;
    }
    function E(M, B, C, _, z, I, T, D, Z, O) {
      var H = f(M, T),
        Q = f(_, T),
        te = f(B, D),
        J = f(z, D),
        re = f(C, Z),
        oe = f(I, Z),
        ae = s(s(s(O, H), te), re),
        ce = s(s(s(i(i(Q, J), oe), H), te), re),
        se = u(ae, ce),
        pe = i(M, f(se, s(_, M))),
        ne = i(B, f(se, s(z, B))),
        Ae = i(C, f(se, s(I, C)));
      return [pe, ne, Ae];
    }
  }),
  hm = "sum",
  yD = ["typed", "config", "add", "numeric"],
  Nh = P(hm, yD, (e) => {
    var { typed: r, config: t, add: a, numeric: n } = e;
    return r(hm, {
      "Array | Matrix": i,
      "Array | Matrix, number | BigNumber": c,
      "...": function (f) {
        if (ya(f))
          throw new TypeError("Scalar values expected in function sum");
        return i(f);
      },
    });
    function i(m) {
      var f;
      return (
        Qt(m, function (u) {
          try {
            f = f === void 0 ? u : a(f, u);
          } catch (s) {
            throw Xr(s, "sum", u);
          }
        }),
        f === void 0 && (f = n(0, t.number)),
        typeof f == "string" && (f = n(f, t.number)),
        f
      );
    }
    function c(m, f) {
      try {
        var u = ro(m, f, a);
        return u;
      } catch (s) {
        throw Xr(s, "sum");
      }
    }
  }),
  bi = "cumsum",
  bD = ["typed", "add", "unaryPlus"],
  Mh = P(bi, bD, (e) => {
    var { typed: r, add: t, unaryPlus: a } = e;
    return r(bi, {
      Array: n,
      Matrix: function (u) {
        return u.create(n(u.valueOf()));
      },
      "Array, number | BigNumber": c,
      "Matrix, number | BigNumber": function (u, s) {
        return u.create(c(u.valueOf(), s));
      },
      "...": function (u) {
        if (ya(u))
          throw new TypeError(
            "All values expected to be scalar in function cumsum"
          );
        return n(u);
      },
    });
    function n(f) {
      try {
        return i(f);
      } catch (u) {
        throw Xr(u, bi);
      }
    }
    function i(f) {
      if (f.length === 0) return [];
      for (var u = [a(f[0])], s = 1; s < f.length; ++s)
        u.push(t(u[s - 1], f[s]));
      return u;
    }
    function c(f, u) {
      var s = Xe(f);
      if (u < 0 || u >= s.length) throw new At(u, s.length);
      try {
        return m(f, u);
      } catch (o) {
        throw Xr(o, bi);
      }
    }
    function m(f, u) {
      var s, o, l;
      if (u <= 0) {
        var p = f[0][0];
        if (Array.isArray(p)) {
          for (l = ov(f), o = [], s = 0; s < l.length; s++)
            o[s] = m(l[s], u - 1);
          return o;
        } else return i(f);
      } else {
        for (o = [], s = 0; s < f.length; s++) o[s] = m(f[s], u - 1);
        return o;
      }
    }
  }),
  dm = "mean",
  xD = ["typed", "add", "divide"],
  Ah = P(dm, xD, (e) => {
    var { typed: r, add: t, divide: a } = e;
    return r(dm, {
      "Array | Matrix": i,
      "Array | Matrix, number | BigNumber": n,
      "...": function (m) {
        if (ya(m))
          throw new TypeError("Scalar values expected in function mean");
        return i(m);
      },
    });
    function n(c, m) {
      try {
        var f = ro(c, m, t),
          u = Array.isArray(c) ? Xe(c) : c.size();
        return a(f, u[m]);
      } catch (s) {
        throw Xr(s, "mean");
      }
    }
    function i(c) {
      var m,
        f = 0;
      if (
        (Qt(c, function (u) {
          try {
            (m = m === void 0 ? u : t(m, u)), f++;
          } catch (s) {
            throw Xr(s, "mean", u);
          }
        }),
        f === 0)
      )
        throw new Error("Cannot calculate the mean of an empty array");
      return a(m, f);
    }
  }),
  gm = "median",
  wD = ["typed", "add", "divide", "compare", "partitionSelect"],
  ND = P(gm, wD, (e) => {
    var { typed: r, add: t, divide: a, compare: n, partitionSelect: i } = e;
    function c(u) {
      try {
        u = Ke(u.valueOf());
        var s = u.length;
        if (s === 0)
          throw new Error("Cannot calculate median of an empty array");
        if (s % 2 === 0) {
          for (var o = s / 2 - 1, l = i(u, o + 1), p = u[o], v = 0; v < o; ++v)
            n(u[v], p) > 0 && (p = u[v]);
          return f(p, l);
        } else {
          var h = i(u, (s - 1) / 2);
          return m(h);
        }
      } catch (x) {
        throw Xr(x, "median");
      }
    }
    var m = r({
        "number | BigNumber | Complex | Unit": function (s) {
          return s;
        },
      }),
      f = r({
        "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit":
          function (s, o) {
            return a(t(s, o), 2);
          },
      });
    return r(gm, {
      "Array | Matrix": c,
      "Array | Matrix, number | BigNumber": function (s, o) {
        throw new Error("median(A, dim) is not yet supported");
      },
      "...": function (s) {
        if (ya(s))
          throw new TypeError("Scalar values expected in function median");
        return c(s);
      },
    });
  }),
  ym = "mad",
  MD = ["typed", "abs", "map", "median", "subtract"],
  AD = P(ym, MD, (e) => {
    var { typed: r, abs: t, map: a, median: n, subtract: i } = e;
    return r(ym, {
      "Array | Matrix": c,
      "...": function (f) {
        return c(f);
      },
    });
    function c(m) {
      if (((m = Ke(m.valueOf())), m.length === 0))
        throw new Error(
          "Cannot calculate median absolute deviation (mad) of an empty array"
        );
      try {
        var f = n(m);
        return n(
          a(m, function (u) {
            return t(i(u, f));
          })
        );
      } catch (u) {
        throw u instanceof TypeError && u.message.indexOf("median") !== -1
          ? new TypeError(u.message.replace("median", "mad"))
          : Xr(u, "mad");
      }
    }
  }),
  Vo = "unbiased",
  bm = "variance",
  SD = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"],
  Sh = P(bm, SD, (e) => {
    var {
      typed: r,
      add: t,
      subtract: a,
      multiply: n,
      divide: i,
      apply: c,
      isNaN: m,
    } = e;
    return r(bm, {
      "Array | Matrix": function (o) {
        return f(o, Vo);
      },
      "Array | Matrix, string": f,
      "Array | Matrix, number | BigNumber": function (o, l) {
        return u(o, l, Vo);
      },
      "Array | Matrix, number | BigNumber, string": u,
      "...": function (o) {
        return f(o, Vo);
      },
    });
    function f(s, o) {
      var l,
        p = 0;
      if (s.length === 0)
        throw new SyntaxError(
          "Function variance requires one or more parameters (0 provided)"
        );
      if (
        (Qt(s, function (x) {
          try {
            (l = l === void 0 ? x : t(l, x)), p++;
          } catch (b) {
            throw Xr(b, "variance", x);
          }
        }),
        p === 0)
      )
        throw new Error("Cannot calculate variance of an empty array");
      var v = i(l, p);
      if (
        ((l = void 0),
        Qt(s, function (x) {
          var b = a(x, v);
          l = l === void 0 ? n(b, b) : t(l, n(b, b));
        }),
        m(l))
      )
        return l;
      switch (o) {
        case "uncorrected":
          return i(l, p);
        case "biased":
          return i(l, p + 1);
        case "unbiased": {
          var h = Qe(l) ? l.mul(0) : 0;
          return p === 1 ? h : i(l, p - 1);
        }
        default:
          throw new Error(
            'Unknown normalization "' +
              o +
              '". Choose "unbiased" (default), "uncorrected", or "biased".'
          );
      }
    }
    function u(s, o, l) {
      try {
        if (s.length === 0)
          throw new SyntaxError(
            "Function variance requires one or more parameters (0 provided)"
          );
        return c(s, o, (p) => f(p, l));
      } catch (p) {
        throw Xr(p, "variance");
      }
    }
  }),
  ED = "quantileSeq",
  CD = ["typed", "add", "multiply", "partitionSelect", "compare"],
  $D = P(ED, CD, (e) => {
    var { typed: r, add: t, multiply: a, partitionSelect: n, compare: i } = e;
    function c(u, s, o) {
      var l, p, v;
      if (arguments.length < 2 || arguments.length > 3)
        throw new SyntaxError(
          "Function quantileSeq requires two or three parameters"
        );
      if (da(u)) {
        if (((o = o || !1), typeof o == "boolean")) {
          if (((p = u.valueOf()), je(s))) {
            if (s < 0) throw new Error("N/prob must be non-negative");
            if (s <= 1) return m(p, s, o);
            if (s > 1) {
              if (!Be(s)) throw new Error("N must be a positive integer");
              var h = s + 1;
              l = new Array(s);
              for (var x = 0; x < s; ) l[x] = m(p, ++x / h, o);
              return l;
            }
          }
          if (Qe(s)) {
            var b = s.constructor;
            if (s.isNegative()) throw new Error("N/prob must be non-negative");
            if (((v = new b(1)), s.lte(v))) return new b(m(p, s, o));
            if (s.gt(v)) {
              if (!s.isInteger())
                throw new Error("N must be a positive integer");
              var N = s.toNumber();
              if (N > 4294967295)
                throw new Error(
                  "N must be less than or equal to 2^32-1, as that is the maximum length of an Array"
                );
              var d = new b(N + 1);
              l = new Array(N);
              for (var y = 0; y < N; ) l[y] = new b(m(p, new b(++y).div(d), o));
              return l;
            }
          }
          if (Array.isArray(s)) {
            l = new Array(s.length);
            for (var w = 0; w < l.length; ++w) {
              var g = s[w];
              if (je(g)) {
                if (g < 0 || g > 1)
                  throw new Error(
                    "Probability must be between 0 and 1, inclusive"
                  );
              } else if (Qe(g)) {
                if (((v = new g.constructor(1)), g.isNegative() || g.gt(v)))
                  throw new Error(
                    "Probability must be between 0 and 1, inclusive"
                  );
              } else
                throw new TypeError(
                  "Unexpected type of argument in function quantileSeq"
                );
              l[w] = m(p, g, o);
            }
            return l;
          }
          throw new TypeError(
            "Unexpected type of argument in function quantileSeq"
          );
        }
        throw new TypeError(
          "Unexpected type of argument in function quantileSeq"
        );
      }
      throw new TypeError(
        "Unexpected type of argument in function quantileSeq"
      );
    }
    function m(u, s, o) {
      var l = Ke(u),
        p = l.length;
      if (p === 0)
        throw new Error("Cannot calculate quantile of an empty sequence");
      if (je(s)) {
        var v = s * (p - 1),
          h = v % 1;
        if (h === 0) {
          var x = o ? l[v] : n(l, v);
          return f(x), x;
        }
        var b = Math.floor(v),
          N,
          d;
        if (o) (N = l[b]), (d = l[b + 1]);
        else {
          (d = n(l, b + 1)), (N = l[b]);
          for (var y = 0; y < b; ++y) i(l[y], N) > 0 && (N = l[y]);
        }
        return f(N), f(d), t(a(N, 1 - h), a(d, h));
      }
      var w = s.times(p - 1);
      if (w.isInteger()) {
        w = w.toNumber();
        var g = o ? l[w] : n(l, w);
        return f(g), g;
      }
      var S = w.floor(),
        A = w.minus(S),
        E = S.toNumber(),
        M,
        B;
      if (o) (M = l[E]), (B = l[E + 1]);
      else {
        (B = n(l, E + 1)), (M = l[E]);
        for (var C = 0; C < E; ++C) i(l[C], M) > 0 && (M = l[C]);
      }
      f(M), f(B);
      var _ = new A.constructor(1);
      return t(a(M, _.minus(A)), a(B, A));
    }
    var f = r({
      "number | BigNumber | Unit": function (s) {
        return s;
      },
    });
    return c;
  }),
  xm = "std",
  OD = ["typed", "sqrt", "variance"],
  Eh = P(xm, OD, (e) => {
    var { typed: r, sqrt: t, variance: a } = e;
    return r(xm, {
      "Array | Matrix": n,
      "Array | Matrix, string": n,
      "Array | Matrix, number | BigNumber": n,
      "Array | Matrix, number | BigNumber, string": n,
      "...": function (c) {
        return n(c);
      },
    });
    function n(i, c) {
      if (i.length === 0)
        throw new SyntaxError(
          "Function std requires one or more parameters (0 provided)"
        );
      try {
        return t(a.apply(null, arguments));
      } catch (m) {
        throw m instanceof TypeError && m.message.indexOf(" variance") !== -1
          ? new TypeError(m.message.replace(" variance", " std"))
          : m;
      }
    }
  }),
  wm = "combinations",
  TD = ["typed"],
  DD = P(wm, TD, (e) => {
    var { typed: r } = e;
    return r(wm, {
      "number, number": Tv,
      "BigNumber, BigNumber": function (a, n) {
        var i = a.constructor,
          c,
          m,
          f = a.minus(n),
          u = new i(1);
        if (!Nm(a) || !Nm(n))
          throw new TypeError(
            "Positive integer value expected in function combinations"
          );
        if (n.gt(a))
          throw new TypeError("k must be less than n in function combinations");
        if (((c = u), n.lt(f)))
          for (m = u; m.lte(f); m = m.plus(u))
            c = c.times(n.plus(m)).dividedBy(m);
        else
          for (m = u; m.lte(n); m = m.plus(u))
            c = c.times(f.plus(m)).dividedBy(m);
        return c;
      },
    });
  });
function Nm(e) {
  return e.isInteger() && e.gte(0);
}
var Mm = "combinationsWithRep",
  BD = ["typed"],
  _D = P(Mm, BD, (e) => {
    var { typed: r } = e;
    return r(Mm, {
      "number, number": function (a, n) {
        if (!Be(a) || a < 0)
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        if (!Be(n) || n < 0)
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        if (a < 1)
          throw new TypeError("k must be less than or equal to n + k - 1");
        if (n < a - 1) {
          var i = Zt(a, a + n - 1);
          return i / Zt(1, n);
        }
        var c = Zt(n + 1, a + n - 1);
        return c / Zt(1, a - 1);
      },
      "BigNumber, BigNumber": function (a, n) {
        var i = a.constructor,
          c,
          m,
          f = new i(1),
          u = a.minus(f);
        if (!Am(a) || !Am(n))
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        if (a.lt(f))
          throw new TypeError(
            "k must be less than or equal to n + k - 1 in function combinationsWithRep"
          );
        if (((c = f), n.lt(u)))
          for (m = f; m.lte(u); m = m.plus(f))
            c = c.times(n.plus(m)).dividedBy(m);
        else
          for (m = f; m.lte(n); m = m.plus(f))
            c = c.times(u.plus(m)).dividedBy(m);
        return c;
      },
    });
  });
function Am(e) {
  return e.isInteger() && e.gte(0);
}
var Sm = "gamma",
  ID = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"],
  RD = P(Sm, ID, (e) => {
    var {
      typed: r,
      config: t,
      multiplyScalar: a,
      pow: n,
      BigNumber: i,
      Complex: c,
    } = e;
    return r(Sm, {
      number: Xs,
      Complex: function (u) {
        if (u.im === 0) return this(u.re);
        if (u.re < 0.5) {
          var s = new c(1 - u.re, -u.im),
            o = new c(Math.PI * u.re, Math.PI * u.im);
          return new c(Math.PI).div(o.sin()).div(this(s));
        }
        u = new c(u.re - 1, u.im);
        for (var l = new c(na[0], 0), p = 1; p < na.length; ++p) {
          var v = new c(na[p], 0);
          l = l.add(v.div(u.add(p)));
        }
        var h = new c(u.re + Rv + 0.5, u.im),
          x = Math.sqrt(2 * Math.PI),
          b = h.pow(u.add(0.5)),
          N = h.neg().exp();
        return l.mul(x).mul(b).mul(N);
      },
      BigNumber: function (u) {
        if (u.isInteger())
          return u.isNegative() || u.isZero() ? new i(1 / 0) : m(u.minus(1));
        if (!u.isFinite()) return new i(u.isNegative() ? NaN : 1 / 0);
        throw new Error("Integer BigNumber expected");
      },
      "Array | Matrix": function (u) {
        return Oe(u, this);
      },
    });
    function m(f) {
      if (f < 8) return new i([1, 1, 2, 6, 24, 120, 720, 5040][f]);
      var u = t.precision + (Math.log(f.toNumber()) | 0),
        s = i.clone({ precision: u });
      if (f % 2 === 1) return f.times(m(new i(f - 1)));
      for (var o = f, l = new s(f), p = f.toNumber(); o > 2; )
        (o -= 2), (p += o), (l = l.times(p));
      return new i(l.toPrecision(i.precision));
    }
  }),
  Em = "lgamma",
  FD = ["Complex", "typed"],
  PD = P(Em, FD, (e) => {
    var { Complex: r, typed: t } = e,
      a = 7,
      n = 7,
      i = [
        -0.029550653594771242, 0.00641025641025641, -0.0019175269175269176,
        0.0008417508417508417, -0.0005952380952380953, 0.0007936507936507937,
        -0.002777777777777778, 0.08333333333333333,
      ];
    return t(Em, {
      number: Fi,
      Complex: function (u) {
        var s = 6.283185307179586,
          o = 1.1447298858494002,
          l = 0.1;
        if (u.isNaN()) return new r(NaN, NaN);
        if (u.im === 0) return new r(Fi(u.re), 0);
        if (u.re >= a || Math.abs(u.im) >= n) return c(u);
        if (u.re <= l) {
          var p = j0(s, u.im) * Math.floor(0.5 * u.re + 0.25),
            v = u.mul(Math.PI).sin().log(),
            h = this(new r(1 - u.re, -u.im));
          return new r(o, p).sub(v).sub(h);
        } else return u.im >= 0 ? m(u) : m(u.conjugate()).conjugate();
      },
      BigNumber: function () {
        throw new Error(
          "mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber"
        );
      },
    });
    function c(f) {
      for (
        var u = f.sub(0.5).mul(f.log()).sub(f).add(Fv),
          s = new r(1, 0).div(f),
          o = s.div(f),
          l = i[0],
          p = i[1],
          v = 2 * o.re,
          h = o.re * o.re + o.im * o.im,
          x = 2;
        x < 8;
        x++
      ) {
        var b = p;
        (p = -h * l + i[x]), (l = v * l + b);
      }
      var N = s.mul(o.mul(l).add(p));
      return u.add(N);
    }
    function m(f) {
      var u = 0,
        s = 0,
        o = f;
      for (f = f.add(1); f.re <= a; ) {
        o = o.mul(f);
        var l = o.im < 0 ? 1 : 0;
        l !== 0 && s === 0 && u++, (s = l), (f = f.add(1));
      }
      return c(f)
        .sub(o.log())
        .sub(new r(0, u * 2 * Math.PI * 1));
    }
  }),
  Cm = "factorial",
  qD = ["typed", "gamma"],
  zD = P(Cm, qD, (e) => {
    var { typed: r, gamma: t } = e;
    return r(Cm, {
      number: function (n) {
        if (n < 0) throw new Error("Value must be non-negative");
        return t(n + 1);
      },
      BigNumber: function (n) {
        if (n.isNegative()) throw new Error("Value must be non-negative");
        return t(n.plus(1));
      },
      "Array | Matrix": function (n) {
        return Oe(n, this);
      },
    });
  }),
  $m = "kldivergence",
  UD = [
    "typed",
    "matrix",
    "divide",
    "sum",
    "multiply",
    "dotDivide",
    "log",
    "isNumeric",
  ],
  LD = P($m, UD, (e) => {
    var {
      typed: r,
      matrix: t,
      divide: a,
      sum: n,
      multiply: i,
      dotDivide: c,
      log: m,
      isNumeric: f,
    } = e;
    return r($m, {
      "Array, Array": function (o, l) {
        return u(t(o), t(l));
      },
      "Matrix, Array": function (o, l) {
        return u(o, t(l));
      },
      "Array, Matrix": function (o, l) {
        return u(t(o), l);
      },
      "Matrix, Matrix": function (o, l) {
        return u(o, l);
      },
    });
    function u(s, o) {
      var l = o.size().length,
        p = s.size().length;
      if (l > 1) throw new Error("first object must be one dimensional");
      if (p > 1) throw new Error("second object must be one dimensional");
      if (l !== p) throw new Error("Length of two vectors must be equal");
      var v = n(s);
      if (v === 0)
        throw new Error("Sum of elements in first object must be non zero");
      var h = n(o);
      if (h === 0)
        throw new Error("Sum of elements in second object must be non zero");
      var x = a(s, n(s)),
        b = a(o, n(o)),
        N = n(i(x, m(c(x, b))));
      return f(N) ? N : Number.NaN;
    }
  }),
  Om = "multinomial",
  kD = [
    "typed",
    "add",
    "divide",
    "multiply",
    "factorial",
    "isInteger",
    "isPositive",
  ],
  VD = P(Om, kD, (e) => {
    var {
      typed: r,
      add: t,
      divide: a,
      multiply: n,
      factorial: i,
      isInteger: c,
      isPositive: m,
    } = e;
    return r(Om, {
      "Array | Matrix": function (u) {
        var s = 0,
          o = 1;
        return (
          Qt(u, function (l) {
            if (!c(l) || !m(l))
              throw new TypeError(
                "Positive integer value expected in function multinomial"
              );
            (s = t(s, l)), (o = n(o, i(l)));
          }),
          a(i(s), o)
        );
      },
    });
  }),
  Tm = "permutations",
  GD = ["typed", "factorial"],
  HD = P(Tm, GD, (e) => {
    var { typed: r, factorial: t } = e;
    return r(Tm, {
      "number | BigNumber": t,
      "number, number": function (n, i) {
        if (!Be(n) || n < 0)
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        if (!Be(i) || i < 0)
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        if (i > n)
          throw new TypeError(
            "second argument k must be less than or equal to first argument n"
          );
        return Zt(n - i + 1, n);
      },
      "BigNumber, BigNumber": function (n, i) {
        var c, m;
        if (!Dm(n) || !Dm(i))
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        if (i.gt(n))
          throw new TypeError(
            "second argument k must be less than or equal to first argument n"
          );
        var f = n.mul(0).add(1);
        for (c = f, m = n.minus(i).plus(1); m.lte(n); m = m.plus(1))
          c = c.times(m);
        return c;
      },
    });
  });
function Dm(e) {
  return e.isInteger() && e.gte(0);
}
var ru = { exports: {} };
ru.exports;
(function (e) {
  (function (r, t, a) {
    function n(f) {
      var u = this,
        s = m();
      (u.next = function () {
        var o = 2091639 * u.s0 + u.c * 23283064365386963e-26;
        return (u.s0 = u.s1), (u.s1 = u.s2), (u.s2 = o - (u.c = o | 0));
      }),
        (u.c = 1),
        (u.s0 = s(" ")),
        (u.s1 = s(" ")),
        (u.s2 = s(" ")),
        (u.s0 -= s(f)),
        u.s0 < 0 && (u.s0 += 1),
        (u.s1 -= s(f)),
        u.s1 < 0 && (u.s1 += 1),
        (u.s2 -= s(f)),
        u.s2 < 0 && (u.s2 += 1),
        (s = null);
    }
    function i(f, u) {
      return (u.c = f.c), (u.s0 = f.s0), (u.s1 = f.s1), (u.s2 = f.s2), u;
    }
    function c(f, u) {
      var s = new n(f),
        o = u && u.state,
        l = s.next;
      return (
        (l.int32 = function () {
          return (s.next() * 4294967296) | 0;
        }),
        (l.double = function () {
          return l() + ((l() * 2097152) | 0) * 11102230246251565e-32;
        }),
        (l.quick = l),
        o &&
          (typeof o == "object" && i(o, s),
          (l.state = function () {
            return i(s, {});
          })),
        l
      );
    }
    function m() {
      var f = 4022871197,
        u = function (s) {
          s = String(s);
          for (var o = 0; o < s.length; o++) {
            f += s.charCodeAt(o);
            var l = 0.02519603282416938 * f;
            (f = l >>> 0),
              (l -= f),
              (l *= f),
              (f = l >>> 0),
              (l -= f),
              (f += l * 4294967296);
          }
          return (f >>> 0) * 23283064365386963e-26;
        };
      return u;
    }
    t && t.exports
      ? (t.exports = c)
      : a && a.amd
      ? a(function () {
          return c;
        })
      : (this.alea = c);
  })(gn, e, !1);
})(ru);
var ZD = ru.exports,
  tu = { exports: {} };
tu.exports;
(function (e) {
  (function (r, t, a) {
    function n(m) {
      var f = this,
        u = "";
      (f.x = 0),
        (f.y = 0),
        (f.z = 0),
        (f.w = 0),
        (f.next = function () {
          var o = f.x ^ (f.x << 11);
          return (
            (f.x = f.y),
            (f.y = f.z),
            (f.z = f.w),
            (f.w ^= (f.w >>> 19) ^ o ^ (o >>> 8))
          );
        }),
        m === (m | 0) ? (f.x = m) : (u += m);
      for (var s = 0; s < u.length + 64; s++)
        (f.x ^= u.charCodeAt(s) | 0), f.next();
    }
    function i(m, f) {
      return (f.x = m.x), (f.y = m.y), (f.z = m.z), (f.w = m.w), f;
    }
    function c(m, f) {
      var u = new n(m),
        s = f && f.state,
        o = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (o.double = function () {
          do
            var l = u.next() >>> 11,
              p = (u.next() >>> 0) / 4294967296,
              v = (l + p) / (1 << 21);
          while (v === 0);
          return v;
        }),
        (o.int32 = u.next),
        (o.quick = o),
        s &&
          (typeof s == "object" && i(s, u),
          (o.state = function () {
            return i(u, {});
          })),
        o
      );
    }
    t && t.exports
      ? (t.exports = c)
      : a && a.amd
      ? a(function () {
          return c;
        })
      : (this.xor128 = c);
  })(gn, e, !1);
})(tu);
var JD = tu.exports,
  nu = { exports: {} };
nu.exports;
(function (e) {
  (function (r, t, a) {
    function n(m) {
      var f = this,
        u = "";
      (f.next = function () {
        var o = f.x ^ (f.x >>> 2);
        return (
          (f.x = f.y),
          (f.y = f.z),
          (f.z = f.w),
          (f.w = f.v),
          ((f.d = (f.d + 362437) | 0) +
            (f.v = f.v ^ (f.v << 4) ^ (o ^ (o << 1)))) |
            0
        );
      }),
        (f.x = 0),
        (f.y = 0),
        (f.z = 0),
        (f.w = 0),
        (f.v = 0),
        m === (m | 0) ? (f.x = m) : (u += m);
      for (var s = 0; s < u.length + 64; s++)
        (f.x ^= u.charCodeAt(s) | 0),
          s == u.length && (f.d = (f.x << 10) ^ (f.x >>> 4)),
          f.next();
    }
    function i(m, f) {
      return (
        (f.x = m.x),
        (f.y = m.y),
        (f.z = m.z),
        (f.w = m.w),
        (f.v = m.v),
        (f.d = m.d),
        f
      );
    }
    function c(m, f) {
      var u = new n(m),
        s = f && f.state,
        o = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (o.double = function () {
          do
            var l = u.next() >>> 11,
              p = (u.next() >>> 0) / 4294967296,
              v = (l + p) / (1 << 21);
          while (v === 0);
          return v;
        }),
        (o.int32 = u.next),
        (o.quick = o),
        s &&
          (typeof s == "object" && i(s, u),
          (o.state = function () {
            return i(u, {});
          })),
        o
      );
    }
    t && t.exports
      ? (t.exports = c)
      : a && a.amd
      ? a(function () {
          return c;
        })
      : (this.xorwow = c);
  })(gn, e, !1);
})(nu);
var WD = nu.exports,
  au = { exports: {} };
au.exports;
(function (e) {
  (function (r, t, a) {
    function n(m) {
      var f = this;
      f.next = function () {
        var s = f.x,
          o = f.i,
          l,
          p;
        return (
          (l = s[o]),
          (l ^= l >>> 7),
          (p = l ^ (l << 24)),
          (l = s[(o + 1) & 7]),
          (p ^= l ^ (l >>> 10)),
          (l = s[(o + 3) & 7]),
          (p ^= l ^ (l >>> 3)),
          (l = s[(o + 4) & 7]),
          (p ^= l ^ (l << 7)),
          (l = s[(o + 7) & 7]),
          (l = l ^ (l << 13)),
          (p ^= l ^ (l << 9)),
          (s[o] = p),
          (f.i = (o + 1) & 7),
          p
        );
      };
      function u(s, o) {
        var l,
          p = [];
        if (o === (o | 0)) p[0] = o;
        else
          for (o = "" + o, l = 0; l < o.length; ++l)
            p[l & 7] =
              (p[l & 7] << 15) ^ ((o.charCodeAt(l) + p[(l + 1) & 7]) << 13);
        for (; p.length < 8; ) p.push(0);
        for (l = 0; l < 8 && p[l] === 0; ++l);
        for (l == 8 ? (p[7] = -1) : p[l], s.x = p, s.i = 0, l = 256; l > 0; --l)
          s.next();
      }
      u(f, m);
    }
    function i(m, f) {
      return (f.x = m.x.slice()), (f.i = m.i), f;
    }
    function c(m, f) {
      m == null && (m = +new Date());
      var u = new n(m),
        s = f && f.state,
        o = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (o.double = function () {
          do
            var l = u.next() >>> 11,
              p = (u.next() >>> 0) / 4294967296,
              v = (l + p) / (1 << 21);
          while (v === 0);
          return v;
        }),
        (o.int32 = u.next),
        (o.quick = o),
        s &&
          (s.x && i(s, u),
          (o.state = function () {
            return i(u, {});
          })),
        o
      );
    }
    t && t.exports
      ? (t.exports = c)
      : a && a.amd
      ? a(function () {
          return c;
        })
      : (this.xorshift7 = c);
  })(gn, e, !1);
})(au);
var XD = au.exports,
  iu = { exports: {} };
iu.exports;
(function (e) {
  (function (r, t, a) {
    function n(m) {
      var f = this;
      f.next = function () {
        var s = f.w,
          o = f.X,
          l = f.i,
          p,
          v;
        return (
          (f.w = s = (s + 1640531527) | 0),
          (v = o[(l + 34) & 127]),
          (p = o[(l = (l + 1) & 127)]),
          (v ^= v << 13),
          (p ^= p << 17),
          (v ^= v >>> 15),
          (p ^= p >>> 12),
          (v = o[l] = v ^ p),
          (f.i = l),
          (v + (s ^ (s >>> 16))) | 0
        );
      };
      function u(s, o) {
        var l,
          p,
          v,
          h,
          x,
          b = [],
          N = 128;
        for (
          o === (o | 0)
            ? ((p = o), (o = null))
            : ((o = o + "\0"), (p = 0), (N = Math.max(N, o.length))),
            v = 0,
            h = -32;
          h < N;
          ++h
        )
          o && (p ^= o.charCodeAt((h + 32) % o.length)),
            h === 0 && (x = p),
            (p ^= p << 10),
            (p ^= p >>> 15),
            (p ^= p << 4),
            (p ^= p >>> 13),
            h >= 0 &&
              ((x = (x + 1640531527) | 0),
              (l = b[h & 127] ^= p + x),
              (v = l == 0 ? v + 1 : 0));
        for (
          v >= 128 && (b[((o && o.length) || 0) & 127] = -1),
            v = 127,
            h = 4 * 128;
          h > 0;
          --h
        )
          (p = b[(v + 34) & 127]),
            (l = b[(v = (v + 1) & 127)]),
            (p ^= p << 13),
            (l ^= l << 17),
            (p ^= p >>> 15),
            (l ^= l >>> 12),
            (b[v] = p ^ l);
        (s.w = x), (s.X = b), (s.i = v);
      }
      u(f, m);
    }
    function i(m, f) {
      return (f.i = m.i), (f.w = m.w), (f.X = m.X.slice()), f;
    }
    function c(m, f) {
      m == null && (m = +new Date());
      var u = new n(m),
        s = f && f.state,
        o = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (o.double = function () {
          do
            var l = u.next() >>> 11,
              p = (u.next() >>> 0) / 4294967296,
              v = (l + p) / (1 << 21);
          while (v === 0);
          return v;
        }),
        (o.int32 = u.next),
        (o.quick = o),
        s &&
          (s.X && i(s, u),
          (o.state = function () {
            return i(u, {});
          })),
        o
      );
    }
    t && t.exports
      ? (t.exports = c)
      : a && a.amd
      ? a(function () {
          return c;
        })
      : (this.xor4096 = c);
  })(gn, e, !1);
})(iu);
var YD = iu.exports,
  ou = { exports: {} };
ou.exports;
(function (e) {
  (function (r, t, a) {
    function n(m) {
      var f = this,
        u = "";
      (f.next = function () {
        var o = f.b,
          l = f.c,
          p = f.d,
          v = f.a;
        return (
          (o = (o << 25) ^ (o >>> 7) ^ l),
          (l = (l - p) | 0),
          (p = (p << 24) ^ (p >>> 8) ^ v),
          (v = (v - o) | 0),
          (f.b = o = (o << 20) ^ (o >>> 12) ^ l),
          (f.c = l = (l - p) | 0),
          (f.d = (p << 16) ^ (l >>> 16) ^ v),
          (f.a = (v - o) | 0)
        );
      }),
        (f.a = 0),
        (f.b = 0),
        (f.c = -1640531527),
        (f.d = 1367130551),
        m === Math.floor(m)
          ? ((f.a = (m / 4294967296) | 0), (f.b = m | 0))
          : (u += m);
      for (var s = 0; s < u.length + 20; s++)
        (f.b ^= u.charCodeAt(s) | 0), f.next();
    }
    function i(m, f) {
      return (f.a = m.a), (f.b = m.b), (f.c = m.c), (f.d = m.d), f;
    }
    function c(m, f) {
      var u = new n(m),
        s = f && f.state,
        o = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (o.double = function () {
          do
            var l = u.next() >>> 11,
              p = (u.next() >>> 0) / 4294967296,
              v = (l + p) / (1 << 21);
          while (v === 0);
          return v;
        }),
        (o.int32 = u.next),
        (o.quick = o),
        s &&
          (typeof s == "object" && i(s, u),
          (o.state = function () {
            return i(u, {});
          })),
        o
      );
    }
    t && t.exports
      ? (t.exports = c)
      : a && a.amd
      ? a(function () {
          return c;
        })
      : (this.tychei = c);
  })(gn, e, !1);
})(ou);
var QD = ou.exports,
  Ch = { exports: {} };
const jD = {},
  KD = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: jD },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  eB = ay(KD);
(function (e) {
  (function (r, t, a) {
    var n = 256,
      i = 6,
      c = 52,
      m = "random",
      f = a.pow(n, i),
      u = a.pow(2, c),
      s = u * 2,
      o = n - 1,
      l;
    function p(y, w, g) {
      var S = [];
      w = w == !0 ? { entropy: !0 } : w || {};
      var A = b(x(w.entropy ? [y, d(t)] : y ?? N(), 3), S),
        E = new v(S),
        M = function () {
          for (var B = E.g(i), C = f, _ = 0; B < u; )
            (B = (B + _) * n), (C *= n), (_ = E.g(1));
          for (; B >= s; ) (B /= 2), (C /= 2), (_ >>>= 1);
          return (B + _) / C;
        };
      return (
        (M.int32 = function () {
          return E.g(4) | 0;
        }),
        (M.quick = function () {
          return E.g(4) / 4294967296;
        }),
        (M.double = M),
        b(d(E.S), t),
        (
          w.pass ||
          g ||
          function (B, C, _, z) {
            return (
              z &&
                (z.S && h(z, E),
                (B.state = function () {
                  return h(E, {});
                })),
              _ ? ((a[m] = B), C) : B
            );
          }
        )(M, A, "global" in w ? w.global : this == a, w.state)
      );
    }
    function v(y) {
      var w,
        g = y.length,
        S = this,
        A = 0,
        E = (S.i = S.j = 0),
        M = (S.S = []);
      for (g || (y = [g++]); A < n; ) M[A] = A++;
      for (A = 0; A < n; A++)
        (M[A] = M[(E = o & (E + y[A % g] + (w = M[A])))]), (M[E] = w);
      (S.g = function (B) {
        for (var C, _ = 0, z = S.i, I = S.j, T = S.S; B--; )
          (C = T[(z = o & (z + 1))]),
            (_ = _ * n + T[o & ((T[z] = T[(I = o & (I + C))]) + (T[I] = C))]);
        return (S.i = z), (S.j = I), _;
      })(n);
    }
    function h(y, w) {
      return (w.i = y.i), (w.j = y.j), (w.S = y.S.slice()), w;
    }
    function x(y, w) {
      var g = [],
        S = typeof y,
        A;
      if (w && S == "object")
        for (A in y)
          try {
            g.push(x(y[A], w - 1));
          } catch {}
      return g.length ? g : S == "string" ? y : y + "\0";
    }
    function b(y, w) {
      for (var g = y + "", S, A = 0; A < g.length; )
        w[o & A] = o & ((S ^= w[o & A] * 19) + g.charCodeAt(A++));
      return d(w);
    }
    function N() {
      try {
        var y;
        return (
          l && (y = l.randomBytes)
            ? (y = y(n))
            : ((y = new Uint8Array(n)),
              (r.crypto || r.msCrypto).getRandomValues(y)),
          d(y)
        );
      } catch {
        var w = r.navigator,
          g = w && w.plugins;
        return [+new Date(), r, g, r.screen, d(t)];
      }
    }
    function d(y) {
      return String.fromCharCode.apply(0, y);
    }
    if ((b(a.random(), t), e.exports)) {
      e.exports = p;
      try {
        l = eB;
      } catch {}
    } else a["seed" + m] = p;
  })(typeof self < "u" ? self : gn, [], Math);
})(Ch);
var rB = Ch.exports,
  tB = ZD,
  nB = JD,
  aB = WD,
  iB = XD,
  oB = YD,
  sB = QD,
  Bn = rB;
Bn.alea = tB;
Bn.xor128 = nB;
Bn.xorwow = aB;
Bn.xorshift7 = iB;
Bn.xor4096 = oB;
Bn.tychei = sB;
var uB = Bn;
const $h = pa(uB);
var lB = $h(Date.now());
function ca(e) {
  var r;
  function t(n) {
    r = n === null ? lB : $h(String(n));
  }
  t(e);
  function a() {
    return r();
  }
  return a;
}
var Bm = "pickRandom",
  cB = ["typed", "config", "?on"],
  fB = P(Bm, cB, (e) => {
    var { typed: r, config: t, on: a } = e,
      n = ca(t.randomSeed);
    return (
      a &&
        a("config", function (c, m) {
          c.randomSeed !== m.randomSeed && (n = ca(c.randomSeed));
        }),
      r(Bm, {
        "Array | Matrix": function (m) {
          return i(m, {});
        },
        "Array | Matrix, Object": function (m, f) {
          return i(m, f);
        },
        "Array | Matrix, number": function (m, f) {
          return i(m, { number: f });
        },
        "Array | Matrix, Array | Matrix": function (m, f) {
          return i(m, { weights: f });
        },
        "Array | Matrix, Array | Matrix, number": function (m, f, u) {
          return i(m, { number: u, weights: f });
        },
        "Array | Matrix, number, Array | Matrix": function (m, f, u) {
          return i(m, { number: f, weights: u });
        },
      })
    );
    function i(c, m) {
      var { number: f, weights: u, elementWise: s = !0 } = m,
        o = typeof f > "u";
      o && (f = 1);
      var l = ze(c) ? c.create : ze(u) ? u.create : null;
      (c = c.valueOf()),
        u && (u = u.valueOf()),
        s === !0 && ((c = Ke(c)), (u = Ke(u)));
      var p = 0;
      if (typeof u < "u") {
        if (u.length !== c.length)
          throw new Error("Weights must have the same length as possibles");
        for (var v = 0, h = u.length; v < h; v++) {
          if (!je(u[v]) || u[v] < 0)
            throw new Error("Weights must be an array of positive numbers");
          p += u[v];
        }
      }
      for (var x = c.length, b = [], N; b.length < f; ) {
        if (typeof u > "u") N = c[Math.floor(n() * x)];
        else
          for (var d = n() * p, y = 0, w = c.length; y < w; y++)
            if (((d -= u[y]), d < 0)) {
              N = c[y];
              break;
            }
        b.push(N);
      }
      return o ? b[0] : l ? l(b) : b;
    }
  });
function su(e, r) {
  var t = [];
  if (((e = e.slice(0)), e.length > 1))
    for (var a = 0, n = e.shift(); a < n; a++) t.push(su(e, r));
  else for (var i = 0, c = e.shift(); i < c; i++) t.push(r());
  return t;
}
var _m = "random",
  mB = ["typed", "config", "?on"],
  pB = P(_m, mB, (e) => {
    var { typed: r, config: t, on: a } = e,
      n = ca(t.randomSeed);
    return (
      a &&
        a("config", function (m, f) {
          m.randomSeed !== f.randomSeed && (n = ca(m.randomSeed));
        }),
      r(_m, {
        "": () => c(0, 1),
        number: (m) => c(0, m),
        "number, number": (m, f) => c(m, f),
        "Array | Matrix": (m) => i(m, 0, 1),
        "Array | Matrix, number": (m, f) => i(m, 0, f),
        "Array | Matrix, number, number": (m, f, u) => i(m, f, u),
      })
    );
    function i(m, f, u) {
      var s = su(m.valueOf(), () => c(f, u));
      return ze(m) ? m.create(s) : s;
    }
    function c(m, f) {
      return m + n() * (f - m);
    }
  }),
  Im = "randomInt",
  vB = ["typed", "config", "?on"],
  hB = P(Im, vB, (e) => {
    var { typed: r, config: t, on: a } = e,
      n = ca(t.randomSeed);
    return (
      a &&
        a("config", function (m, f) {
          m.randomSeed !== f.randomSeed && (n = ca(m.randomSeed));
        }),
      r(Im, {
        "": () => c(0, 1),
        number: (m) => c(0, m),
        "number, number": (m, f) => c(m, f),
        "Array | Matrix": (m) => i(m, 0, 1),
        "Array | Matrix, number": (m, f) => i(m, 0, f),
        "Array | Matrix, number, number": (m, f, u) => i(m, f, u),
      })
    );
    function i(m, f, u) {
      var s = su(m.valueOf(), () => c(f, u));
      return ze(m) ? m.create(s) : s;
    }
    function c(m, f) {
      return Math.floor(m + n() * (f - m));
    }
  }),
  Rm = "stirlingS2",
  dB = [
    "typed",
    "addScalar",
    "subtract",
    "multiplyScalar",
    "divideScalar",
    "pow",
    "factorial",
    "combinations",
    "isNegative",
    "isInteger",
    "number",
    "?bignumber",
    "larger",
  ],
  gB = P(Rm, dB, (e) => {
    var {
        typed: r,
        addScalar: t,
        subtract: a,
        multiplyScalar: n,
        divideScalar: i,
        pow: c,
        factorial: m,
        combinations: f,
        isNegative: u,
        isInteger: s,
        number: o,
        bignumber: l,
        larger: p,
      } = e,
      v = [],
      h = [];
    return r(Rm, {
      "number | BigNumber, number | BigNumber": function (b, N) {
        if (!s(b) || u(b) || !s(N) || u(N))
          throw new TypeError(
            "Non-negative integer value expected in function stirlingS2"
          );
        if (p(N, b))
          throw new TypeError(
            "k must be less than or equal to n in function stirlingS2"
          );
        var d = !(je(b) && je(N)),
          y = d ? h : v,
          w = d ? l : o,
          g = o(b),
          S = o(N);
        if (y[g] && y[g].length > S) return y[g][S];
        for (var A = 0; A <= g; ++A)
          if ((y[A] || (y[A] = [w(A === 0 ? 1 : 0)]), A !== 0))
            for (
              var E = y[A], M = y[A - 1], B = E.length;
              B <= A && B <= S;
              ++B
            )
              B === A ? (E[B] = 1) : (E[B] = t(n(w(B), M[B]), M[B - 1]));
        return y[g][S];
      },
    });
  }),
  Fm = "bellNumbers",
  yB = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"],
  bB = P(Fm, yB, (e) => {
    var {
      typed: r,
      addScalar: t,
      isNegative: a,
      isInteger: n,
      stirlingS2: i,
    } = e;
    return r(Fm, {
      "number | BigNumber": function (m) {
        if (!n(m) || a(m))
          throw new TypeError(
            "Non-negative integer value expected in function bellNumbers"
          );
        for (var f = 0, u = 0; u <= m; u++) f = t(f, i(m, u));
        return f;
      },
    });
  }),
  Pm = "catalan",
  xB = [
    "typed",
    "addScalar",
    "divideScalar",
    "multiplyScalar",
    "combinations",
    "isNegative",
    "isInteger",
  ],
  wB = P(Pm, xB, (e) => {
    var {
      typed: r,
      addScalar: t,
      divideScalar: a,
      multiplyScalar: n,
      combinations: i,
      isNegative: c,
      isInteger: m,
    } = e;
    return r(Pm, {
      "number | BigNumber": function (u) {
        if (!m(u) || c(u))
          throw new TypeError(
            "Non-negative integer value expected in function catalan"
          );
        return a(i(n(u, 2), u), t(u, 1));
      },
    });
  }),
  qm = "composition",
  NB = [
    "typed",
    "addScalar",
    "combinations",
    "isNegative",
    "isPositive",
    "isInteger",
    "larger",
  ],
  MB = P(qm, NB, (e) => {
    var {
      typed: r,
      addScalar: t,
      combinations: a,
      isPositive: n,
      isNegative: i,
      isInteger: c,
      larger: m,
    } = e;
    return r(qm, {
      "number | BigNumber, number | BigNumber": function (u, s) {
        if (!c(u) || !n(u) || !c(s) || !n(s))
          throw new TypeError(
            "Positive integer value expected in function composition"
          );
        if (m(s, u))
          throw new TypeError(
            "k must be less than or equal to n in function composition"
          );
        return a(t(u, -1), t(s, -1));
      },
    });
  }),
  zm = "leafCount",
  AB = ["parse", "typed"],
  SB = P(zm, AB, (e) => {
    var { parse: r, typed: t } = e;
    function a(n) {
      var i = 0;
      return (
        n.forEach((c) => {
          i += a(c);
        }),
        i || 1
      );
    }
    return t(zm, {
      string: function (i) {
        return this(r(i));
      },
      Node: function (i) {
        return a(i);
      },
    });
  });
function Um(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    r &&
      (a = a.filter(function (n) {
        return Object.getOwnPropertyDescriptor(e, n).enumerable;
      })),
      t.push.apply(t, a);
  }
  return t;
}
function Go(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2
      ? Um(Object(t), !0).forEach(function (a) {
          dh(e, a, t[a]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
      : Um(Object(t)).forEach(function (a) {
          Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(t, a));
        });
  }
  return e;
}
var EB = "simplifyUtil",
  CB = ["FunctionNode", "OperatorNode", "SymbolNode"],
  uu = P(EB, CB, (e) => {
    var { FunctionNode: r, OperatorNode: t, SymbolNode: a } = e,
      n = !0,
      i = !1,
      c = "defaultF",
      m = {
        add: { trivial: n, total: n, commutative: n, associative: n },
        unaryPlus: { trivial: n, total: n, commutative: n, associative: n },
        subtract: { trivial: i, total: n, commutative: i, associative: i },
        multiply: { trivial: n, total: n, commutative: n, associative: n },
        divide: { trivial: i, total: n, commutative: i, associative: i },
        paren: { trivial: n, total: n, commutative: n, associative: i },
        defaultF: { trivial: i, total: n, commutative: i, associative: i },
      },
      f = { divide: { total: i }, log: { total: i } },
      u = { subtract: { total: i }, abs: { trivial: n }, log: { total: n } };
    function s(d, y) {
      var w =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : m,
        g = c;
      if (
        (typeof d == "string"
          ? (g = d)
          : Kr(d)
          ? (g = d.fn.toString())
          : Cn(d)
          ? (g = d.name)
          : Wa(d) && (g = "paren"),
        De(w, g))
      ) {
        var S = w[g];
        if (De(S, y)) return S[y];
        if (De(m, g)) return m[g][y];
      }
      if (De(w, c)) {
        var A = w[c];
        return De(A, y) ? A[y] : m[c][y];
      }
      if (De(m, g)) {
        var E = m[g];
        if (De(E, y)) return E[y];
      }
      return m[c][y];
    }
    function o(d) {
      var y =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : m;
      return s(d, "commutative", y);
    }
    function l(d) {
      var y =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : m;
      return s(d, "associative", y);
    }
    function p(d, y) {
      var w = Go({}, d);
      for (var g in y)
        De(d, g) ? (w[g] = Go(Go({}, y[g]), d[g])) : (w[g] = y[g]);
      return w;
    }
    function v(d, y) {
      if (!d.args || d.args.length === 0) return d;
      d.args = h(d, y);
      for (var w = 0; w < d.args.length; w++) v(d.args[w], y);
    }
    function h(d, y) {
      var w,
        g = [],
        S = function A(E) {
          for (var M = 0; M < E.args.length; M++) {
            var B = E.args[M];
            Kr(B) && w === B.op ? A(B) : g.push(B);
          }
        };
      return l(d, y) ? ((w = d.op), S(d), g) : d.args;
    }
    function x(d, y) {
      if (!(!d.args || d.args.length === 0)) {
        for (var w = N(d), g = d.args.length, S = 0; S < g; S++)
          x(d.args[S], y);
        if (g > 2 && l(d, y)) {
          for (var A = d.args.pop(); d.args.length > 0; )
            A = w([d.args.pop(), A]);
          d.args = A.args;
        }
      }
    }
    function b(d, y) {
      if (!(!d.args || d.args.length === 0)) {
        for (var w = N(d), g = d.args.length, S = 0; S < g; S++)
          b(d.args[S], y);
        if (g > 2 && l(d, y)) {
          for (var A = d.args.shift(); d.args.length > 0; )
            A = w([A, d.args.shift()]);
          d.args = A.args;
        }
      }
    }
    function N(d) {
      return Kr(d)
        ? function (y) {
            try {
              return new t(d.op, d.fn, y, d.implicit);
            } catch (w) {
              return console.error(w), [];
            }
          }
        : function (y) {
            return new r(new a(d.name), y);
          };
    }
    return {
      createMakeNodeFunction: N,
      hasProperty: s,
      isCommutative: o,
      isAssociative: l,
      mergeContext: p,
      flatten: v,
      allChildren: h,
      unflattenr: x,
      unflattenl: b,
      defaultContext: m,
      realContext: f,
      positiveContext: u,
    };
  }),
  $B = "simplifyConstant",
  OB = [
    "typed",
    "config",
    "mathWithTransform",
    "matrix",
    "?fraction",
    "?bignumber",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "SymbolNode",
  ],
  Oh = P($B, OB, (e) => {
    var {
        typed: r,
        config: t,
        mathWithTransform: a,
        matrix: n,
        fraction: i,
        bignumber: c,
        AccessorNode: m,
        ArrayNode: f,
        ConstantNode: u,
        FunctionNode: s,
        IndexNode: o,
        ObjectNode: l,
        OperatorNode: p,
        SymbolNode: v,
      } = e,
      {
        isCommutative: h,
        isAssociative: x,
        allChildren: b,
        createMakeNodeFunction: N,
      } = uu({ FunctionNode: s, OperatorNode: p, SymbolNode: v });
    function d(I, T) {
      return S(z(I, T));
    }
    function y(I) {
      return ha(I)
        ? I.valueOf()
        : I instanceof Array
        ? I.map(y)
        : ze(I)
        ? n(y(I.valueOf()))
        : I;
    }
    function w(I, T, D) {
      try {
        return a[I].apply(null, T);
      } catch {
        return (T = T.map(y)), E(a[I].apply(null, T), D);
      }
    }
    var g = r({
      Fraction: B,
      number: function (T) {
        return T < 0 ? M(new u(-T)) : new u(T);
      },
      BigNumber: function (T) {
        return T < 0 ? M(new u(-T)) : new u(T);
      },
      Complex: function (T) {
        throw new Error("Cannot convert Complex number to Node");
      },
      string: function (T) {
        return new u(T);
      },
      Matrix: function (T) {
        return new f(T.valueOf().map((D) => g(D)));
      },
    });
    function S(I) {
      return ir(I) ? I : g(I);
    }
    function A(I, T) {
      var D = T && T.exactFractions !== !1;
      if (D && isFinite(I) && i) {
        var Z = i(I),
          O =
            T && typeof T.fractionsLimit == "number" ? T.fractionsLimit : 1 / 0;
        if (Z.valueOf() === I && Z.n < O && Z.d < O) return Z;
      }
      return I;
    }
    var E = r({
      "string, Object": function (T, D) {
        if (t.number === "BigNumber") return c === void 0 && js(), c(T);
        if (t.number === "Fraction") return i === void 0 && lh(), i(T);
        var Z = parseFloat(T);
        return A(Z, D);
      },
      "Fraction, Object": function (T, D) {
        return T;
      },
      "BigNumber, Object": function (T, D) {
        return T;
      },
      "number, Object": function (T, D) {
        return A(T, D);
      },
      "Complex, Object": function (T, D) {
        return T.im !== 0 ? T : A(T.re, D);
      },
      "Matrix, Object": function (T, D) {
        return n(A(T.valueOf()));
      },
      "Array, Object": function (T, D) {
        return T.map(A);
      },
    });
    function M(I) {
      return new p("-", "unaryMinus", [I]);
    }
    function B(I) {
      var T,
        D = I.s * I.n;
      return (
        D < 0 ? (T = new p("-", "unaryMinus", [new u(-D)])) : (T = new u(D)),
        I.d === 1 ? T : new p("/", "divide", [T, new u(I.d)])
      );
    }
    function C(I, T, D) {
      if (!ga(T)) return new m(S(I), S(T));
      if (ut(I) || ze(I)) {
        for (var Z = Array.from(T.dimensions); Z.length > 0; )
          if (lr(Z[0]) && typeof Z[0].value != "string") {
            var O = E(Z.shift().value, D);
            ut(I)
              ? (I = I.items[O - 1])
              : ((I = I.valueOf()[O - 1]), I instanceof Array && (I = n(I)));
          } else if (
            Z.length > 1 &&
            lr(Z[1]) &&
            typeof Z[1].value != "string"
          ) {
            var H = E(Z[1].value, D),
              Q = [],
              te = ut(I) ? I.items : I.valueOf();
            for (var J of te)
              if (ut(J)) Q.push(J.items[H - 1]);
              else if (ze(I)) Q.push(J[H - 1]);
              else break;
            if (Q.length === te.length)
              ut(I) ? (I = new f(Q)) : (I = n(Q)), Z.splice(1, 1);
            else break;
          } else break;
        return Z.length === T.dimensions.length
          ? new m(S(I), T)
          : Z.length > 0
          ? ((T = new o(Z)), new m(S(I), T))
          : I;
      }
      if (Ji(I) && T.dimensions.length === 1 && lr(T.dimensions[0])) {
        var re = T.dimensions[0].value;
        return re in I.properties ? I.properties[re] : new u();
      }
      return new m(S(I), T);
    }
    function _(I, T, D, Z) {
      return T.reduce(function (O, H) {
        if (!ir(O) && !ir(H)) {
          try {
            return w(I, [O, H], Z);
          } catch {}
          (O = g(O)), (H = g(H));
        } else ir(O) ? ir(H) || (H = g(H)) : (O = g(O));
        return D([O, H]);
      });
    }
    function z(I, T) {
      switch (I.type) {
        case "SymbolNode":
          return I;
        case "ConstantNode":
          switch (typeof I.value) {
            case "number":
              return E(I.value, T);
            case "string":
              return I.value;
            default:
              if (!isNaN(I.value)) return E(I.value, T);
          }
          return I;
        case "FunctionNode":
          if (a[I.name] && a[I.name].rawArgs) return I;
          {
            var D = ["add", "multiply"];
            if (D.indexOf(I.name) === -1) {
              var Z = I.args.map((Ae) => z(Ae, T));
              if (!Z.some(ir))
                try {
                  return w(I.name, Z, T);
                } catch {}
              if (I.name === "size" && Z.length === 1 && ut(Z[0])) {
                for (var O = [], H = Z[0]; ut(H); )
                  O.push(H.items.length), (H = H.items[0]);
                return n(O);
              }
              return new s(I.name, Z.map(S));
            }
          }
        case "OperatorNode": {
          var Q = I.fn.toString(),
            te,
            J,
            re = N(I);
          if (Kr(I) && I.isUnary())
            (te = [z(I.args[0], T)]),
              ir(te[0]) ? (J = re(te)) : (J = w(Q, te, T));
          else if (x(I, T.context))
            if (
              ((te = b(I, T.context)),
              (te = te.map((Ae) => z(Ae, T))),
              h(Q, T.context))
            ) {
              for (var oe = [], ae = [], ce = 0; ce < te.length; ce++)
                ir(te[ce]) ? ae.push(te[ce]) : oe.push(te[ce]);
              oe.length > 1
                ? ((J = _(Q, oe, re, T)), ae.unshift(J), (J = _(Q, ae, re, T)))
                : (J = _(Q, te, re, T));
            } else J = _(Q, te, re, T);
          else (te = I.args.map((Ae) => z(Ae, T))), (J = _(Q, te, re, T));
          return J;
        }
        case "ParenthesisNode":
          return z(I.content, T);
        case "AccessorNode":
          return C(z(I.object, T), z(I.index, T), T);
        case "ArrayNode": {
          var se = I.items.map((Ae) => z(Ae, T));
          return se.some(ir) ? new f(se.map(S)) : n(se);
        }
        case "IndexNode":
          return new o(I.dimensions.map((Ae) => d(Ae, T)));
        case "ObjectNode": {
          var pe = {};
          for (var ne in I.properties) pe[ne] = d(I.properties[ne], T);
          return new l(pe);
        }
        case "AssignmentNode":
        case "BlockNode":
        case "FunctionAssignmentNode":
        case "RangeNode":
        case "ConditionalNode":
        default:
          throw new Error(
            "Unimplemented node type in simplifyConstant: ".concat(I.type)
          );
      }
    }
    return d;
  }),
  TB = "simplify",
  DB = [
    "config",
    "typed",
    "parse",
    "add",
    "subtract",
    "multiply",
    "divide",
    "pow",
    "isZero",
    "equal",
    "resolve",
    "simplifyCore",
    "?fraction",
    "?bignumber",
    "mathWithTransform",
    "matrix",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "ParenthesisNode",
    "SymbolNode",
  ],
  BB = P(TB, DB, (e) => {
    var {
        config: r,
        typed: t,
        parse: a,
        add: n,
        subtract: i,
        multiply: c,
        divide: m,
        pow: f,
        isZero: u,
        equal: s,
        resolve: o,
        simplifyCore: l,
        fraction: p,
        bignumber: v,
        mathWithTransform: h,
        matrix: x,
        AccessorNode: b,
        ArrayNode: N,
        ConstantNode: d,
        FunctionNode: y,
        IndexNode: w,
        ObjectNode: g,
        OperatorNode: S,
        ParenthesisNode: A,
        SymbolNode: E,
      } = e,
      M = Oh({
        typed: t,
        config: r,
        mathWithTransform: h,
        matrix: x,
        fraction: p,
        bignumber: v,
        AccessorNode: b,
        ArrayNode: N,
        ConstantNode: d,
        FunctionNode: y,
        IndexNode: w,
        ObjectNode: g,
        OperatorNode: S,
        SymbolNode: E,
      }),
      {
        hasProperty: B,
        isCommutative: C,
        isAssociative: _,
        mergeContext: z,
        flatten: I,
        unflattenr: T,
        unflattenl: D,
        createMakeNodeFunction: Z,
        defaultContext: O,
        realContext: H,
        positiveContext: Q,
      } = uu({ FunctionNode: y, OperatorNode: S, SymbolNode: E }),
      te = t("simplify", {
        string: function (L) {
          return this(a(L), this.rules, Gt(), {});
        },
        "string, Map | Object": function (L, j) {
          return this(a(L), this.rules, j, {});
        },
        "string, Map | Object, Object": function (L, j, F) {
          return this(a(L), this.rules, j, F);
        },
        "string, Array": function (L, j) {
          return this(a(L), j, Gt(), {});
        },
        "string, Array, Map | Object": function (L, j, F) {
          return this(a(L), j, F, {});
        },
        "string, Array, Map | Object, Object": function (L, j, F, U) {
          return this(a(L), j, F, U);
        },
        "Node, Map | Object": function (L, j) {
          return this(L, this.rules, j, {});
        },
        "Node, Map | Object, Object": function (L, j, F) {
          return this(L, this.rules, j, F);
        },
        Node: function (L) {
          return this(L, this.rules, Gt(), {});
        },
        "Node, Array": function (L, j) {
          return this(L, j, Gt(), {});
        },
        "Node, Array, Map | Object": function (L, j, F) {
          return this(L, j, F, {});
        },
        "Node, Array, Object, Object": function (L, j, F, U) {
          return this(L, j, Zs(F), U);
        },
        "Node, Array, Map, Object": function (L, j, F, U) {
          var ee = U.consoleDebug;
          j = ae(j, U.context);
          var k = o(L, F);
          k = J(k);
          for (
            var me = {}, he = k.toString({ parenthesis: "all" });
            !me[he];

          ) {
            (me[he] = !0), (ce = 0);
            var Me = he;
            ee && console.log("Working on: ", he);
            for (var be = 0; be < j.length; be++) {
              var xe = "";
              if (
                (typeof j[be] == "function"
                  ? ((k = j[be](k, U)), ee && (xe = j[be].name))
                  : (I(k, U.context),
                    (k = ne(k, j[be], U.context)),
                    ee &&
                      (xe = ""
                        .concat(j[be].l.toString(), " -> ")
                        .concat(j[be].r.toString()))),
                ee)
              ) {
                var Te = k.toString({ parenthesis: "all" });
                Te !== Me &&
                  (console.log("Applying", xe, "produced", Te), (Me = Te));
              }
              D(k, U.context);
            }
            he = k.toString({ parenthesis: "all" });
          }
          return k;
        },
      });
    (te.defaultContext = O), (te.realContext = H), (te.positiveContext = Q);
    function J(V) {
      return V.transform(function (L, j, F) {
        return Wa(L) ? J(L.content) : L;
      });
    }
    var re = {
      true: !0,
      false: !0,
      e: !0,
      i: !0,
      Infinity: !0,
      LN2: !0,
      LN10: !0,
      LOG2E: !0,
      LOG10E: !0,
      NaN: !0,
      phi: !0,
      pi: !0,
      SQRT1_2: !0,
      SQRT2: !0,
      tau: !0,
    };
    te.rules = [
      l,
      { l: "log(e)", r: "1" },
      { s: "n-n1 -> n+-n1", assuming: { subtract: { total: !0 } } },
      { s: "n-n -> 0", assuming: { subtract: { total: !1 } } },
      {
        s: "-(c*v) -> v * (-c)",
        assuming: { multiply: { commutative: !0 }, subtract: { total: !0 } },
      },
      {
        s: "-(c*v) -> (-c) * v",
        assuming: { multiply: { commutative: !1 }, subtract: { total: !0 } },
      },
      {
        s: "-(v*c) -> v * (-c)",
        assuming: { multiply: { commutative: !1 }, subtract: { total: !0 } },
      },
      { l: "-(n1/n2)", r: "-n1/n2" },
      { l: "-v", r: "v * (-1)" },
      { l: "(n1 + n2)*(-1)", r: "n1*(-1) + n2*(-1)", repeat: !0 },
      { l: "n/n1^n2", r: "n*n1^-n2" },
      { l: "n/n1", r: "n*n1^-1" },
      {
        s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
        assuming: { multiply: { commutative: !0 } },
      },
      {
        s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
        assuming: { divide: { total: !0 } },
      },
      { l: " v   * ( v   * n1 + n2)", r: "v^2       * n1 +  v   * n2" },
      {
        s: " v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2",
        assuming: { divide: { total: !0 } },
      },
      {
        s: "v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2",
        assuming: { divide: { total: !0 } },
      },
      {
        s: "v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2",
        assuming: { divide: { total: !0 } },
      },
      { l: "n*n", r: "n^2" },
      { s: "n * n^n1 -> n^(n1+1)", assuming: { divide: { total: !0 } } },
      { s: "n^n1 * n^n2 -> n^(n1+n2)", assuming: { divide: { total: !0 } } },
      M,
      { s: "n+n -> 2*n", assuming: { add: { total: !0 } } },
      { l: "n+-n", r: "0" },
      { l: "v*n + v", r: "v*(n+1)" },
      { l: "n3*n1 + n3*n2", r: "n3*(n1+n2)" },
      { l: "n3^(-n4)*n1 +   n3  * n2", r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)" },
      { l: "n3^(-n4)*n1 + n3^n5 * n2", r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)" },
      { s: "n*v + v -> (n+1)*v", assuming: { multiply: { commutative: !1 } } },
      {
        s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
        assuming: { multiply: { commutative: !1 } },
      },
      { l: "n*c + c", r: "(n+1)*c" },
      { s: "c*n + c -> c*(n+1)", assuming: { multiply: { commutative: !1 } } },
      M,
      { s: "(-n)*n1 -> -(n*n1)", assuming: { subtract: { total: !0 } } },
      {
        s: "n1*(-n) -> -(n1*n)",
        assuming: { subtract: { total: !0 }, multiply: { commutative: !1 } },
      },
      {
        s: "c+v -> v+c",
        assuming: { add: { commutative: !0 } },
        imposeContext: { add: { commutative: !1 } },
      },
      {
        s: "v*c -> c*v",
        assuming: { multiply: { commutative: !0 } },
        imposeContext: { multiply: { commutative: !1 } },
      },
      { l: "n+-n1", r: "n-n1" },
      { s: "n*(n1^-1) -> n/n1", assuming: { multiply: { commutative: !0 } } },
      { s: "n*n1^-n2 -> n/n1^n2", assuming: { multiply: { commutative: !0 } } },
      { s: "n^-1 -> 1/n", assuming: { multiply: { commutative: !0 } } },
      { l: "n^1", r: "n" },
      {
        s: "n*(n1/n2) -> (n*n1)/n2",
        assuming: { multiply: { associative: !0 } },
      },
      {
        s: "n-(n1+n2) -> n-n1-n2",
        assuming: { addition: { associative: !0, commutative: !0 } },
      },
      { l: "1*n", r: "n", imposeContext: { multiply: { commutative: !0 } } },
      {
        s: "n1/(n2/n3) -> (n1*n3)/n2",
        assuming: { multiply: { associative: !0 } },
      },
      { l: "n1/(-n2)", r: "-n1/n2" },
    ];
    function oe(V, L) {
      var j = {};
      if (V.s) {
        var F = V.s.split("->");
        if (F.length === 2) (j.l = F[0]), (j.r = F[1]);
        else throw SyntaxError("Could not parse rule: " + V.s);
      } else (j.l = V.l), (j.r = V.r);
      (j.l = J(a(j.l))), (j.r = J(a(j.r)));
      for (var U of ["imposeContext", "repeat", "assuming"])
        U in V && (j[U] = V[U]);
      if ((V.evaluate && (j.evaluate = a(V.evaluate)), _(j.l, L))) {
        var ee = Z(j.l),
          k = se();
        (j.expanded = {}),
          (j.expanded.l = ee([j.l.clone(), k])),
          I(j.expanded.l, L),
          T(j.expanded.l, L),
          (j.expanded.r = ee([j.r, k]));
      }
      return j;
    }
    function ae(V, L) {
      for (var j = [], F = 0; F < V.length; F++) {
        var U = V[F],
          ee = void 0,
          k = typeof U;
        switch (k) {
          case "string":
            U = { s: U };
          case "object":
            ee = oe(U, L);
            break;
          case "function":
            ee = U;
            break;
          default:
            throw TypeError("Unsupported type of rule: " + k);
        }
        j.push(ee);
      }
      return j;
    }
    var ce = 0;
    function se() {
      return new E("_p" + ce++);
    }
    function pe(V, L, j) {
      var F = V;
      if (V)
        for (var U = 0; U < V.length; ++U) {
          var ee = ne(V[U], L, j);
          ee !== V[U] && (F === V && (F = V.slice()), (F[U] = ee));
        }
      return F;
    }
    function ne(V, L, j) {
      if (L.assuming) {
        for (var F in L.assuming)
          for (var U in L.assuming[F])
            if (B(F, U, j) !== L.assuming[F][U]) return V;
      }
      var ee = z(L.imposeContext, j),
        k = V;
      if (k instanceof S || k instanceof y) {
        var me = pe(k.args, L, j);
        me !== k.args && ((k = k.clone()), (k.args = me));
      } else if (k instanceof A) {
        if (k.content) {
          var he = ne(k.content, L, j);
          he !== k.content && (k = new A(he));
        }
      } else if (k instanceof N) {
        var Me = pe(k.items, L, j);
        Me !== k.items && (k = new N(Me));
      } else if (k instanceof b) {
        var be = k.object;
        k.object && (be = ne(k.object, L, j));
        var xe = k.index;
        k.index && (xe = ne(k.index, L, j)),
          (be !== k.object || xe !== k.index) && (k = new b(be, xe));
      } else if (k instanceof w) {
        var Te = pe(k.dimensions, L, j);
        Te !== k.dimensions && (k = new w(Te));
      } else if (k instanceof g) {
        var or = !1,
          br = {};
        for (var mr in k.properties)
          (br[mr] = ne(k.properties[mr], L, j)),
            br[mr] !== k.properties[mr] && (or = !0);
        or && (k = new g(br));
      }
      var Jr = L.r,
        Wr = q(L.l, k, ee)[0];
      if (
        (!Wr &&
          L.expanded &&
          ((Jr = L.expanded.r), (Wr = q(L.expanded.l, k, ee)[0])),
        Wr)
      ) {
        var ot = k.implicit;
        (k = Jr.clone()),
          ot && "implicit" in Jr && (k.implicit = !0),
          (k = k.transform(function (rr) {
            return rr.isSymbolNode && De(Wr.placeholders, rr.name)
              ? Wr.placeholders[rr.name].clone()
              : rr;
          }));
      }
      return L.repeat && k !== V && (k = ne(k, L, j)), k;
    }
    function Ae(V, L) {
      var j = [],
        F,
        U,
        ee = Z(V);
      if (C(V, L))
        for (var k = 0; k < V.args.length; k++)
          (U = V.args.slice(0)),
            U.splice(k, 1),
            (F = U.length === 1 ? U[0] : ee(U)),
            j.push(ee([V.args[k], F]));
      else
        for (var me = 1; me < V.args.length; me++) {
          var he = V.args[0];
          me > 1 && (he = ee(V.args.slice(0, me))),
            (U = V.args.slice(me)),
            (F = U.length === 1 ? U[0] : ee(U)),
            j.push(ee([he, F]));
        }
      return j;
    }
    function Ce(V, L) {
      var j = { placeholders: {} };
      if (!V.placeholders && !L.placeholders) return j;
      if (V.placeholders) {
        if (!L.placeholders) return V;
      } else return L;
      for (var F in V.placeholders)
        if (
          De(V.placeholders, F) &&
          ((j.placeholders[F] = V.placeholders[F]),
          De(L.placeholders, F) && !Y(V.placeholders[F], L.placeholders[F]))
        )
          return null;
      for (var U in L.placeholders)
        De(L.placeholders, U) && (j.placeholders[U] = L.placeholders[U]);
      return j;
    }
    function ge(V, L) {
      var j = [];
      if (V.length === 0 || L.length === 0) return j;
      for (var F, U = 0; U < V.length; U++)
        for (var ee = 0; ee < L.length; ee++)
          (F = Ce(V[U], L[ee])), F && j.push(F);
      return j;
    }
    function Se(V) {
      if (V.length === 0) return V;
      for (var L = V.reduce(ge), j = [], F = {}, U = 0; U < L.length; U++) {
        var ee = JSON.stringify(L[U]);
        F[ee] || ((F[ee] = !0), j.push(L[U]));
      }
      return j;
    }
    function q(V, L, j, F) {
      var U = [{ placeholders: {} }];
      if (
        (V instanceof S && L instanceof S) ||
        (V instanceof y && L instanceof y)
      ) {
        if (V instanceof S) {
          if (V.op !== L.op || V.fn !== L.fn) return [];
        } else if (V instanceof y && V.name !== L.name) return [];
        if (
          (L.args.length === 1 && V.args.length === 1) ||
          (!_(L, j) && L.args.length === V.args.length) ||
          F
        ) {
          for (var ee = [], k = 0; k < V.args.length; k++) {
            var me = q(V.args[k], L.args[k], j);
            if (me.length === 0) break;
            ee.push(me);
          }
          if (ee.length !== V.args.length) {
            if (!C(L, j) || V.args.length === 1) return [];
            if (V.args.length > 2)
              throw new Error(
                "permuting >2 commutative non-associative rule arguments not yet implemented"
              );
            var he = q(V.args[0], L.args[1], j);
            if (he.length === 0) return [];
            var Me = q(V.args[1], L.args[0], j);
            if (Me.length === 0) return [];
            ee = [he, Me];
          }
          U = Se(ee);
        } else if (L.args.length >= 2 && V.args.length === 2) {
          for (var be = Ae(L, j), xe = [], Te = 0; Te < be.length; Te++) {
            var or = q(V, be[Te], j, !0);
            xe = xe.concat(or);
          }
          return xe;
        } else {
          if (V.args.length > 2)
            throw Error(
              "Unexpected non-binary associative function: " + V.toString()
            );
          return [];
        }
      } else if (V instanceof E) {
        if (V.name.length === 0)
          throw new Error("Symbol in rule has 0 length...!?");
        if (re[V.name]) {
          if (V.name !== L.name) return [];
        } else if (V.name[0] === "n" || V.name.substring(0, 2) === "_p")
          U[0].placeholders[V.name] = L;
        else if (V.name[0] === "v")
          if (!lr(L)) U[0].placeholders[V.name] = L;
          else return [];
        else if (V.name[0] === "c")
          if (L instanceof d) U[0].placeholders[V.name] = L;
          else return [];
        else throw new Error("Invalid symbol in rule: " + V.name);
      } else if (V instanceof d) {
        if (!s(V.value, L.value)) return [];
      } else return [];
      return U;
    }
    function Y(V, L) {
      if (V instanceof d && L instanceof d) {
        if (!s(V.value, L.value)) return !1;
      } else if (V instanceof E && L instanceof E) {
        if (V.name !== L.name) return !1;
      } else if (
        (V instanceof S && L instanceof S) ||
        (V instanceof y && L instanceof y)
      ) {
        if (V instanceof S) {
          if (V.op !== L.op || V.fn !== L.fn) return !1;
        } else if (V instanceof y && V.name !== L.name) return !1;
        if (V.args.length !== L.args.length) return !1;
        for (var j = 0; j < V.args.length; j++)
          if (!Y(V.args[j], L.args[j])) return !1;
      } else return !1;
      return !0;
    }
    return te;
  }),
  _B = "simplifyCore",
  IB = [
    "equal",
    "isZero",
    "add",
    "subtract",
    "multiply",
    "divide",
    "pow",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "ParenthesisNode",
    "SymbolNode",
  ],
  RB = P(_B, IB, (e) => {
    var {
        equal: r,
        isZero: t,
        add: a,
        subtract: n,
        multiply: i,
        divide: c,
        pow: m,
        AccessorNode: f,
        ArrayNode: u,
        ConstantNode: s,
        FunctionNode: o,
        IndexNode: l,
        ObjectNode: p,
        OperatorNode: v,
        ParenthesisNode: h,
        SymbolNode: x,
      } = e,
      b = new s(0),
      N = new s(1),
      { hasProperty: d, isCommutative: y } = uu({
        FunctionNode: o,
        OperatorNode: v,
        SymbolNode: x,
      });
    function w(g, S) {
      var A = S ? S.context : void 0;
      if (d(g, "trivial", A)) {
        if (Cn(g) && g.args.length === 1) return w(g.args[0], S);
        var E = !1,
          M = 0;
        if (
          (g.forEach((O) => {
            ++M, M === 1 && (E = w(O, S));
          }),
          M === 1)
        )
          return E;
      }
      if (Kr(g) && g.isUnary()) {
        var B = w(g.args[0], S);
        if (g.op === "-") {
          if (Kr(B)) {
            if (B.isUnary() && B.op === "-") return B.args[0];
            if (B.isBinary() && B.fn === "subtract")
              return new v("-", "subtract", [B.args[1], B.args[0]]);
          }
          return new v(g.op, g.fn, [B]);
        }
      } else if (Kr(g) && g.isBinary()) {
        var C = w(g.args[0], S),
          _ = w(g.args[1], S);
        if (g.op === "+") {
          if (lr(C)) {
            if (t(C.value)) return _;
            if (lr(_)) return new s(a(C.value, _.value));
          }
          return lr(_) && t(_.value)
            ? C
            : Kr(_) && _.isUnary() && _.op === "-"
            ? new v("-", "subtract", [C, _.args[0]])
            : new v(g.op, g.fn, _ ? [C, _] : [C]);
        } else if (g.op === "-") {
          if (lr(C) && _) {
            if (lr(_)) return new s(n(C.value, _.value));
            if (t(C.value)) return new v("-", "unaryMinus", [_]);
          }
          if (g.fn === "subtract")
            return lr(_) && t(_.value)
              ? C
              : Kr(_) && _.isUnary() && _.op === "-"
              ? w(new v("+", "add", [C, _.args[0]]), S)
              : new v(g.op, g.fn, [C, _]);
        } else if (g.op === "*") {
          if (lr(C)) {
            if (t(C.value)) return b;
            if (r(C.value, 1)) return _;
            if (lr(_)) return new s(i(C.value, _.value));
          }
          if (lr(_)) {
            if (t(_.value)) return b;
            if (r(_.value, 1)) return C;
            if (Kr(C) && C.isBinary() && C.op === g.op && y(g, A)) {
              var z = C.args[0];
              if (lr(z)) {
                var I = new s(i(z.value, _.value));
                return new v(g.op, g.fn, [I, C.args[1]], g.implicit);
              }
            }
            return y(g, A)
              ? new v(g.op, g.fn, [_, C], g.implicit)
              : new v(g.op, g.fn, [C, _], g.implicit);
          }
          return new v(g.op, g.fn, [C, _], g.implicit);
        } else if (g.op === "/") {
          if (lr(C)) {
            if (t(C.value)) return b;
            if (lr(_) && (r(_.value, 1) || r(_.value, 2) || r(_.value, 4)))
              return new s(c(C.value, _.value));
          }
          return new v(g.op, g.fn, [C, _]);
        } else if (g.op === "^" && lr(_)) {
          if (t(_.value)) return N;
          if (r(_.value, 1)) return C;
          if (lr(C)) return new s(m(C.value, _.value));
          if (Kr(C) && C.isBinary() && C.op === "^") {
            var T = C.args[1];
            if (lr(T))
              return new v(g.op, g.fn, [C.args[0], new s(i(T.value, _.value))]);
          }
        }
        return new v(g.op, g.fn, [C, _]);
      } else {
        if (Cn(g))
          return new o(
            w(g.fn),
            g.args.map((O) => w(O, S))
          );
        if (ut(g)) return new u(g.items.map((O) => w(O, S)));
        if (En(g)) return new f(w(g.object, S), w(g.index, S));
        if (ga(g)) return new l(g.dimensions.map((O) => w(O, S)));
        if (Ji(g)) {
          var D = {};
          for (var Z in g.properties) D[Z] = w(g.properties[Z], S);
          return new p(D);
        }
      }
      return g;
    }
    return w;
  }),
  FB = "resolve",
  PB = [
    "parse",
    "ConstantNode",
    "FunctionNode",
    "OperatorNode",
    "ParenthesisNode",
  ],
  qB = P(FB, PB, (e) => {
    var {
      parse: r,
      ConstantNode: t,
      FunctionNode: a,
      OperatorNode: n,
      ParenthesisNode: i,
    } = e;
    function c(m, f) {
      var u =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : new Set();
      if (!f) return m;
      if ((Qi(f) || (f = Zs(f)), qr(m))) {
        if (u.has(m.name)) {
          var s = Array.from(u).join(", ");
          throw new ReferenceError(
            "recursive loop of variable definitions among {".concat(s, "}")
          );
        }
        var o = f.get(m.name);
        if (ir(o)) {
          var l = new Set(u);
          return l.add(m.name), c(o, f, l);
        } else
          return typeof o == "number"
            ? r(String(o))
            : o !== void 0
            ? new t(o)
            : m;
      } else if (Kr(m)) {
        var p = m.args.map(function (h) {
          return c(h, f, u);
        });
        return new n(m.op, m.fn, p, m.implicit);
      } else {
        if (Wa(m)) return new i(c(m.content, f, u));
        if (Cn(m)) {
          var v = m.args.map(function (h) {
            return c(h, f, u);
          });
          return new a(m.name, v);
        }
      }
      return m.map((h) => c(h, f, u));
    }
    return c;
  }),
  Lm = "symbolicEqual",
  zB = ["parse", "simplify", "typed", "OperatorNode"],
  UB = P(Lm, zB, (e) => {
    var { parse: r, simplify: t, typed: a, OperatorNode: n } = e;
    return a(Lm, {
      "string, string": function (c, m) {
        return this(r(c), r(m), {});
      },
      "string, string, Object": function (c, m, f) {
        return this(r(c), r(m), f);
      },
      "Node, string": function (c, m) {
        return this(c, r(m), {});
      },
      "Node, string, Object": function (c, m, f) {
        return this(c, r(m), f);
      },
      "string, Node": function (c, m) {
        return this(r(c), m, {});
      },
      "string, Node, Object": function (c, m, f) {
        return this(r(c), m, f);
      },
      "Node, Node": function (c, m) {
        return this(c, m, {});
      },
      "Node, Node, Object": function (c, m, f) {
        var u = new n("-", "subtract", [c, m]),
          s = t(u, {}, f);
        return lr(s) && !s.value;
      },
    });
  }),
  LB = "derivative",
  kB = [
    "typed",
    "config",
    "parse",
    "simplify",
    "equal",
    "isZero",
    "numeric",
    "ConstantNode",
    "FunctionNode",
    "OperatorNode",
    "ParenthesisNode",
    "SymbolNode",
  ],
  VB = P(LB, kB, (e) => {
    var {
        typed: r,
        config: t,
        parse: a,
        simplify: n,
        equal: i,
        isZero: c,
        numeric: m,
        ConstantNode: f,
        FunctionNode: u,
        OperatorNode: s,
        ParenthesisNode: o,
        SymbolNode: l,
      } = e,
      p = r("derivative", {
        "Node, SymbolNode, Object": function (y, w, g) {
          var S = {};
          h(S, y, w.name);
          var A = x(y, S);
          return g.simplify ? n(A) : A;
        },
        "Node, SymbolNode": function (y, w) {
          return this(y, w, { simplify: !0 });
        },
        "string, SymbolNode": function (y, w) {
          return this(a(y), w);
        },
        "string, SymbolNode, Object": function (y, w, g) {
          return this(a(y), w, g);
        },
        "string, string": function (y, w) {
          return this(a(y), a(w));
        },
        "string, string, Object": function (y, w, g) {
          return this(a(y), a(w), g);
        },
        "Node, string": function (y, w) {
          return this(y, a(w));
        },
        "Node, string, Object": function (y, w, g) {
          return this(y, a(w), g);
        },
      });
    (p._simplify = !0),
      (p.toTex = function (d) {
        return v.apply(null, d.args);
      });
    var v = r("_derivTex", {
        "Node, SymbolNode": function (y, w) {
          return lr(y) && vr(y.value) === "string"
            ? v(a(y.value).toString(), w.toString(), 1)
            : v(y.toTex(), w.toString(), 1);
        },
        "Node, ConstantNode": function (y, w) {
          if (vr(w.value) === "string") return v(y, a(w.value));
          throw new Error(
            "The second parameter to 'derivative' is a non-string constant"
          );
        },
        "Node, SymbolNode, ConstantNode": function (y, w, g) {
          return v(y.toString(), w.name, g.value);
        },
        "string, string, number": function (y, w, g) {
          var S;
          return (
            g === 1
              ? (S = "{d\\over d" + w + "}")
              : (S = "{d^{" + g + "}\\over d" + w + "^{" + g + "}}"),
            S + "\\left[".concat(y, "\\right]")
          );
        },
      }),
      h = r("constTag", {
        "Object, ConstantNode, string": function (y, w) {
          return (y[w] = !0), !0;
        },
        "Object, SymbolNode, string": function (y, w, g) {
          return w.name !== g ? ((y[w] = !0), !0) : !1;
        },
        "Object, ParenthesisNode, string": function (y, w, g) {
          return h(y, w.content, g);
        },
        "Object, FunctionAssignmentNode, string": function (y, w, g) {
          return w.params.indexOf(g) === -1
            ? ((y[w] = !0), !0)
            : h(y, w.expr, g);
        },
        "Object, FunctionNode | OperatorNode, string": function (y, w, g) {
          if (w.args.length > 0) {
            for (var S = h(y, w.args[0], g), A = 1; A < w.args.length; ++A)
              S = h(y, w.args[A], g) && S;
            if (S) return (y[w] = !0), !0;
          }
          return !1;
        },
      }),
      x = r("_derivative", {
        "ConstantNode, Object": function (y) {
          return N(0);
        },
        "SymbolNode, Object": function (y, w) {
          return w[y] !== void 0 ? N(0) : N(1);
        },
        "ParenthesisNode, Object": function (y, w) {
          return new o(x(y.content, w));
        },
        "FunctionAssignmentNode, Object": function (y, w) {
          return w[y] !== void 0 ? N(0) : x(y.expr, w);
        },
        "FunctionNode, Object": function (y, w) {
          if ((y.args.length !== 1 && b(y), w[y] !== void 0)) return N(0);
          var g = y.args[0],
            S,
            A = !1,
            E = !1,
            M;
          switch (y.name) {
            case "cbrt":
              (A = !0),
                (M = new s("*", "multiply", [
                  N(3),
                  new s("^", "pow", [g, new s("/", "divide", [N(2), N(3)])]),
                ]));
              break;
            case "sqrt":
            case "nthRoot":
              if (y.args.length === 1)
                (A = !0),
                  (M = new s("*", "multiply", [N(2), new u("sqrt", [g])]));
              else if (y.args.length === 2)
                return (
                  (S = new s("/", "divide", [N(1), y.args[1]])),
                  (w[S] = w[y.args[1]]),
                  x(new s("^", "pow", [g, S]), w)
                );
              break;
            case "log10":
              S = N(10);
            case "log":
              if (!S && y.args.length === 1) (M = g.clone()), (A = !0);
              else if (
                (y.args.length === 1 && S) ||
                (y.args.length === 2 && w[y.args[1]] !== void 0)
              )
                (M = new s("*", "multiply", [
                  g.clone(),
                  new u("log", [S || y.args[1]]),
                ])),
                  (A = !0);
              else if (y.args.length === 2)
                return x(
                  new s("/", "divide", [
                    new u("log", [g]),
                    new u("log", [y.args[1]]),
                  ]),
                  w
                );
              break;
            case "pow":
              return (
                (w[S] = w[y.args[1]]), x(new s("^", "pow", [g, y.args[1]]), w)
              );
            case "exp":
              M = new u("exp", [g.clone()]);
              break;
            case "sin":
              M = new u("cos", [g.clone()]);
              break;
            case "cos":
              M = new s("-", "unaryMinus", [new u("sin", [g.clone()])]);
              break;
            case "tan":
              M = new s("^", "pow", [new u("sec", [g.clone()]), N(2)]);
              break;
            case "sec":
              M = new s("*", "multiply", [y, new u("tan", [g.clone()])]);
              break;
            case "csc":
              (E = !0),
                (M = new s("*", "multiply", [y, new u("cot", [g.clone()])]));
              break;
            case "cot":
              (E = !0),
                (M = new s("^", "pow", [new u("csc", [g.clone()]), N(2)]));
              break;
            case "asin":
              (A = !0),
                (M = new u("sqrt", [
                  new s("-", "subtract", [
                    N(1),
                    new s("^", "pow", [g.clone(), N(2)]),
                  ]),
                ]));
              break;
            case "acos":
              (A = !0),
                (E = !0),
                (M = new u("sqrt", [
                  new s("-", "subtract", [
                    N(1),
                    new s("^", "pow", [g.clone(), N(2)]),
                  ]),
                ]));
              break;
            case "atan":
              (A = !0),
                (M = new s("+", "add", [
                  new s("^", "pow", [g.clone(), N(2)]),
                  N(1),
                ]));
              break;
            case "asec":
              (A = !0),
                (M = new s("*", "multiply", [
                  new u("abs", [g.clone()]),
                  new u("sqrt", [
                    new s("-", "subtract", [
                      new s("^", "pow", [g.clone(), N(2)]),
                      N(1),
                    ]),
                  ]),
                ]));
              break;
            case "acsc":
              (A = !0),
                (E = !0),
                (M = new s("*", "multiply", [
                  new u("abs", [g.clone()]),
                  new u("sqrt", [
                    new s("-", "subtract", [
                      new s("^", "pow", [g.clone(), N(2)]),
                      N(1),
                    ]),
                  ]),
                ]));
              break;
            case "acot":
              (A = !0),
                (E = !0),
                (M = new s("+", "add", [
                  new s("^", "pow", [g.clone(), N(2)]),
                  N(1),
                ]));
              break;
            case "sinh":
              M = new u("cosh", [g.clone()]);
              break;
            case "cosh":
              M = new u("sinh", [g.clone()]);
              break;
            case "tanh":
              M = new s("^", "pow", [new u("sech", [g.clone()]), N(2)]);
              break;
            case "sech":
              (E = !0),
                (M = new s("*", "multiply", [y, new u("tanh", [g.clone()])]));
              break;
            case "csch":
              (E = !0),
                (M = new s("*", "multiply", [y, new u("coth", [g.clone()])]));
              break;
            case "coth":
              (E = !0),
                (M = new s("^", "pow", [new u("csch", [g.clone()]), N(2)]));
              break;
            case "asinh":
              (A = !0),
                (M = new u("sqrt", [
                  new s("+", "add", [
                    new s("^", "pow", [g.clone(), N(2)]),
                    N(1),
                  ]),
                ]));
              break;
            case "acosh":
              (A = !0),
                (M = new u("sqrt", [
                  new s("-", "subtract", [
                    new s("^", "pow", [g.clone(), N(2)]),
                    N(1),
                  ]),
                ]));
              break;
            case "atanh":
              (A = !0),
                (M = new s("-", "subtract", [
                  N(1),
                  new s("^", "pow", [g.clone(), N(2)]),
                ]));
              break;
            case "asech":
              (A = !0),
                (E = !0),
                (M = new s("*", "multiply", [
                  g.clone(),
                  new u("sqrt", [
                    new s("-", "subtract", [
                      N(1),
                      new s("^", "pow", [g.clone(), N(2)]),
                    ]),
                  ]),
                ]));
              break;
            case "acsch":
              (A = !0),
                (E = !0),
                (M = new s("*", "multiply", [
                  new u("abs", [g.clone()]),
                  new u("sqrt", [
                    new s("+", "add", [
                      new s("^", "pow", [g.clone(), N(2)]),
                      N(1),
                    ]),
                  ]),
                ]));
              break;
            case "acoth":
              (A = !0),
                (E = !0),
                (M = new s("-", "subtract", [
                  N(1),
                  new s("^", "pow", [g.clone(), N(2)]),
                ]));
              break;
            case "abs":
              M = new s("/", "divide", [
                new u(new l("abs"), [g.clone()]),
                g.clone(),
              ]);
              break;
            case "gamma":
            default:
              throw new Error(
                'Function "' +
                  y.name +
                  '" is not supported by derivative, or a wrong number of arguments is passed'
              );
          }
          var B, C;
          A ? ((B = "/"), (C = "divide")) : ((B = "*"), (C = "multiply"));
          var _ = x(g, w);
          return E && (_ = new s("-", "unaryMinus", [_])), new s(B, C, [_, M]);
        },
        "OperatorNode, Object": function (y, w) {
          if (w[y] !== void 0) return N(0);
          if (y.op === "+")
            return new s(
              y.op,
              y.fn,
              y.args.map(function (I) {
                return x(I, w);
              })
            );
          if (y.op === "-") {
            if (y.isUnary()) return new s(y.op, y.fn, [x(y.args[0], w)]);
            if (y.isBinary())
              return new s(y.op, y.fn, [x(y.args[0], w), x(y.args[1], w)]);
          }
          if (y.op === "*") {
            var g = y.args.filter(function (I) {
              return w[I] !== void 0;
            });
            if (g.length > 0) {
              var S = y.args.filter(function (I) {
                  return w[I] === void 0;
                }),
                A = S.length === 1 ? S[0] : new s("*", "multiply", S),
                E = g.concat(x(A, w));
              return new s("*", "multiply", E);
            }
            return new s(
              "+",
              "add",
              y.args.map(function (I) {
                return new s(
                  "*",
                  "multiply",
                  y.args.map(function (T) {
                    return T === I ? x(T, w) : T.clone();
                  })
                );
              })
            );
          }
          if (y.op === "/" && y.isBinary()) {
            var M = y.args[0],
              B = y.args[1];
            return w[B] !== void 0
              ? new s("/", "divide", [x(M, w), B])
              : w[M] !== void 0
              ? new s("*", "multiply", [
                  new s("-", "unaryMinus", [M]),
                  new s("/", "divide", [
                    x(B, w),
                    new s("^", "pow", [B.clone(), N(2)]),
                  ]),
                ])
              : new s("/", "divide", [
                  new s("-", "subtract", [
                    new s("*", "multiply", [x(M, w), B.clone()]),
                    new s("*", "multiply", [M.clone(), x(B, w)]),
                  ]),
                  new s("^", "pow", [B.clone(), N(2)]),
                ]);
          }
          if (y.op === "^" && y.isBinary()) {
            var C = y.args[0],
              _ = y.args[1];
            if (w[C] !== void 0)
              return lr(C) && (c(C.value) || i(C.value, 1))
                ? N(0)
                : new s("*", "multiply", [
                    y,
                    new s("*", "multiply", [
                      new u("log", [C.clone()]),
                      x(_.clone(), w),
                    ]),
                  ]);
            if (w[_] !== void 0) {
              if (lr(_)) {
                if (c(_.value)) return N(0);
                if (i(_.value, 1)) return x(C, w);
              }
              var z = new s("^", "pow", [
                C.clone(),
                new s("-", "subtract", [_, N(1)]),
              ]);
              return new s("*", "multiply", [
                _.clone(),
                new s("*", "multiply", [x(C, w), z]),
              ]);
            }
            return new s("*", "multiply", [
              new s("^", "pow", [C.clone(), _.clone()]),
              new s("+", "add", [
                new s("*", "multiply", [
                  x(C, w),
                  new s("/", "divide", [_.clone(), C.clone()]),
                ]),
                new s("*", "multiply", [x(_, w), new u("log", [C.clone()])]),
              ]),
            ]);
          }
          throw new Error(
            'Operator "' +
              y.op +
              '" is not supported by derivative, or a wrong number of arguments is passed'
          );
        },
      });
    function b(d) {
      if (
        !(
          (d.name === "log" || d.name === "nthRoot" || d.name === "pow") &&
          d.args.length === 2
        )
      ) {
        for (var y = 0; y < d.args.length; ++y) d.args[y] = N(0);
        throw (
          (d.compile().evaluate(),
          new Error("Expected TypeError, but none found"))
        );
      }
    }
    function N(d, y) {
      return new f(m(d, y || t.number));
    }
    return p;
  }),
  km = "rationalize",
  GB = [
    "config",
    "typed",
    "equal",
    "isZero",
    "add",
    "subtract",
    "multiply",
    "divide",
    "pow",
    "parse",
    "simplifyCore",
    "simplify",
    "?bignumber",
    "?fraction",
    "mathWithTransform",
    "matrix",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "SymbolNode",
    "ParenthesisNode",
  ],
  HB = P(km, GB, (e) => {
    var {
        config: r,
        typed: t,
        equal: a,
        isZero: n,
        add: i,
        subtract: c,
        multiply: m,
        divide: f,
        pow: u,
        parse: s,
        simplifyCore: o,
        simplify: l,
        fraction: p,
        bignumber: v,
        mathWithTransform: h,
        matrix: x,
        AccessorNode: b,
        ArrayNode: N,
        ConstantNode: d,
        FunctionNode: y,
        IndexNode: w,
        ObjectNode: g,
        OperatorNode: S,
        SymbolNode: A,
        ParenthesisNode: E,
      } = e,
      M = Oh({
        typed: t,
        config: r,
        mathWithTransform: h,
        matrix: x,
        fraction: p,
        bignumber: v,
        AccessorNode: b,
        ArrayNode: N,
        ConstantNode: d,
        FunctionNode: y,
        IndexNode: w,
        ObjectNode: g,
        OperatorNode: S,
        SymbolNode: A,
      });
    return t(km, {
      string: function (T) {
        return this(s(T), {}, !1);
      },
      "string, boolean": function (T, D) {
        return this(s(T), {}, D);
      },
      "string, Object": function (T, D) {
        return this(s(T), D, !1);
      },
      "string, Object, boolean": function (T, D, Z) {
        return this(s(T), D, Z);
      },
      Node: function (T) {
        return this(T, {}, !1);
      },
      "Node, boolean": function (T, D) {
        return this(T, {}, D);
      },
      "Node, Object": function (T, D) {
        return this(T, D, !1);
      },
      "Node, Object, boolean": function (T, D, Z) {
        var O = C(),
          H = B(T, D, !0, O.firstRules),
          Q = H.variables.length,
          te = { exactFractions: !1 },
          J = { exactFractions: !0 };
        if (((T = H.expression), Q >= 1)) {
          T = _(T);
          var re,
            oe,
            ae = !0,
            ce = !1;
          T = l(T, O.firstRules, {}, te);
          for (
            var se;
            (oe = ae ? O.distrDivRules : O.sucDivRules),
              (T = l(T, oe, {}, J)),
              (ae = !ae),
              (se = T.toString()),
              se !== re;

          )
            (ce = !0), (re = se);
          ce && (T = l(T, O.firstRulesAgain, {}, te)),
            (T = l(T, O.finalRules, {}, te));
        }
        var pe = [],
          ne = {};
        return (
          T.type === "OperatorNode" && T.isBinary() && T.op === "/"
            ? (Q === 1 &&
                ((T.args[0] = z(T.args[0], pe)), (T.args[1] = z(T.args[1]))),
              Z && ((ne.numerator = T.args[0]), (ne.denominator = T.args[1])))
            : (Q === 1 && (T = z(T, pe)),
              Z && ((ne.numerator = T), (ne.denominator = null))),
          Z
            ? ((ne.coefficients = pe),
              (ne.variables = H.variables),
              (ne.expression = T),
              ne)
            : T
        );
      },
    });
    function B(I, T, D, Z) {
      var O = [],
        H = l(I, Z, T, { exactFractions: !1 });
      D = !!D;
      var Q = "+-*" + (D ? "/" : "");
      J(H);
      var te = {};
      return (te.expression = H), (te.variables = O), te;
      function J(re) {
        var oe = re.type;
        if (oe === "FunctionNode")
          throw new Error("There is an unsolved function call");
        if (oe === "OperatorNode")
          if (re.op === "^") {
            if (
              re.args[1].type !== "ConstantNode" ||
              !Be(parseFloat(re.args[1].value))
            )
              throw new Error("There is a non-integer exponent");
            J(re.args[0]);
          } else {
            if (Q.indexOf(re.op) === -1)
              throw new Error(
                "Operator " + re.op + " invalid in polynomial expression"
              );
            for (var ae = 0; ae < re.args.length; ae++) J(re.args[ae]);
          }
        else if (oe === "SymbolNode") {
          var ce = re.name,
            se = O.indexOf(ce);
          se === -1 && O.push(ce);
        } else if (oe === "ParenthesisNode") J(re.content);
        else if (oe !== "ConstantNode")
          throw new Error(
            "type " + oe + " is not allowed in polynomial expression"
          );
      }
    }
    function C() {
      var I = [
          o,
          { l: "n+n", r: "2*n" },
          { l: "n+-n", r: "0" },
          M,
          { l: "n*(n1^-1)", r: "n/n1" },
          { l: "n*n1^-n2", r: "n/n1^n2" },
          { l: "n1^-1", r: "1/n1" },
          { l: "n*(n1/n2)", r: "(n*n1)/n2" },
          { l: "1*n", r: "n" },
        ],
        T = [
          { l: "(-n1)/(-n2)", r: "n1/n2" },
          { l: "(-n1)*(-n2)", r: "n1*n2" },
          { l: "n1--n2", r: "n1+n2" },
          { l: "n1-n2", r: "n1+(-n2)" },
          { l: "(n1+n2)*n3", r: "(n1*n3 + n2*n3)" },
          { l: "n1*(n2+n3)", r: "(n1*n2+n1*n3)" },
          { l: "c1*n + c2*n", r: "(c1+c2)*n" },
          { l: "c1*n + n", r: "(c1+1)*n" },
          { l: "c1*n - c2*n", r: "(c1-c2)*n" },
          { l: "c1*n - n", r: "(c1-1)*n" },
          { l: "v/c", r: "(1/c)*v" },
          { l: "v/-c", r: "-(1/c)*v" },
          { l: "-v*-c", r: "c*v" },
          { l: "-v*c", r: "-c*v" },
          { l: "v*-c", r: "-c*v" },
          { l: "v*c", r: "c*v" },
          { l: "-(-n1*n2)", r: "(n1*n2)" },
          { l: "-(n1*n2)", r: "(-n1*n2)" },
          { l: "-(-n1+n2)", r: "(n1-n2)" },
          { l: "-(n1+n2)", r: "(-n1-n2)" },
          { l: "(n1^n2)^n3", r: "(n1^(n2*n3))" },
          { l: "-(-n1/n2)", r: "(n1/n2)" },
          { l: "-(n1/n2)", r: "(-n1/n2)" },
        ],
        D = [
          { l: "(n1/n2 + n3/n4)", r: "((n1*n4 + n3*n2)/(n2*n4))" },
          { l: "(n1/n2 + n3)", r: "((n1 + n3*n2)/n2)" },
          { l: "(n1 + n2/n3)", r: "((n1*n3 + n2)/n3)" },
        ],
        Z = [
          { l: "(n1/(n2/n3))", r: "((n1*n3)/n2)" },
          { l: "(n1/n2/n3)", r: "(n1/(n2*n3))" },
        ],
        O = {};
      return (
        (O.firstRules = I.concat(T, Z)),
        (O.distrDivRules = D),
        (O.sucDivRules = Z),
        (O.firstRulesAgain = I.concat(T)),
        (O.finalRules = [
          o,
          { l: "n*-n", r: "-n^2" },
          { l: "n*n", r: "n^2" },
          M,
          { l: "n*-n^n1", r: "-n^(n1+1)" },
          { l: "n*n^n1", r: "n^(n1+1)" },
          { l: "n^n1*-n^n2", r: "-n^(n1+n2)" },
          { l: "n^n1*n^n2", r: "n^(n1+n2)" },
          { l: "n^n1*-n", r: "-n^(n1+1)" },
          { l: "n^n1*n", r: "n^(n1+1)" },
          { l: "n^n1/-n", r: "-n^(n1-1)" },
          { l: "n^n1/n", r: "n^(n1-1)" },
          { l: "n/-n^n1", r: "-n^(1-n1)" },
          { l: "n/n^n1", r: "n^(1-n1)" },
          { l: "n^n1/-n^n2", r: "n^(n1-n2)" },
          { l: "n^n1/n^n2", r: "n^(n1-n2)" },
          { l: "n1+(-n2*n3)", r: "n1-n2*n3" },
          { l: "v*(-c)", r: "-c*v" },
          { l: "n1+-n2", r: "n1-n2" },
          { l: "v*c", r: "c*v" },
          { l: "(n1^n2)^n3", r: "(n1^(n2*n3))" },
        ]),
        O
      );
    }
    function _(I, T, D) {
      var Z = I.type,
        O = arguments.length > 1;
      if (Z === "OperatorNode" && I.isBinary()) {
        var H = !1,
          Q;
        if (
          (I.op === "^" &&
            (I.args[0].type === "ParenthesisNode" ||
              I.args[0].type === "OperatorNode") &&
            I.args[1].type === "ConstantNode" &&
            ((Q = parseFloat(I.args[1].value)), (H = Q >= 2 && Be(Q))),
          H)
        ) {
          if (Q > 2) {
            var te = I.args[0],
              J = new S("^", "pow", [I.args[0].cloneDeep(), new d(Q - 1)]);
            I = new S("*", "multiply", [te, J]);
          } else I = new S("*", "multiply", [I.args[0], I.args[0].cloneDeep()]);
          O && (D === "content" ? (T.content = I) : (T.args[D] = I));
        }
      }
      if (Z === "ParenthesisNode") _(I.content, I, "content");
      else if (Z !== "ConstantNode" && Z !== "SymbolNode")
        for (var re = 0; re < I.args.length; re++) _(I.args[re], I, re);
      if (!O) return I;
    }
    function z(I, T) {
      T === void 0 && (T = []), (T[0] = 0);
      var D = {};
      (D.cte = 1), (D.oper = "+"), (D.fire = "");
      var Z = 0,
        O = "";
      ce(I, null, D), (Z = T.length - 1);
      for (var H = !0, Q, te = Z; te >= 0; te--)
        if (T[te] !== 0) {
          var J = new d(H ? T[te] : Math.abs(T[te])),
            re = T[te] < 0 ? "-" : "+";
          if (te > 0) {
            var oe = new A(O);
            if (te > 1) {
              var ae = new d(te);
              oe = new S("^", "pow", [oe, ae]);
            }
            T[te] === -1 && H
              ? (J = new S("-", "unaryMinus", [oe]))
              : Math.abs(T[te]) === 1
              ? (J = oe)
              : (J = new S("*", "multiply", [J, oe]));
          }
          H
            ? (Q = J)
            : re === "+"
            ? (Q = new S("+", "add", [Q, J]))
            : (Q = new S("-", "subtract", [Q, J])),
            (H = !1);
        }
      if (H) return new d(0);
      return Q;
      function ce(se, pe, ne) {
        var Ae = se.type;
        if (Ae === "FunctionNode")
          throw new Error("There is an unsolved function call");
        if (Ae === "OperatorNode") {
          if ("+-*^".indexOf(se.op) === -1)
            throw new Error("Operator " + se.op + " invalid");
          if (pe !== null) {
            if (
              (se.fn === "unaryMinus" || se.fn === "pow") &&
              pe.fn !== "add" &&
              pe.fn !== "subtract" &&
              pe.fn !== "multiply"
            )
              throw new Error("Invalid " + se.op + " placing");
            if (
              (se.fn === "subtract" ||
                se.fn === "add" ||
                se.fn === "multiply") &&
              pe.fn !== "add" &&
              pe.fn !== "subtract"
            )
              throw new Error("Invalid " + se.op + " placing");
            if (
              (se.fn === "subtract" ||
                se.fn === "add" ||
                se.fn === "unaryMinus") &&
              ne.noFil !== 0
            )
              throw new Error("Invalid " + se.op + " placing");
          }
          (se.op === "^" || se.op === "*") && (ne.fire = se.op);
          for (var Ce = 0; Ce < se.args.length; Ce++)
            se.fn === "unaryMinus" && (ne.oper = "-"),
              (se.op === "+" || se.fn === "subtract") &&
                ((ne.fire = ""),
                (ne.cte = 1),
                (ne.oper = Ce === 0 ? "+" : se.op)),
              (ne.noFil = Ce),
              ce(se.args[Ce], se, ne);
        } else if (Ae === "SymbolNode") {
          if (se.name !== O && O !== "")
            throw new Error("There is more than one variable");
          if (((O = se.name), pe === null)) {
            T[1] = 1;
            return;
          }
          if (pe.op === "^" && ne.noFil !== 0)
            throw new Error(
              "In power the variable should be the first parameter"
            );
          if (pe.op === "*" && ne.noFil !== 1)
            throw new Error(
              "In multiply the variable should be the second parameter"
            );
          (ne.fire === "" || ne.fire === "*") &&
            (Z < 1 && (T[1] = 0),
            (T[1] += ne.cte * (ne.oper === "+" ? 1 : -1)),
            (Z = Math.max(1, Z)));
        } else if (Ae === "ConstantNode") {
          var ge = parseFloat(se.value);
          if (pe === null) {
            T[0] = ge;
            return;
          }
          if (pe.op === "^") {
            if (ne.noFil !== 1) throw new Error("Constant cannot be powered");
            if (!Be(ge) || ge <= 0)
              throw new Error("Non-integer exponent is not allowed");
            for (var Se = Z + 1; Se < ge; Se++) T[Se] = 0;
            ge > Z && (T[ge] = 0),
              (T[ge] += ne.cte * (ne.oper === "+" ? 1 : -1)),
              (Z = Math.max(ge, Z));
            return;
          }
          (ne.cte = ge),
            ne.fire === "" && (T[0] += ne.cte * (ne.oper === "+" ? 1 : -1));
        } else throw new Error("Type " + Ae + " is not allowed");
      }
    }
  }),
  ZB = "reviver",
  JB = ["classes"],
  WB = P(ZB, JB, (e) => {
    var { classes: r } = e;
    return function (a, n) {
      var i = r[n && n.mathjs];
      return i && typeof i.fromJSON == "function" ? i.fromJSON(n) : n;
    };
  }),
  XB = "replacer",
  YB = [],
  QB = P(
    XB,
    YB,
    () =>
      function (r, t) {
        return typeof t == "number" && (!isFinite(t) || isNaN(t))
          ? { mathjs: "number", value: String(t) }
          : t;
      }
  ),
  jB = "10.6.4",
  KB = P("true", [], () => !0),
  e_ = P("false", [], () => !1),
  r_ = P("null", [], () => null),
  t_ = at("Infinity", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? new t(1 / 0) : 1 / 0;
  }),
  n_ = at("NaN", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? new t(NaN) : NaN;
  }),
  a_ = at("pi", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? eu(t) : zb;
  }),
  i_ = at("tau", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? JA(t) : Ub;
  }),
  o_ = at("e", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? HA(t) : Lb;
  }),
  s_ = at("phi", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? ZA(t) : kb;
  }),
  u_ = at("LN2", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? new t(2).ln() : Math.LN2;
  }),
  l_ = at("LN10", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? new t(10).ln() : Math.LN10;
  }),
  c_ = at("LOG2E", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? new t(1).div(new t(2).ln()) : Math.LOG2E;
  }),
  f_ = at("LOG10E", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber"
      ? new t(1).div(new t(10).ln())
      : Math.LOG10E;
  }),
  m_ = at("SQRT1_2", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? new t("0.5").sqrt() : Math.SQRT1_2;
  }),
  p_ = at("SQRT2", ["config", "?BigNumber"], (e) => {
    var { config: r, BigNumber: t } = e;
    return r.number === "BigNumber" ? new t(2).sqrt() : Math.SQRT2;
  }),
  v_ = at("i", ["Complex"], (e) => {
    var { Complex: r } = e;
    return r.I;
  }),
  h_ = P("version", [], () => jB);
function at(e, r, t) {
  return P(e, r, t, { recreateOnConfigChange: !0 });
}
var d_ = Ge("speedOfLight", "299792458", "m s^-1"),
  g_ = Ge("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2"),
  y_ = Ge("planckConstant", "6.62607015e-34", "J s"),
  b_ = Ge("reducedPlanckConstant", "1.0545718176461565e-34", "J s"),
  x_ = Ge("magneticConstant", "1.25663706212e-6", "N A^-2"),
  w_ = Ge("electricConstant", "8.8541878128e-12", "F m^-1"),
  N_ = Ge("vacuumImpedance", "376.730313667", "ohm"),
  M_ = Ge("coulomb", "8.987551792261171e9", "N m^2 C^-2"),
  A_ = Ge("elementaryCharge", "1.602176634e-19", "C"),
  S_ = Ge("bohrMagneton", "9.2740100783e-24", "J T^-1"),
  E_ = Ge("conductanceQuantum", "7.748091729863649e-5", "S"),
  C_ = Ge("inverseConductanceQuantum", "12906.403729652257", "ohm"),
  $_ = Ge("magneticFluxQuantum", "2.0678338484619295e-15", "Wb"),
  O_ = Ge("nuclearMagneton", "5.0507837461e-27", "J T^-1"),
  T_ = Ge("klitzing", "25812.807459304513", "ohm"),
  D_ = Ge("bohrRadius", "5.29177210903e-11", "m"),
  B_ = Ge("classicalElectronRadius", "2.8179403262e-15", "m"),
  __ = Ge("electronMass", "9.1093837015e-31", "kg"),
  I_ = Ge("fermiCoupling", "1.1663787e-5", "GeV^-2"),
  R_ = oo("fineStructure", 0.0072973525693),
  F_ = Ge("hartreeEnergy", "4.3597447222071e-18", "J"),
  P_ = Ge("protonMass", "1.67262192369e-27", "kg"),
  q_ = Ge("deuteronMass", "3.3435830926e-27", "kg"),
  z_ = Ge("neutronMass", "1.6749271613e-27", "kg"),
  U_ = Ge("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1"),
  L_ = Ge("rydberg", "10973731.568160", "m^-1"),
  k_ = Ge("thomsonCrossSection", "6.6524587321e-29", "m^2"),
  V_ = oo("weakMixingAngle", 0.2229),
  G_ = oo("efimovFactor", 22.7),
  H_ = Ge("atomicMass", "1.66053906660e-27", "kg"),
  Z_ = Ge("avogadro", "6.02214076e23", "mol^-1"),
  J_ = Ge("boltzmann", "1.380649e-23", "J K^-1"),
  W_ = Ge("faraday", "96485.33212331001", "C mol^-1"),
  X_ = Ge("firstRadiation", "3.7417718521927573e-16", "W m^2"),
  Y_ = Ge("loschmidt", "2.686780111798444e25", "m^-3"),
  Q_ = Ge("gasConstant", "8.31446261815324", "J K^-1 mol^-1"),
  j_ = Ge("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1"),
  K_ = Ge("molarVolume", "0.022413969545014137", "m^3 mol^-1"),
  e5 = oo("sackurTetrode", -1.16487052358),
  r5 = Ge("secondRadiation", "0.014387768775039337", "m K"),
  t5 = Ge("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4"),
  n5 = Ge("wienDisplacement", "2.897771955e-3", "m K"),
  a5 = Ge("molarMass", "0.99999999965e-3", "kg mol^-1"),
  i5 = Ge("molarMassC12", "11.9999999958e-3", "kg mol^-1"),
  o5 = Ge("gravity", "9.80665", "m s^-2"),
  s5 = Ge("planckLength", "1.616255e-35", "m"),
  u5 = Ge("planckMass", "2.176435e-8", "kg"),
  l5 = Ge("planckTime", "5.391245e-44", "s"),
  c5 = Ge("planckCharge", "1.87554603778e-18", "C"),
  f5 = Ge("planckTemperature", "1.416785e+32", "K");
function Ge(e, r, t) {
  var a = ["config", "Unit", "BigNumber"];
  return P(e, a, (n) => {
    var { config: i, Unit: c, BigNumber: m } = n,
      f = i.number === "BigNumber" ? new m(r) : parseFloat(r),
      u = new c(f, t);
    return (u.fixPrefix = !0), u;
  });
}
function oo(e, r) {
  var t = ["config", "BigNumber"];
  return P(e, t, (a) => {
    var { config: n, BigNumber: i } = a;
    return n.number === "BigNumber" ? new i(r) : r;
  });
}
var m5 = "apply",
  p5 = ["typed", "isInteger"],
  v5 = P(
    m5,
    p5,
    (e) => {
      var { typed: r, isInteger: t } = e,
        a = nh({ typed: r, isInteger: t });
      return r("apply", {
        "...any": function (i) {
          var c = i[1];
          je(c) ? (i[1] = c - 1) : Qe(c) && (i[1] = c.minus(1));
          try {
            return a.apply(null, i);
          } catch (m) {
            throw Qr(m);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  h5 = "column",
  d5 = ["typed", "Index", "matrix", "range"],
  g5 = P(
    h5,
    d5,
    (e) => {
      var { typed: r, Index: t, matrix: a, range: n } = e,
        i = sh({ typed: r, Index: t, matrix: a, range: n });
      return r("column", {
        "...any": function (m) {
          var f = m.length - 1,
            u = m[f];
          je(u) && (m[f] = u - 1);
          try {
            return i.apply(null, m);
          } catch (s) {
            throw Qr(s);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  );
function lu(e, r, t) {
  var a = e.filter(function (m) {
    return qr(m) && !(m.name in r) && !t.has(m.name);
  })[0];
  if (!a)
    throw new Error(
      'No undefined variable found in inline expression "' + e + '"'
    );
  var n = a.name,
    i = Ia(t),
    c = e.compile();
  return function (f) {
    return i.set(n, f), c.evaluate(i);
  };
}
var y5 = "filter",
  b5 = ["typed"],
  x5 = P(
    y5,
    b5,
    (e) => {
      var { typed: r } = e;
      function t(n, i, c) {
        var m, f;
        return (
          n[0] && (m = n[0].compile().evaluate(c)),
          n[1] &&
            (qr(n[1]) || Ja(n[1])
              ? (f = n[1].compile().evaluate(c))
              : (f = lu(n[1], i, c))),
          a(m, f)
        );
      }
      t.rawArgs = !0;
      var a = r("filter", {
        "Array, function": Vm,
        "Matrix, function": function (i, c) {
          return i.create(Vm(i.toArray(), c));
        },
        "Array, RegExp": Ti,
        "Matrix, RegExp": function (i, c) {
          return i.create(Ti(i.toArray(), c));
        },
      });
      return t;
    },
    { isTransformFunction: !0 }
  );
function Vm(e, r) {
  var t = xa(r);
  return Gp(e, function (a, n, i) {
    return t === 1 ? r(a) : t === 2 ? r(a, [n + 1]) : r(a, [n + 1], i);
  });
}
var w5 = "forEach",
  N5 = ["typed"],
  M5 = P(
    w5,
    N5,
    (e) => {
      var { typed: r } = e;
      function t(n, i, c) {
        var m, f;
        return (
          n[0] && (m = n[0].compile().evaluate(c)),
          n[1] &&
            (qr(n[1]) || Ja(n[1])
              ? (f = n[1].compile().evaluate(c))
              : (f = lu(n[1], i, c))),
          a(m, f)
        );
      }
      t.rawArgs = !0;
      var a = r("forEach", {
        "Array | Matrix, function": function (i, c) {
          var m = xa(c),
            f = function u(s, o) {
              Array.isArray(s)
                ? Yi(s, function (l, p) {
                    u(l, o.concat(p + 1));
                  })
                : m === 1
                ? c(s)
                : m === 2
                ? c(s, o)
                : c(s, o, i);
            };
          f(i.valueOf(), []);
        },
      });
      return t;
    },
    { isTransformFunction: !0 }
  ),
  A5 = "index",
  S5 = ["Index"],
  E5 = P(
    A5,
    S5,
    (e) => {
      var { Index: r } = e;
      return function () {
        for (var a = [], n = 0, i = arguments.length; n < i; n++) {
          var c = arguments[n];
          if (Zi(c)) c.start--, (c.end -= c.step > 0 ? 0 : 2);
          else if (c && c.isSet === !0)
            c = c.map(function (f) {
              return f - 1;
            });
          else if (sr(c) || ze(c))
            c = c.map(function (f) {
              return f - 1;
            });
          else if (je(c)) c--;
          else if (Qe(c)) c = c.toNumber() - 1;
          else if (typeof c != "string")
            throw new TypeError(
              "Dimension must be an Array, Matrix, number, string, or Range"
            );
          a[n] = c;
        }
        var m = new r();
        return r.apply(m, a), m;
      };
    },
    { isTransformFunction: !0 }
  ),
  C5 = "map",
  $5 = ["typed"],
  O5 = P(
    C5,
    $5,
    (e) => {
      var { typed: r } = e;
      function t(n, i, c) {
        var m, f;
        return (
          n[0] && (m = n[0].compile().evaluate(c)),
          n[1] &&
            (qr(n[1]) || Ja(n[1])
              ? (f = n[1].compile().evaluate(c))
              : (f = lu(n[1], i, c))),
          a(m, f)
        );
      }
      t.rawArgs = !0;
      var a = r("map", {
        "Array, function": function (i, c) {
          return Gm(i, c, i);
        },
        "Matrix, function": function (i, c) {
          return i.create(Gm(i.valueOf(), c, i));
        },
      });
      return t;
    },
    { isTransformFunction: !0 }
  );
function Gm(e, r, t) {
  var a = xa(r);
  function n(i, c) {
    return Array.isArray(i)
      ? Xt(i, function (m, f) {
          return n(m, c.concat(f + 1));
        })
      : a === 1
      ? r(i)
      : a === 2
      ? r(i, c)
      : r(i, c, t);
  }
  return n(e, []);
}
function _n(e) {
  if (e.length === 2 && da(e[0])) {
    e = e.slice();
    var r = e[1];
    je(r) ? (e[1] = r - 1) : Qe(r) && (e[1] = r.minus(1));
  }
  return e;
}
var T5 = "max",
  D5 = ["typed", "config", "numeric", "larger"],
  B5 = P(
    T5,
    D5,
    (e) => {
      var { typed: r, config: t, numeric: a, larger: n } = e,
        i = vh({ typed: r, config: t, numeric: a, larger: n });
      return r("max", {
        "...any": function (m) {
          m = _n(m);
          try {
            return i.apply(null, m);
          } catch (f) {
            throw Qr(f);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  _5 = "mean",
  I5 = ["typed", "add", "divide"],
  R5 = P(
    _5,
    I5,
    (e) => {
      var { typed: r, add: t, divide: a } = e,
        n = Ah({ typed: r, add: t, divide: a });
      return r("mean", {
        "...any": function (c) {
          c = _n(c);
          try {
            return n.apply(null, c);
          } catch (m) {
            throw Qr(m);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  F5 = "min",
  P5 = ["typed", "config", "numeric", "smaller"],
  q5 = P(
    F5,
    P5,
    (e) => {
      var { typed: r, config: t, numeric: a, smaller: n } = e,
        i = hh({ typed: r, config: t, numeric: a, smaller: n });
      return r("min", {
        "...any": function (m) {
          m = _n(m);
          try {
            return i.apply(null, m);
          } catch (f) {
            throw Qr(f);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  z5 = "range",
  U5 = [
    "typed",
    "config",
    "?matrix",
    "?bignumber",
    "smaller",
    "smallerEq",
    "larger",
    "largerEq",
  ],
  L5 = P(
    z5,
    U5,
    (e) => {
      var {
          typed: r,
          config: t,
          matrix: a,
          bignumber: n,
          smaller: i,
          smallerEq: c,
          larger: m,
          largerEq: f,
        } = e,
        u = fh({
          typed: r,
          config: t,
          matrix: a,
          bignumber: n,
          smaller: i,
          smallerEq: c,
          larger: m,
          largerEq: f,
        });
      return r("range", {
        "...any": function (o) {
          var l = o.length - 1,
            p = o[l];
          return typeof p != "boolean" && o.push(!0), u.apply(null, o);
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  k5 = "row",
  V5 = ["typed", "Index", "matrix", "range"],
  G5 = P(
    k5,
    V5,
    (e) => {
      var { typed: r, Index: t, matrix: a, range: n } = e,
        i = mh({ typed: r, Index: t, matrix: a, range: n });
      return r("row", {
        "...any": function (m) {
          var f = m.length - 1,
            u = m[f];
          je(u) && (m[f] = u - 1);
          try {
            return i.apply(null, m);
          } catch (s) {
            throw Qr(s);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  H5 = "subset",
  Z5 = ["typed", "matrix"],
  J5 = P(
    H5,
    Z5,
    (e) => {
      var { typed: r, matrix: t } = e,
        a = ph({ typed: r, matrix: t });
      return r("subset", {
        "...any": function (i) {
          try {
            return a.apply(null, i);
          } catch (c) {
            throw Qr(c);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  W5 = "concat",
  X5 = ["typed", "matrix", "isInteger"],
  Y5 = P(
    W5,
    X5,
    (e) => {
      var { typed: r, matrix: t, isInteger: a } = e,
        n = ih({ typed: r, matrix: t, isInteger: a });
      return r("concat", {
        "...any": function (c) {
          var m = c.length - 1,
            f = c[m];
          je(f) ? (c[m] = f - 1) : Qe(f) && (c[m] = f.minus(1));
          try {
            return n.apply(null, c);
          } catch (u) {
            throw Qr(u);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  Hm = "diff",
  Q5 = ["typed", "matrix", "subtract", "number", "bignumber"],
  j5 = P(
    Hm,
    Q5,
    (e) => {
      var { typed: r, matrix: t, subtract: a, number: n, bignumber: i } = e,
        c = uh({ typed: r, matrix: t, subtract: a, number: n, bignumber: i });
      return r(Hm, {
        "...any": function (f) {
          f = _n(f);
          try {
            return c.apply(null, f);
          } catch (u) {
            throw Qr(u);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  K5 = "std",
  eI = ["typed", "sqrt", "variance"],
  rI = P(
    K5,
    eI,
    (e) => {
      var { typed: r, sqrt: t, variance: a } = e,
        n = Eh({ typed: r, sqrt: t, variance: a });
      return r("std", {
        "...any": function (c) {
          c = _n(c);
          try {
            return n.apply(null, c);
          } catch (m) {
            throw Qr(m);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  Zm = "sum",
  tI = ["typed", "config", "add", "numeric"],
  nI = P(
    Zm,
    tI,
    (e) => {
      var { typed: r, config: t, add: a, numeric: n } = e,
        i = Nh({ typed: r, config: t, add: a, numeric: n });
      return r(Zm, {
        "...any": function (m) {
          m = _n(m);
          try {
            return i.apply(null, m);
          } catch (f) {
            throw Qr(f);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  Jm = "cumsum",
  aI = ["typed", "add", "unaryPlus"],
  iI = P(
    Jm,
    aI,
    (e) => {
      var { typed: r, add: t, unaryPlus: a } = e,
        n = Mh({ typed: r, add: t, unaryPlus: a });
      return r(Jm, {
        "...any": function (c) {
          if (c.length === 2 && da(c[0])) {
            var m = c[1];
            je(m) ? (c[1] = m - 1) : Qe(m) && (c[1] = m.minus(1));
          }
          try {
            return n.apply(null, c);
          } catch (f) {
            throw Qr(f);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  Wm = "variance",
  oI = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"],
  sI = P(
    Wm,
    oI,
    (e) => {
      var {
          typed: r,
          add: t,
          subtract: a,
          multiply: n,
          divide: i,
          apply: c,
          isNaN: m,
        } = e,
        f = Sh({
          typed: r,
          add: t,
          subtract: a,
          multiply: n,
          divide: i,
          apply: c,
          isNaN: m,
        });
      return r(Wm, {
        "...any": function (s) {
          s = _n(s);
          try {
            return f.apply(null, s);
          } catch (o) {
            throw Qr(o);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  ye = hb({ config: fe }),
  xr = bb({}),
  Xm = o_({ BigNumber: ye, config: fe }),
  uI = e_({}),
  lI = R_({ BigNumber: ye, config: fe }),
  In = Mb({}),
  Th = v_({ Complex: xr }),
  cI = t_({ BigNumber: ye, config: fe }),
  fI = l_({ BigNumber: ye, config: fe }),
  mI = f_({ BigNumber: ye, config: fe }),
  so = Ob({}),
  pI = n_({ BigNumber: ye, config: fe }),
  vI = r_({}),
  hI = s_({ BigNumber: ye, config: fe }),
  dI = Eb({}),
  Dh = b1({}),
  gI = m_({ BigNumber: ye, config: fe }),
  yI = e5({ BigNumber: ye, config: fe }),
  Bh = i_({ BigNumber: ye, config: fe }),
  bI = KB({}),
  xI = h_({}),
  We = Bb({ Matrix: so }),
  wI = G_({ BigNumber: ye, config: fe }),
  NI = u_({ BigNumber: ye, config: fe }),
  Ym = a_({ BigNumber: ye, config: fe }),
  MI = QB({}),
  AI = p_({ BigNumber: ye, config: fe }),
  W = h1({ BigNumber: ye, Complex: xr, DenseMatrix: We, Fraction: In }),
  cu = Vx({ BigNumber: ye, config: fe, typed: W }),
  SI = V_({ BigNumber: ye, config: fe }),
  it = Hx({ typed: W }),
  EI = aS({ Complex: xr, config: fe, typed: W }),
  CI = uS({ BigNumber: ye, typed: W }),
  $I = mS({ BigNumber: ye, Complex: xr, config: fe, typed: W }),
  Tr = Xx({ typed: W }),
  OI = DN({ typed: W }),
  TI = yS({ BigNumber: ye, Complex: xr, config: fe, typed: W }),
  DI = MS({ typed: W }),
  _h = ES({ typed: W }),
  BI = TS({ Complex: xr, config: fe, typed: W }),
  jt = Mx({ BigNumber: ye, typed: W }),
  _I = MN({ typed: W }),
  II = xx({ typed: W }),
  RI = Ib({ typed: W }),
  uo = DD({ typed: W }),
  lo = Ex({ Complex: xr, typed: W }),
  Na = _N({ typed: W }),
  FI = IS({ typed: W }),
  PI = qS({ BigNumber: ye, typed: W }),
  qI = US({ BigNumber: ye, typed: W }),
  zI = uw({ typed: W }),
  er = ux({ config: fe, typed: W }),
  UI = jM({ typed: W }),
  Ih = cw({ typed: W }),
  LI = mw({ Complex: xr, typed: W }),
  kI = rM({ typed: W }),
  VI = iM({ typed: W }),
  Qa = s2({ typed: W }),
  GI = uM({ typed: W }),
  HI = p2({ format: Qa, typed: W }),
  Rh = RN({ typed: W }),
  ft = Fb({ typed: W }),
  Ma = Jb({ typed: W }),
  co = Kb({ typed: W }),
  zt = rx({ typed: W }),
  ZI = c_({ BigNumber: ye, config: fe }),
  JI = PD({ Complex: xr, typed: W }),
  WI = Fw({ Complex: xr, config: fe, typed: W }),
  XI = qw({ Complex: xr, config: fe, typed: W }),
  Fh = vM({ typed: W }),
  Cr = Jw({ typed: W }),
  Ph = zN({ typed: W }),
  xn = dx({ typed: W }),
  YI = f2({ format: Qa, typed: W }),
  QI = fB({ config: fe, typed: W }),
  jI = h2({ typed: W }),
  KI = pB({ config: fe, typed: W }),
  qh = PN({ typed: W }),
  eR = GS({ BigNumber: ye, typed: W }),
  zh = Kw({ BigNumber: ye, Fraction: In, complex: lo, typed: W }),
  fu = WS({ typed: W }),
  rn = fx({ Matrix: so, equalScalar: er, typed: W }),
  rR = zx({ typed: W }),
  tR = aN({ typed: W }),
  nR = yx({ typed: W }),
  aR = jS({ typed: W }),
  iR = ix({ typed: W }),
  oR = oS({ Complex: xr, config: fe, typed: W }),
  sR = vS({ BigNumber: ye, typed: W }),
  mu = nh({ isInteger: ft, typed: W }),
  uR = dS({ BigNumber: ye, Complex: xr, config: fe, typed: W }),
  lR = l2({ format: Qa, typed: W }),
  cR = _D({ typed: W }),
  pu = BS({ typed: W }),
  fR = kS({ BigNumber: ye, typed: W }),
  ja = nx({ typed: W }),
  mR = b2({ typed: W }),
  pR = hB({ config: fe, typed: W }),
  vR = ZS({ BigNumber: ye, typed: W }),
  hR = YS({ typed: W }),
  dR = eS({ SparseMatrix: rn, typed: W }),
  tn = tN({ Complex: xr, config: fe, typed: W }),
  gR = rE({ typed: W }),
  nn = Lx({ typed: W }),
  yR = cS({ BigNumber: ye, Complex: xr, config: fe, typed: W }),
  bR = FS({ BigNumber: ye, typed: W }),
  Ka = Ox({ Fraction: In, typed: W }),
  Rn = Xb({ typed: W }),
  Ne = Dx({ DenseMatrix: We, Matrix: so, SparseMatrix: rn, typed: W }),
  xR = _x({ isZero: zt, matrix: Ne, typed: W }),
  Uh = Gw({ DenseMatrix: We, equalScalar: er, matrix: Ne, typed: W }),
  wR = Qw({ BigNumber: ye, equalScalar: er, matrix: Ne, typed: W }),
  xt = N2({ bignumber: jt, fraction: Ka, number: xn }),
  NR = LN({ DenseMatrix: We, equalScalar: er, matrix: Ne, typed: W }),
  Lh = i2({ config: fe, multiplyScalar: Cr, numeric: xt, typed: W }),
  MR = NM({ isInteger: ft, matrix: Ne, typed: W }),
  Hr = BM({ matrix: Ne, config: fe, typed: W }),
  mt = dA({ DenseMatrix: We, config: fe, matrix: Ne, typed: W }),
  AR = IM({ matrix: Ne, typed: W }),
  vt = ph({ matrix: Ne, typed: W }),
  Mr = oN({
    DenseMatrix: We,
    addScalar: Tr,
    equalScalar: er,
    matrix: Ne,
    typed: W,
    unaryMinus: nn,
  }),
  SR = g2({ matrix: Ne, typed: W }),
  vu = LM({ matrix: Ne, typed: W }),
  kh = uN({ BigNumber: ye, config: fe, matrix: Ne, typed: W }),
  Ut = HM({ BigNumber: ye, config: fe, matrix: Ne, typed: W }),
  ER = tA({ equalScalar: er, matrix: Ne, not: Ph, typed: W, zeros: Ut }),
  CR = wN({ equalScalar: er, matrix: Ne, typed: W }),
  $R = ON({ DenseMatrix: We, matrix: Ne, typed: W }),
  OR = Qx({
    BigNumber: ye,
    Complex: xr,
    Fraction: In,
    config: fe,
    isNegative: Ma,
    matrix: Ne,
    typed: W,
    unaryMinus: nn,
  }),
  Aa = aA({
    BigNumber: ye,
    DenseMatrix: We,
    Fraction: In,
    config: fe,
    equalScalar: er,
    matrix: Ne,
    typed: W,
  }),
  Vh = cA({ matrix: Ne, typed: W }),
  hu = ih({ isInteger: ft, matrix: Ne, typed: W }),
  TR = JN({ prod: Lh, size: Hr, typed: W }),
  du = VM({ conj: Na, transpose: vu, typed: W }),
  Gh = QN({ DenseMatrix: We, SparseMatrix: rn, matrix: Ne, typed: W }),
  Ar = A2({ numeric: xt, typed: W }),
  fo = q2({
    DenseMatrix: We,
    divideScalar: Ar,
    equalScalar: er,
    matrix: Ne,
    typed: W,
  }),
  Ct = mA({ DenseMatrix: We, equalScalar: er, matrix: Ne, typed: W }),
  Hh = JM({
    addScalar: Tr,
    divideScalar: Ar,
    exp: Ih,
    i: Th,
    matrix: Ne,
    multiplyScalar: Cr,
    tau: Bh,
    typed: W,
  }),
  ei = nM({ matrix: Ne, typed: W }),
  DR = $w({
    BigNumber: ye,
    DenseMatrix: We,
    equalScalar: er,
    matrix: Ne,
    typed: W,
  }),
  BR = Qb({ isNumeric: Rn, typed: W }),
  _R = SE({
    abs: it,
    addScalar: Tr,
    divideScalar: Ar,
    isPositive: co,
    multiplyScalar: Cr,
    smaller: mt,
    sqrt: tn,
    typed: W,
  }),
  IR = XM({ conj: Na, dotDivide: fo, fft: Hh, typed: W }),
  RR = mM({ matrix: Ne, multiplyScalar: Cr, typed: W }),
  mo = NA({ DenseMatrix: We, config: fe, matrix: Ne, typed: W }),
  FR = Y2({
    DenseMatrix: We,
    equalScalar: er,
    matrix: Ne,
    typed: W,
    zeros: Ut,
  }),
  Zh = U2({
    DenseMatrix: We,
    divideScalar: Ar,
    equalScalar: er,
    matrix: Ne,
    multiplyScalar: Cr,
    subtract: Mr,
    typed: W,
  }),
  Jh = Px({ flatten: ei, matrix: Ne, size: Hr, typed: W }),
  PR = hh({ config: fe, numeric: xt, smaller: mt, typed: W }),
  qR = n2({ isNaN: ja, isNumeric: Rn, typed: W }),
  zR = I2({ Complex: xr, config: fe, divideScalar: Ar, typed: W }),
  UR = bM({ BigNumber: ye, config: fe, matrix: Ne, typed: W }),
  gu = $A({ compare: Aa, isNaN: ja, isNumeric: Rn, typed: W }),
  LR = SM({ config: fe, matrix: Ne }),
  kR = j2({
    DenseMatrix: We,
    equalScalar: er,
    matrix: Ne,
    typed: W,
    zeros: Ut,
  }),
  po = $2({
    BigNumber: ye,
    DenseMatrix: We,
    equalScalar: er,
    matrix: Ne,
    typed: W,
    zeros: Ut,
  }),
  yu = yA({ DenseMatrix: We, config: fe, matrix: Ne, typed: W }),
  VR = EA({
    DenseMatrix: We,
    config: fe,
    equalScalar: er,
    matrix: Ne,
    typed: W,
  }),
  bu = k2({
    DenseMatrix: We,
    divideScalar: Ar,
    equalScalar: er,
    matrix: Ne,
    multiplyScalar: Cr,
    subtract: Mr,
    typed: W,
  }),
  GR = VN({ DenseMatrix: We, matrix: Ne, typed: W }),
  Nr = ME({
    DenseMatrix: We,
    SparseMatrix: rn,
    addScalar: Tr,
    equalScalar: er,
    matrix: Ne,
    typed: W,
  }),
  HR = $S({
    BigNumber: ye,
    DenseMatrix: We,
    equalScalar: er,
    matrix: Ne,
    typed: W,
  }),
  ZR = SN({ DenseMatrix: We, equalScalar: er, matrix: Ne, typed: W }),
  JR = wB({
    addScalar: Tr,
    combinations: uo,
    divideScalar: Ar,
    isInteger: ft,
    isNegative: Ma,
    multiplyScalar: Cr,
    typed: W,
  }),
  Lt = sA({ compare: Aa, typed: W }),
  WR = Mh({ add: Nr, typed: W, unaryPlus: cu }),
  Wh = AA({ equal: Ct, typed: W }),
  XR = uh({ matrix: Ne, number: xn, subtract: Mr, typed: W }),
  vo = OE({ addScalar: Tr, conj: Na, multiplyScalar: Cr, size: Hr, typed: W }),
  YR = vA({ compareText: Vh, isZero: zt, typed: W }),
  Xh = yw({
    DenseMatrix: We,
    config: fe,
    equalScalar: er,
    matrix: Ne,
    round: po,
    typed: W,
    zeros: Ut,
  }),
  Sa = cM({
    BigNumber: ye,
    DenseMatrix: We,
    SparseMatrix: rn,
    config: fe,
    matrix: Ne,
    typed: W,
  }),
  QR = cN({
    BigNumber: ye,
    add: Nr,
    config: fe,
    equal: Ct,
    isInteger: ft,
    mod: Uh,
    smaller: mt,
    typed: W,
    xgcd: kh,
  }),
  pt = xA({ DenseMatrix: We, config: fe, matrix: Ne, typed: W }),
  xu = T2({ Complex: xr, config: fe, divideScalar: Ar, typed: W }),
  jR = G2({
    DenseMatrix: We,
    divideScalar: Ar,
    equalScalar: er,
    matrix: Ne,
    multiplyScalar: Cr,
    subtract: Mr,
    typed: W,
  }),
  KR = Rx({ flatten: ei, matrix: Ne, size: Hr, typed: W }),
  $r = Xw({
    addScalar: Tr,
    dot: vo,
    equalScalar: er,
    matrix: Ne,
    multiplyScalar: Cr,
    typed: W,
  }),
  Yh = YC({
    addScalar: Tr,
    complex: lo,
    conj: Na,
    divideScalar: Ar,
    equal: Ct,
    identity: Sa,
    isZero: zt,
    matrix: Ne,
    multiplyScalar: Cr,
    sign: zh,
    sqrt: tn,
    subtract: Mr,
    typed: W,
    unaryMinus: nn,
    zeros: Ut,
  }),
  La = fh({
    bignumber: jt,
    matrix: Ne,
    config: fe,
    larger: pt,
    largerEq: mo,
    smaller: mt,
    smallerEq: yu,
    typed: W,
  }),
  eF = eA({
    DenseMatrix: We,
    equalScalar: er,
    matrix: Ne,
    typed: W,
    zeros: Ut,
  }),
  rF = gE({ compareNatural: Lt, typed: W }),
  Qh = x3({
    SparseMatrix: rn,
    abs: it,
    add: Nr,
    divideScalar: Ar,
    larger: pt,
    largerEq: mo,
    multiply: $r,
    subtract: Mr,
    transpose: vu,
    typed: W,
  }),
  jh = Nh({ add: Nr, config: fe, numeric: xt, typed: W }),
  tF = BE({ add: Nr, matrix: Ne, typed: W }),
  Kh = Z2({
    DenseMatrix: We,
    divideScalar: Ar,
    equalScalar: er,
    matrix: Ne,
    multiplyScalar: Cr,
    subtract: Mr,
    typed: W,
  }),
  nF = xS({ Complex: xr, config: fe, typed: W }),
  ed = ow({
    DenseMatrix: We,
    config: fe,
    equalScalar: er,
    matrix: Ne,
    round: po,
    typed: W,
    zeros: Ut,
  }),
  aF = MB({
    addScalar: Tr,
    combinations: uo,
    isInteger: ft,
    isNegative: Ma,
    isPositive: co,
    larger: pt,
    typed: W,
  }),
  iF = XN({ matrix: Ne, multiply: $r, subtract: Mr, typed: W }),
  rd = Y4({
    divideScalar: Ar,
    isZero: zt,
    matrix: Ne,
    multiply: $r,
    subtract: Mr,
    typed: W,
    unaryMinus: nn,
  }),
  oF = vD({
    abs: it,
    addScalar: Tr,
    divideScalar: Ar,
    multiplyScalar: Cr,
    sqrt: tn,
    subtract: Mr,
    typed: W,
    unaryMinus: nn,
  }),
  sF = vN({ equalScalar: er, matrix: Ne, multiplyScalar: Cr, typed: W }),
  td = LA({ larger: pt, smaller: mt }),
  nd = hw({
    Complex: xr,
    DenseMatrix: We,
    ceil: ed,
    equalScalar: er,
    floor: Xh,
    matrix: Ne,
    typed: W,
    zeros: Ut,
  }),
  ad = RA({ DenseMatrix: We, smaller: mt }),
  kr = qA({ ImmutableDenseMatrix: ad }),
  uF = gD({
    abs: it,
    add: Nr,
    addScalar: Tr,
    config: fe,
    divideScalar: Ar,
    equalScalar: er,
    flatten: ei,
    isNumeric: Rn,
    isZero: zt,
    matrix: Ne,
    multiply: $r,
    multiplyScalar: Cr,
    smaller: mt,
    subtract: Mr,
    typed: W,
  }),
  lF = Iw({ equalScalar: er, matrix: Ne, typed: W }),
  cF = B2({ Complex: xr, config: fe, divideScalar: Ar, log: xu, typed: W }),
  id = vh({ config: fe, larger: pt, numeric: xt, typed: W }),
  fF = $D({
    add: Nr,
    compare: Aa,
    multiply: $r,
    partitionSelect: gu,
    typed: W,
  }),
  mF = mh({ Index: kr, matrix: Ne, range: La, typed: W }),
  pF = nE({
    DenseMatrix: We,
    Index: kr,
    compareNatural: Lt,
    size: Hr,
    subset: vt,
    typed: W,
  }),
  vF = sE({
    DenseMatrix: We,
    Index: kr,
    compareNatural: Lt,
    size: Hr,
    subset: vt,
    typed: W,
  }),
  hF = fE({ Index: kr, compareNatural: Lt, size: Hr, subset: vt, typed: W }),
  dF = hE({ Index: kr, compareNatural: Lt, size: Hr, subset: vt, typed: W }),
  gF = TA({ compare: Aa, compareNatural: Lt, matrix: Ne, typed: W }),
  od = sh({ Index: kr, matrix: Ne, range: La, typed: W }),
  yF = IE({ Index: kr, typed: W }),
  Fn = j4({
    abs: it,
    addScalar: Tr,
    det: rd,
    divideScalar: Ar,
    identity: Sa,
    matrix: Ne,
    multiply: $r,
    typed: W,
    unaryMinus: nn,
  }),
  bF = eD({
    Complex: xr,
    add: Nr,
    ctranspose: du,
    deepEqual: Wh,
    divideScalar: Ar,
    dot: vo,
    dotDivide: fo,
    equal: Ct,
    inv: Fn,
    matrix: Ne,
    multiply: $r,
    typed: W,
  }),
  an = E2({
    Complex: xr,
    config: fe,
    fraction: Ka,
    identity: Sa,
    inv: Fn,
    matrix: Ne,
    multiply: $r,
    number: xn,
    typed: W,
  }),
  sd = iE({
    DenseMatrix: We,
    Index: kr,
    compareNatural: Lt,
    size: Hr,
    subset: vt,
    typed: W,
  }),
  xF = pE({ Index: kr, compareNatural: Lt, size: Hr, subset: vt, typed: W }),
  ud = GA({ FibonacciHeap: td, addScalar: Tr, equalScalar: er }),
  wF = lD({
    abs: it,
    add: Nr,
    identity: Sa,
    inv: Fn,
    max: id,
    multiply: $r,
    size: Hr,
    sqrt: tn,
    subtract: Mr,
    typed: W,
  }),
  Ue = YA({
    BigNumber: ye,
    Complex: xr,
    Fraction: In,
    abs: it,
    addScalar: Tr,
    config: fe,
    divideScalar: Ar,
    equal: Ct,
    fix: nd,
    format: Qa,
    isNumeric: Rn,
    multiplyScalar: Cr,
    number: xn,
    pow: an,
    round: po,
    subtract: Mr,
  }),
  NF = N_({ BigNumber: ye, Unit: Ue, config: fe }),
  MF = n5({ BigNumber: ye, Unit: Ue, config: fe }),
  AF = H_({ BigNumber: ye, Unit: Ue, config: fe }),
  SF = S_({ BigNumber: ye, Unit: Ue, config: fe }),
  EF = J_({ BigNumber: ye, Unit: Ue, config: fe }),
  CF = E_({ BigNumber: ye, Unit: Ue, config: fe }),
  $F = tS({ Unit: Ue, typed: W }),
  OF = q_({ BigNumber: ye, Unit: Ue, config: fe }),
  TF = F2({ DenseMatrix: We, equalScalar: er, matrix: Ne, pow: an, typed: W }),
  DF = w_({ BigNumber: ye, Unit: Ue, config: fe }),
  BF = A_({ BigNumber: ye, Unit: Ue, config: fe }),
  _F = sD({ abs: it, add: Nr, identity: Sa, inv: Fn, multiply: $r, typed: W }),
  IF = W_({ BigNumber: ye, Unit: Ue, config: fe }),
  RF = X_({ BigNumber: ye, Unit: Ue, config: fe }),
  ld = RD({
    BigNumber: ye,
    Complex: xr,
    config: fe,
    multiplyScalar: Cr,
    pow: an,
    typed: W,
  }),
  FF = g_({ BigNumber: ye, Unit: Ue, config: fe }),
  PF = F_({ BigNumber: ye, Unit: Ue, config: fe }),
  qF = T_({ BigNumber: ye, Unit: Ue, config: fe }),
  zF = Y_({ BigNumber: ye, Unit: Ue, config: fe }),
  UF = x_({ BigNumber: ye, Unit: Ue, config: fe }),
  LF = a5({ BigNumber: ye, Unit: Ue, config: fe }),
  kF = j_({ BigNumber: ye, Unit: Ue, config: fe }),
  VF = z_({ BigNumber: ye, Unit: Ue, config: fe }),
  GF = O_({ BigNumber: ye, Unit: Ue, config: fe }),
  HF = c5({ BigNumber: ye, Unit: Ue, config: fe }),
  ZF = s5({ BigNumber: ye, Unit: Ue, config: fe }),
  JF = f5({ BigNumber: ye, Unit: Ue, config: fe }),
  WF = P_({ BigNumber: ye, Unit: Ue, config: fe }),
  XF = b_({ BigNumber: ye, Unit: Ue, config: fe }),
  YF = L_({ BigNumber: ye, Unit: Ue, config: fe }),
  cd = lE({
    DenseMatrix: We,
    Index: kr,
    compareNatural: Lt,
    size: Hr,
    subset: vt,
    typed: W,
  }),
  QF = d_({ BigNumber: ye, Unit: Ue, config: fe }),
  jF = t5({ BigNumber: ye, Unit: Ue, config: fe }),
  KF = k_({ BigNumber: ye, Unit: Ue, config: fe }),
  e6 = Z_({ BigNumber: ye, Unit: Ue, config: fe }),
  r6 = D_({ BigNumber: ye, Unit: Ue, config: fe }),
  t6 = M_({ BigNumber: ye, Unit: Ue, config: fe }),
  wt = mD({
    divideScalar: Ar,
    equalScalar: er,
    inv: Fn,
    matrix: Ne,
    multiply: $r,
    typed: W,
  }),
  n6 = __({ BigNumber: ye, Unit: Ue, config: fe }),
  ho = zD({ gamma: ld, typed: W }),
  a6 = o5({ BigNumber: ye, Unit: Ue, config: fe }),
  i6 = C_({ BigNumber: ye, Unit: Ue, config: fe }),
  fd = WC({
    DenseMatrix: We,
    Spa: ud,
    SparseMatrix: rn,
    abs: it,
    addScalar: Tr,
    divideScalar: Ar,
    equalScalar: er,
    larger: pt,
    matrix: Ne,
    multiplyScalar: Cr,
    subtract: Mr,
    typed: W,
    unaryMinus: nn,
  }),
  o6 = $_({ BigNumber: ye, Unit: Ue, config: fe }),
  s6 = i5({ BigNumber: ye, Unit: Ue, config: fe }),
  u6 = VD({
    add: Nr,
    divide: wt,
    factorial: ho,
    isInteger: ft,
    isPositive: co,
    multiply: $r,
    typed: W,
  }),
  l6 = HD({ factorial: ho, typed: W }),
  c6 = u5({ BigNumber: ye, Unit: Ue, config: fe }),
  f6 = U_({ BigNumber: ye, Unit: Ue, config: fe }),
  m6 = r5({ BigNumber: ye, Unit: Ue, config: fe }),
  md = gB({
    bignumber: jt,
    addScalar: Tr,
    combinations: uo,
    divideScalar: Ar,
    factorial: ho,
    isInteger: ft,
    isNegative: Ma,
    larger: pt,
    multiplyScalar: Cr,
    number: xn,
    pow: an,
    subtract: Mr,
    typed: W,
  }),
  p6 = jA({ Unit: Ue, typed: W }),
  v6 = bB({
    addScalar: Tr,
    isInteger: ft,
    isNegative: Ma,
    stirlingS2: md,
    typed: W,
  }),
  pd = iD({
    abs: it,
    add: Nr,
    addScalar: Tr,
    atan: _h,
    bignumber: jt,
    column: od,
    complex: lo,
    config: fe,
    cos: pu,
    diag: Gh,
    divideScalar: Ar,
    dot: vo,
    equal: Ct,
    flatten: ei,
    im: Rh,
    inv: Fn,
    larger: pt,
    matrix: Ne,
    matrixFromColumns: Jh,
    multiply: $r,
    multiplyScalar: Cr,
    number: xn,
    qr: Yh,
    re: qh,
    sin: fu,
    smaller: mt,
    sqrt: tn,
    subtract: Mr,
    typed: W,
    usolve: bu,
    usolveAll: Kh,
  }),
  h6 = I_({ BigNumber: ye, Unit: Ue, config: fe }),
  d6 = Ah({ add: Nr, divide: wt, typed: W }),
  g6 = K_({ BigNumber: ye, Unit: Ue, config: fe }),
  y6 = y_({ BigNumber: ye, Unit: Ue, config: fe }),
  vd = bE({
    Index: kr,
    concat: hu,
    setDifference: sd,
    size: Hr,
    subset: vt,
    typed: W,
  }),
  b6 = B_({ BigNumber: ye, Unit: Ue, config: fe }),
  x6 = N3({
    DenseMatrix: We,
    lsolve: Zh,
    lup: fd,
    matrix: Ne,
    slu: Qh,
    typed: W,
    usolve: bu,
  }),
  hd = ND({ add: Nr, compare: Aa, divide: wt, partitionSelect: gu, typed: W }),
  w6 = wE({
    Index: kr,
    concat: hu,
    setIntersect: cd,
    setSymDifference: vd,
    size: Hr,
    subset: vt,
    typed: W,
  }),
  wu = Sh({
    add: Nr,
    apply: mu,
    divide: wt,
    isNaN: ja,
    multiply: $r,
    subtract: Mr,
    typed: W,
  }),
  N6 = LD({
    divide: wt,
    dotDivide: fo,
    isNumeric: Rn,
    log: xu,
    matrix: Ne,
    multiply: $r,
    sum: jh,
    typed: W,
  }),
  dd = CE({
    abs: it,
    add: Nr,
    conj: Na,
    ctranspose: du,
    eigs: pd,
    equalScalar: er,
    larger: pt,
    matrix: Ne,
    multiply: $r,
    pow: an,
    smaller: mt,
    sqrt: tn,
    typed: W,
  }),
  M6 = l5({ BigNumber: ye, Unit: Ue, config: fe }),
  gd = OM({
    BigNumber: ye,
    DenseMatrix: We,
    SparseMatrix: rn,
    addScalar: Tr,
    config: fe,
    cos: pu,
    matrix: Ne,
    multiplyScalar: Cr,
    norm: dd,
    sin: fu,
    typed: W,
    unaryMinus: nn,
  }),
  A6 = Q_({ BigNumber: ye, Unit: Ue, config: fe }),
  S6 = Eh({ sqrt: tn, typed: W, variance: wu }),
  E6 = AD({ abs: it, map: Fh, median: hd, subtract: Mr, typed: W }),
  C6 = CM({ multiply: $r, rotationMatrix: gd, typed: W }),
  Ea = {},
  ri = {},
  yd = {},
  Nu = $3({ math: Ea }),
  Zr = PE({ mathWithTransform: ri }),
  ti = gC({ Node: Zr }),
  wn = xC({ Node: Zr }),
  Pn = MC({ Node: Zr }),
  bd = OC({ Node: Zr }),
  ni = VE({ Node: Zr }),
  xd = YE({ Node: Zr, ResultSet: Dh }),
  wd = KE({ Node: Zr }),
  qn = uC({ Node: Zr }),
  Nd = EC({ Node: Zr }),
  $6 = WB({ classes: yd }),
  O6 = W4({ Chain: Nu, typed: W }),
  Md = fC({ Node: Zr, typed: W }),
  ai = UE({ Node: Zr, subset: vt }),
  Ad = JE({ matrix: Ne, Node: Zr, subset: vt }),
  ii = vC({ Node: Zr, size: Hr }),
  zn = BC({ Unit: Ue, Node: Zr, math: Ea }),
  Un = RC({ Node: Zr, SymbolNode: zn, math: Ea }),
  kt = PC({
    AccessorNode: ai,
    ArrayNode: ni,
    AssignmentNode: Ad,
    BlockNode: xd,
    ConditionalNode: wd,
    ConstantNode: qn,
    FunctionAssignmentNode: Md,
    FunctionNode: Un,
    IndexNode: ii,
    ObjectNode: ti,
    OperatorNode: wn,
    ParenthesisNode: Pn,
    RangeNode: Nd,
    RelationalNode: bd,
    SymbolNode: zn,
    config: fe,
    numeric: xt,
    typed: W,
  }),
  Sd = qB({
    ConstantNode: qn,
    FunctionNode: Un,
    OperatorNode: wn,
    ParenthesisNode: Pn,
    parse: kt,
  }),
  Mu = RB({
    AccessorNode: ai,
    ArrayNode: ni,
    ConstantNode: qn,
    FunctionNode: Un,
    IndexNode: ii,
    ObjectNode: ti,
    OperatorNode: wn,
    ParenthesisNode: Pn,
    SymbolNode: zn,
    add: Nr,
    divide: wt,
    equal: Ct,
    isZero: zt,
    multiply: $r,
    pow: an,
    subtract: Mr,
  }),
  T6 = zC({ parse: kt, typed: W }),
  Ed = S3({ parse: kt }),
  D6 = SB({ parse: kt, typed: W }),
  go = BB({
    bignumber: jt,
    fraction: Ka,
    AccessorNode: ai,
    ArrayNode: ni,
    ConstantNode: qn,
    FunctionNode: Un,
    IndexNode: ii,
    ObjectNode: ti,
    OperatorNode: wn,
    ParenthesisNode: Pn,
    SymbolNode: zn,
    add: Nr,
    config: fe,
    divide: wt,
    equal: Ct,
    isZero: zt,
    mathWithTransform: ri,
    matrix: Ne,
    multiply: $r,
    parse: kt,
    pow: an,
    resolve: Sd,
    simplifyCore: Mu,
    subtract: Mr,
    typed: W,
  }),
  B6 = UB({ OperatorNode: wn, parse: kt, simplify: go, typed: W }),
  Au = LC({ parse: kt, typed: W }),
  _6 = Z4({ Help: Ed, mathWithTransform: ri, typed: W }),
  Cd = GC({ evaluate: Au }),
  I6 = HB({
    bignumber: jt,
    fraction: Ka,
    AccessorNode: ai,
    ArrayNode: ni,
    ConstantNode: qn,
    FunctionNode: Un,
    IndexNode: ii,
    ObjectNode: ti,
    OperatorNode: wn,
    ParenthesisNode: Pn,
    SymbolNode: zn,
    add: Nr,
    config: fe,
    divide: wt,
    equal: Ct,
    isZero: zt,
    mathWithTransform: ri,
    matrix: Ne,
    multiply: $r,
    parse: kt,
    pow: an,
    simplify: go,
    simplifyCore: Mu,
    subtract: Mr,
    typed: W,
  }),
  R6 = VB({
    ConstantNode: qn,
    FunctionNode: Un,
    OperatorNode: wn,
    ParenthesisNode: Pn,
    SymbolNode: zn,
    config: fe,
    equal: Ct,
    isZero: zt,
    numeric: xt,
    parse: kt,
    simplify: go,
    typed: W,
  }),
  F6 = ZC({ Parser: Cd, typed: W });
Lr(Ea, {
  e: Xm,
  false: uI,
  fineStructure: lI,
  i: Th,
  Infinity: cI,
  LN10: fI,
  LOG10E: mI,
  NaN: pI,
  null: vI,
  phi: hI,
  SQRT1_2: gI,
  sackurTetrode: yI,
  tau: Bh,
  true: bI,
  E: Xm,
  version: xI,
  efimovFactor: wI,
  LN2: NI,
  pi: Ym,
  replacer: MI,
  reviver: $6,
  SQRT2: AI,
  typed: W,
  unaryPlus: cu,
  PI: Ym,
  weakMixingAngle: SI,
  abs: it,
  acos: EI,
  acot: CI,
  acsc: $I,
  addScalar: Tr,
  arg: OI,
  asech: TI,
  asinh: DI,
  atan: _h,
  atanh: BI,
  bignumber: jt,
  bitNot: _I,
  boolean: II,
  chain: O6,
  clone: RI,
  combinations: uo,
  complex: lo,
  conj: Na,
  cosh: FI,
  coth: PI,
  csc: qI,
  cube: zI,
  equalScalar: er,
  erf: UI,
  exp: Ih,
  expm1: LI,
  filter: kI,
  forEach: VI,
  format: Qa,
  getMatrixDataType: GI,
  hex: HI,
  im: Rh,
  isInteger: ft,
  isNegative: Ma,
  isPositive: co,
  isZero: zt,
  LOG2E: ZI,
  lgamma: JI,
  log10: WI,
  log2: XI,
  map: Fh,
  multiplyScalar: Cr,
  not: Ph,
  number: xn,
  oct: YI,
  pickRandom: QI,
  print: jI,
  random: KI,
  re: qh,
  sec: eR,
  sign: zh,
  sin: fu,
  splitUnit: rR,
  square: tR,
  string: nR,
  tan: aR,
  typeOf: iR,
  acosh: oR,
  acsch: sR,
  apply: mu,
  asec: uR,
  bin: lR,
  combinationsWithRep: cR,
  cos: pu,
  csch: fR,
  isNaN: ja,
  isPrime: mR,
  randomInt: pR,
  sech: vR,
  sinh: hR,
  sparse: dR,
  sqrt: tn,
  tanh: gR,
  unaryMinus: nn,
  acoth: yR,
  cot: bR,
  fraction: Ka,
  isNumeric: Rn,
  matrix: Ne,
  matrixFromFunction: xR,
  mod: Uh,
  nthRoot: wR,
  numeric: xt,
  or: NR,
  prod: Lh,
  reshape: MR,
  size: Hr,
  smaller: mt,
  squeeze: AR,
  subset: vt,
  subtract: Mr,
  to: SR,
  transpose: vu,
  xgcd: kh,
  zeros: Ut,
  and: ER,
  bitAnd: CR,
  bitXor: $R,
  cbrt: OR,
  compare: Aa,
  compareText: Vh,
  concat: hu,
  count: TR,
  ctranspose: du,
  diag: Gh,
  divideScalar: Ar,
  dotDivide: fo,
  equal: Ct,
  fft: Hh,
  flatten: ei,
  gcd: DR,
  hasNumericValue: BR,
  hypot: _R,
  ifft: IR,
  kron: RR,
  largerEq: mo,
  leftShift: FR,
  lsolve: Zh,
  matrixFromColumns: Jh,
  min: PR,
  mode: qR,
  nthRoots: zR,
  ones: UR,
  partitionSelect: gu,
  resize: LR,
  rightArithShift: kR,
  round: po,
  smallerEq: yu,
  unequal: VR,
  usolve: bu,
  xor: GR,
  add: Nr,
  atan2: HR,
  bitOr: ZR,
  catalan: JR,
  compareNatural: Lt,
  cumsum: WR,
  deepEqual: Wh,
  diff: XR,
  dot: vo,
  equalText: YR,
  floor: Xh,
  identity: Sa,
  invmod: QR,
  larger: pt,
  log: xu,
  lsolveAll: jR,
  matrixFromRows: KR,
  multiply: $r,
  qr: Yh,
  range: La,
  rightLogShift: eF,
  setSize: rF,
  slu: Qh,
  sum: jh,
  trace: tF,
  usolveAll: Kh,
  asin: nF,
  ceil: ed,
  composition: aF,
  cross: iF,
  det: rd,
  distance: oF,
  dotMultiply: sF,
  fix: nd,
  intersect: uF,
  lcm: lF,
  log1p: cF,
  max: id,
  quantileSeq: fF,
  row: mF,
  setCartesian: pF,
  setDistinct: vF,
  setIsSubset: hF,
  setPowerset: dF,
  sort: gF,
  column: od,
  index: yF,
  inv: Fn,
  pinv: bF,
  pow: an,
  setDifference: sd,
  setMultiplicity: xF,
  sqrtm: wF,
  vacuumImpedance: NF,
  wienDisplacement: MF,
  atomicMass: AF,
  bohrMagneton: SF,
  boltzmann: EF,
  conductanceQuantum: CF,
  createUnit: $F,
  deuteronMass: OF,
  dotPow: TF,
  electricConstant: DF,
  elementaryCharge: BF,
  expm: _F,
  faraday: IF,
  firstRadiation: RF,
  gamma: ld,
  gravitationConstant: FF,
  hartreeEnergy: PF,
  klitzing: qF,
  loschmidt: zF,
  magneticConstant: UF,
  molarMass: LF,
  molarPlanckConstant: kF,
  neutronMass: VF,
  nuclearMagneton: GF,
  planckCharge: HF,
  planckLength: ZF,
  planckTemperature: JF,
  protonMass: WF,
  reducedPlanckConstant: XF,
  rydberg: YF,
  setIntersect: cd,
  speedOfLight: QF,
  stefanBoltzmann: jF,
  thomsonCrossSection: KF,
  avogadro: e6,
  bohrRadius: r6,
  coulomb: t6,
  divide: wt,
  electronMass: n6,
  factorial: ho,
  gravity: a6,
  inverseConductanceQuantum: i6,
  lup: fd,
  magneticFluxQuantum: o6,
  molarMassC12: s6,
  multinomial: u6,
  parse: kt,
  permutations: l6,
  planckMass: c6,
  quantumOfCirculation: f6,
  resolve: Sd,
  secondRadiation: m6,
  simplifyCore: Mu,
  stirlingS2: md,
  unit: p6,
  bellNumbers: v6,
  compile: T6,
  eigs: pd,
  fermiCoupling: h6,
  leafCount: D6,
  mean: d6,
  molarVolume: g6,
  planckConstant: y6,
  setSymDifference: vd,
  simplify: go,
  symbolicEqual: B6,
  classicalElectronRadius: b6,
  evaluate: Au,
  help: _6,
  lusolve: x6,
  median: hd,
  rationalize: I6,
  setUnion: w6,
  variance: wu,
  derivative: R6,
  kldivergence: N6,
  norm: dd,
  planckTime: M6,
  rotationMatrix: gd,
  gasConstant: A6,
  parser: F6,
  std: S6,
  mad: E6,
  rotate: C6,
  config: fe,
});
Lr(ri, Ea, {
  filter: x5({ typed: W }),
  forEach: M5({ typed: W }),
  map: O5({ typed: W }),
  apply: v5({ isInteger: ft, typed: W }),
  diff: j5({ bignumber: jt, matrix: Ne, number: xn, subtract: Mr, typed: W }),
  subset: J5({ matrix: Ne, typed: W }),
  concat: Y5({ isInteger: ft, matrix: Ne, typed: W }),
  max: B5({ config: fe, larger: pt, numeric: xt, typed: W }),
  min: q5({ config: fe, numeric: xt, smaller: mt, typed: W }),
  range: L5({
    bignumber: jt,
    matrix: Ne,
    config: fe,
    larger: pt,
    largerEq: mo,
    smaller: mt,
    smallerEq: yu,
    typed: W,
  }),
  sum: nI({ add: Nr, config: fe, numeric: xt, typed: W }),
  cumsum: iI({ add: Nr, typed: W, unaryPlus: cu }),
  row: G5({ Index: kr, matrix: Ne, range: La, typed: W }),
  column: g5({ Index: kr, matrix: Ne, range: La, typed: W }),
  index: E5({ Index: kr }),
  mean: R5({ add: Nr, divide: wt, typed: W }),
  variance: sI({
    add: Nr,
    apply: mu,
    divide: wt,
    isNaN: ja,
    multiply: $r,
    subtract: Mr,
    typed: W,
  }),
  std: rI({ sqrt: tn, typed: W, variance: wu }),
});
Lr(yd, {
  BigNumber: ye,
  Chain: Nu,
  Complex: xr,
  Fraction: In,
  Matrix: so,
  Node: Zr,
  ObjectNode: ti,
  OperatorNode: wn,
  ParenthesisNode: Pn,
  Range: dI,
  RelationalNode: bd,
  ResultSet: Dh,
  ArrayNode: ni,
  BlockNode: xd,
  ConditionalNode: wd,
  ConstantNode: qn,
  DenseMatrix: We,
  RangeNode: Nd,
  FunctionAssignmentNode: Md,
  SparseMatrix: rn,
  AccessorNode: ai,
  AssignmentNode: Ad,
  IndexNode: ii,
  FibonacciHeap: td,
  ImmutableDenseMatrix: ad,
  Index: kr,
  Spa: ud,
  Unit: Ue,
  SymbolNode: zn,
  FunctionNode: Un,
  Help: Ed,
  Parser: Cd,
});
Nu.createProxy(Ea);
/**
 * @dice-roller/rpg-dice-roller - An advanced JS based dice roller that can roll various types of dice and modifiers, along with mathematical equations.
 *
 * @version 5.1.0
 * @license MIT
 * @author GreenImp Media <info@greenimp.co.uk> (http://greenimp.co.uk)
 * @link https://dice-roller.github.io/documentation
 */ class Su extends TypeError {
  constructor(r) {
    super(`Operator "${r}" is invalid`),
      TypeError.captureStackTrace && TypeError.captureStackTrace(this, Su),
      (this.name = "CompareOperatorError"),
      (this.operator = r);
  }
}
class Eu extends Error {
  constructor(r) {
    super(`Invalid data format: ${r}`),
      Error.captureStackTrace && Error.captureStackTrace(this, Eu),
      (this.name = "ImportError"),
      (this.data = r);
  }
}
class yo extends Error {
  constructor(r, t = null) {
    super(
      `Die "${r}" must have more than 1 possible value to ${
        t || "do this action"
      }`
    ),
      Error.captureStackTrace && Error.captureStackTrace(this, yo),
      (this.name = "DieActionValueError"),
      (this.action = t),
      (this.die = r);
  }
}
class Ui extends Error {
  constructor(r) {
    super(`Notation "${r}" is invalid`),
      Error.captureStackTrace && Error.captureStackTrace(this, Ui),
      (this.name = "NotationError"),
      (this.notation = r);
  }
}
class Rt extends Error {
  constructor(r = null) {
    super(`Missing argument${r ? ` "${r}"` : ""}`),
      Error.captureStackTrace && Error.captureStackTrace(this, Rt),
      (this.argumentName = r);
  }
}
const P6 = (e, r, t) => {
    const a = Number(e),
      n = Number(r);
    let i;
    if (Number.isNaN(a) || Number.isNaN(n)) return !1;
    switch (t) {
      case "=":
      case "==":
        i = a === n;
        break;
      case "<":
        i = a < n;
        break;
      case ">":
        i = a > n;
        break;
      case "<=":
        i = a <= n;
        break;
      case ">=":
        i = a >= n;
        break;
      case "!":
      case "!=":
      case "<>":
        i = a !== n;
        break;
      default:
        i = !1;
        break;
    }
    return i;
  },
  $d = (e) => Au(e),
  Er = (e) =>
    typeof e != "number" && typeof e != "string"
      ? !1
      : !Number.isNaN(e) && Number.isFinite(Number(e)),
  Ho = (e) => {
    if (!Er(e)) return !1;
    const r = Number(e);
    return r <= Number.MAX_SAFE_INTEGER && r >= Number.MIN_SAFE_INTEGER;
  },
  q6 = (e) =>
    Array.isArray(e)
      ? e.reduce((r, t) => r + (Er(t) ? parseFloat(`${t}`) : 0), 0)
      : 0,
  z6 = (e, r = 0) => parseFloat(parseFloat(`${e}`).toFixed(r || 0)),
  Dr = 9007199254740992,
  Ta = Dr - 1,
  Li = -1 >>> 0,
  ht = Li + 1,
  Yt = ht / 2,
  Zo = Yt - 1,
  oi = 1 << 21,
  $n = oi - 1;
function Cu(e) {
  return e.next() | 0;
}
function un(e, r) {
  return r === 0 ? e : (t) => e(t) + r;
}
function Cs(e) {
  const r = e.next() | 0,
    t = e.next() >>> 0;
  return (r & $n) * ht + t + (r & oi ? -Dr : 0);
}
function Od(e) {
  for (;;) {
    const r = e.next() | 0;
    if (r & 4194304) {
      if ((r & 8388607) === 4194304 && !(e.next() | 0)) return Dr;
    } else {
      const t = e.next() >>> 0;
      return (r & $n) * ht + t + (r & oi ? -Dr : 0);
    }
  }
}
function Td(e) {
  return e.next() >>> 0;
}
function bo(e) {
  const r = e.next() & $n,
    t = e.next() >>> 0;
  return r * ht + t;
}
function $u(e) {
  for (;;) {
    const r = e.next() | 0;
    if (r & oi) {
      if (!(r & $n) && !(e.next() | 0)) return Dr;
    } else {
      const t = e.next() >>> 0;
      return (r & $n) * ht + t;
    }
  }
}
function Dd(e) {
  return ((e + 1) & e) === 0;
}
function U6(e) {
  return (r) => r.next() & e;
}
function L6(e) {
  const r = e + 1,
    t = r * Math.floor(ht / r);
  return (a) => {
    let n = 0;
    do n = a.next() >>> 0;
    while (n >= t);
    return n % r;
  };
}
function k6(e) {
  return Dd(e) ? U6(e) : L6(e);
}
function V6(e) {
  return (e | 0) === 0;
}
function G6(e) {
  return (r) => {
    const t = r.next() & e,
      a = r.next() >>> 0;
    return t * ht + a;
  };
}
function H6(e) {
  const r = e * Math.floor(Dr / e);
  return (t) => {
    let a = 0;
    do {
      const n = t.next() & $n,
        i = t.next() >>> 0;
      a = n * ht + i;
    } while (a >= r);
    return a % e;
  };
}
function Z6(e) {
  const r = e + 1;
  if (V6(r)) {
    const t = ((r / ht) | 0) - 1;
    if (Dd(t)) return G6(t);
  }
  return H6(r);
}
function Qm(e, r) {
  return (t) => {
    let a = 0;
    do {
      const n = t.next() | 0,
        i = t.next() >>> 0;
      a = (n & $n) * ht + i + (n & oi ? -Dr : 0);
    } while (a < e || a > r);
    return a;
  };
}
function Ln(e, r) {
  if (((e = Math.floor(e)), (r = Math.floor(r)), e < -Dr || !isFinite(e)))
    throw new RangeError(`Expected min to be at least ${-Dr}`);
  if (r > Dr || !isFinite(r))
    throw new RangeError(`Expected max to be at most ${Dr}`);
  const t = r - e;
  return t <= 0 || !isFinite(t)
    ? () => e
    : t === Li
    ? e === 0
      ? Td
      : un(Cu, e + Yt)
    : t < Li
    ? un(k6(t), e)
    : t === Ta
    ? un(bo, e)
    : t < Ta
    ? un(Z6(t), e)
    : r - 1 - e === Ta
    ? un($u, e)
    : e === -Dr && r === Dr
    ? Od
    : e === -Dr && r === Ta
    ? Cs
    : e === -Ta && r === Dr
    ? un(Cs, 1)
    : r === Dr
    ? un(Qm(e - 1, r - 1), 1)
    : Qm(e, r);
}
function J6(e) {
  return (e.next() & 1) === 1;
}
function $s(e, r) {
  return (t) => e(t) < r;
}
function W6(e) {
  if (e <= 0) return () => !1;
  if (e >= 1) return () => !0;
  {
    const r = e * ht;
    return r % 1 === 0 ? $s(Cu, (r - Yt) | 0) : $s(bo, Math.round(e * Dr));
  }
}
function X6(e, r) {
  return r == null
    ? e == null
      ? J6
      : W6(e)
    : e <= 0
    ? () => !1
    : e >= r
    ? () => !0
    : $s(Ln(0, r - 1), e);
}
function Y6(e, r) {
  const t = Ln(+e, +r);
  return (a) => new Date(t(a));
}
function Bd(e) {
  return Ln(1, e);
}
function Q6(e, r) {
  const t = Bd(e);
  return (a) => {
    const n = [];
    for (let i = 0; i < r; ++i) n.push(t(a));
    return n;
  };
}
const j6 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";
function Ou(e = j6) {
  const r = e.length;
  if (!r) throw new Error("Expected pool not to be an empty string");
  const t = Ln(0, r - 1);
  return (a, n) => {
    let i = "";
    for (let c = 0; c < n; ++c) {
      const m = t(a);
      i += e.charAt(m);
    }
    return i;
  };
}
const _d = "0123456789abcdef",
  K6 = Ou(_d),
  eP = Ou(_d.toUpperCase());
function rP(e) {
  return e ? eP : K6;
}
function jm(e, r) {
  return e < 0 ? Math.max(e + r, 0) : Math.min(e, r);
}
function Km(e) {
  const r = +e;
  return r < 0 ? Math.ceil(r) : Math.floor(r);
}
function tP(e, r, t, a) {
  const n = r.length;
  if (n === 0) throw new RangeError("Cannot pick from an empty array");
  const i = t == null ? 0 : jm(Km(t), n),
    c = a === void 0 ? n : jm(Km(a), n);
  if (i >= c) throw new RangeError(`Cannot pick between bounds ${i} and ${c}`);
  const m = Ln(i, c - 1);
  return r[m(e)];
}
function nP(e, r) {
  return r === 1 ? e : r === 0 ? () => 0 : (t) => e(t) * r;
}
function Id(e) {
  return bo(e) / Dr;
}
function Rd(e) {
  return $u(e) / Dr;
}
function aP(e, r, t = !1) {
  if (isFinite(e)) {
    if (!isFinite(r))
      throw new RangeError("Expected max to be a finite number");
  } else throw new RangeError("Expected min to be a finite number");
  return un(nP(t ? Rd : Id, r - e), e);
}
const iP = Array.prototype.slice;
function Os(e, r, t = 0) {
  const a = r.length;
  if (a)
    for (let n = (a - 1) >>> 0; n > t; --n) {
      const c = Ln(0, n)(e);
      if (n !== c) {
        const m = r[n];
        (r[n] = r[c]), (r[c] = m);
      }
    }
  return r;
}
function oP(e, r, t) {
  if (t < 0 || t > r.length || !isFinite(t))
    throw new RangeError(
      "Expected sampleSize to be within 0 and the length of the population"
    );
  if (t === 0) return [];
  const a = iP.call(r),
    n = a.length;
  if (n === t) return Os(e, a, 0);
  const i = n - t;
  return Os(e, a, i - 1).slice(i);
}
const sP = (() => {
  try {
    if ("x".repeat(3) === "xxx") return (e, r) => e.repeat(r);
  } catch {}
  return (e, r) => {
    let t = "";
    for (; r > 0; ) r & 1 && (t += e), (r >>= 1), (e += e);
    return t;
  };
})();
function jn(e, r) {
  return sP("0", r - e.length) + e;
}
function uP(e) {
  const r = e.next() >>> 0,
    t = e.next() | 0,
    a = e.next() | 0,
    n = e.next() >>> 0;
  return (
    jn(r.toString(16), 8) +
    "-" +
    jn((t & 65535).toString(16), 4) +
    "-" +
    jn((((t >> 4) & 4095) | 16384).toString(16), 4) +
    "-" +
    jn(((a & 16383) | 32768).toString(16), 4) +
    "-" +
    jn(((a >> 4) & 65535).toString(16), 4) +
    jn(n.toString(16), 8)
  );
}
const aa = {
  next() {
    return (Math.random() * ht) | 0;
  },
};
class lP {
  constructor(r = aa) {
    this.engine = r;
  }
  int32() {
    return Cu(this.engine);
  }
  uint32() {
    return Td(this.engine);
  }
  uint53() {
    return bo(this.engine);
  }
  uint53Full() {
    return $u(this.engine);
  }
  int53() {
    return Cs(this.engine);
  }
  int53Full() {
    return Od(this.engine);
  }
  integer(r, t) {
    return Ln(r, t)(this.engine);
  }
  realZeroToOneInclusive() {
    return Rd(this.engine);
  }
  realZeroToOneExclusive() {
    return Id(this.engine);
  }
  real(r, t, a = !1) {
    return aP(r, t, a)(this.engine);
  }
  bool(r, t) {
    return X6(r, t)(this.engine);
  }
  pick(r, t, a) {
    return tP(this.engine, r, t, a);
  }
  shuffle(r) {
    return Os(this.engine, r);
  }
  sample(r, t) {
    return oP(this.engine, r, t);
  }
  die(r) {
    return Bd(r)(this.engine);
  }
  dice(r, t) {
    return Q6(r, t)(this.engine);
  }
  uuid4() {
    return uP(this.engine);
  }
  string(r, t) {
    return Ou(t)(this.engine, r);
  }
  hex(r, t) {
    return rP(t)(this.engine, r);
  }
  date(r, t) {
    return Y6(r, t)(this.engine);
  }
}
const Fd = (() => {
  try {
    const e = new ArrayBuffer(4),
      r = new Int32Array(e);
    if (((r[0] = Yt), r[0] === -Yt)) return Int32Array;
  } catch {}
  return Array;
})();
let xi = null;
const Ts = 128;
let Jo = Ts;
const cP = {
  next() {
    return (
      Jo >= Ts &&
        (xi === null && (xi = new Fd(Ts)),
        crypto.getRandomValues(xi),
        (Jo = 0)),
      xi[Jo++] | 0
    );
  },
};
function fP(e = aa, r = 16) {
  const t = [];
  t.push(new Date().getTime() | 0);
  for (let a = 1; a < r; ++a) t[a] = e.next() | 0;
  return t;
}
const Ds = (() => {
    try {
      if (Math.imul(Li, 5) === -5) return Math.imul;
    } catch {}
    const e = 65535;
    return (r, t) => {
      const a = (r >>> 16) & e,
        n = r & e,
        i = (t >>> 16) & e,
        c = t & e;
      return (n * c + (((a * c + n * i) << 16) >>> 0)) | 0;
    };
  })(),
  Dt = 624,
  fn = Dt - 1,
  Bs = 397,
  ep = Dt - Bs,
  Wo = 2567483615;
class Fa {
  constructor() {
    (this.data = new Fd(Dt)), (this.index = 0), (this.uses = 0);
  }
  static seed(r) {
    return new Fa().seed(r);
  }
  static seedWithArray(r) {
    return new Fa().seedWithArray(r);
  }
  static autoSeed() {
    return Fa.seedWithArray(fP());
  }
  next() {
    (this.index | 0) >= Dt && (Xo(this.data), (this.index = 0));
    const r = this.data[this.index];
    return (this.index = (this.index + 1) | 0), (this.uses += 1), mP(r) | 0;
  }
  getUseCount() {
    return this.uses;
  }
  discard(r) {
    if (r <= 0) return this;
    for (
      this.uses += r,
        (this.index | 0) >= Dt && (Xo(this.data), (this.index = 0));
      r + this.index > Dt;

    )
      (r -= Dt - this.index), Xo(this.data), (this.index = 0);
    return (this.index = (this.index + r) | 0), this;
  }
  seed(r) {
    let t = 0;
    this.data[0] = t = r | 0;
    for (let a = 1; a < Dt; a = (a + 1) | 0)
      this.data[a] = t = (Ds(t ^ (t >>> 30), 1812433253) + a) | 0;
    return (this.index = Dt), (this.uses = 0), this;
  }
  seedWithArray(r) {
    return this.seed(19650218), pP(this.data, r), this;
  }
}
function Xo(e) {
  let r = 0,
    t = 0;
  for (; (r | 0) < ep; r = (r + 1) | 0)
    (t = (e[r] & Yt) | (e[(r + 1) | 0] & Zo)),
      (e[r] = e[(r + Bs) | 0] ^ (t >>> 1) ^ (t & 1 ? Wo : 0));
  for (; (r | 0) < fn; r = (r + 1) | 0)
    (t = (e[r] & Yt) | (e[(r + 1) | 0] & Zo)),
      (e[r] = e[(r - ep) | 0] ^ (t >>> 1) ^ (t & 1 ? Wo : 0));
  (t = (e[fn] & Yt) | (e[0] & Zo)),
    (e[fn] = e[Bs - 1] ^ (t >>> 1) ^ (t & 1 ? Wo : 0));
}
function mP(e) {
  return (
    (e ^= e >>> 11),
    (e ^= (e << 7) & 2636928640),
    (e ^= (e << 15) & 4022730752),
    e ^ (e >>> 18)
  );
}
function pP(e, r) {
  let t = 1,
    a = 0;
  const n = r.length;
  let i = Math.max(n, Dt) | 0,
    c = e[0] | 0;
  for (; (i | 0) > 0; --i)
    (e[t] = c =
      ((e[t] ^ Ds(c ^ (c >>> 30), 1664525)) + (r[a] | 0) + (a | 0)) | 0),
      (t = (t + 1) | 0),
      ++a,
      (t | 0) > fn && ((e[0] = e[fn]), (t = 1)),
      a >= n && (a = 0);
  for (i = fn; (i | 0) > 0; --i)
    (e[t] = c = ((e[t] ^ Ds(c ^ (c >>> 30), 1566083941)) - t) | 0),
      (t = (t + 1) | 0),
      (t | 0) > fn && ((e[0] = e[fn]), (t = 1));
  e[0] = Yt;
}
let rp = null;
const _s = 128;
let Yo = _s;
const vP = {
    next() {
      return (
        Yo >= _s &&
          ((rp = new Int32Array(
            new Int8Array(require("crypto").randomBytes(4 * _s)).buffer
          )),
          (Yo = 0)),
        rp[Yo++] | 0
      );
    },
  },
  Da = Symbol("engine"),
  Qo = Symbol("random"),
  hP = {
    range: [],
    next() {
      return this.range[1] - this.range[0];
    },
  },
  dP = {
    next() {
      return 0;
    },
  },
  tp = {
    browserCrypto: cP,
    nodeCrypto: vP,
    MersenneTwister19937: Fa,
    nativeMath: aa,
    min: dP,
    max: hP,
  };
class gP {
  constructor(r = aa) {
    this.engine = r || aa;
  }
  get engine() {
    return this[Da];
  }
  set engine(r) {
    if (r && typeof r.next != "function")
      throw new TypeError("engine must have function `next()`");
    (this[Da] = r || aa), (this[Qo] = new lP(this[Da]));
  }
  integer(r, t) {
    return (this[Da].range = [r, t]), this[Qo].integer(r, t);
  }
  real(r, t, a = !1) {
    return (this[Da].range = [r, t]), this[Qo].real(r, t, a);
  }
}
const ia = new gP(),
  np = Symbol("operator"),
  ap = Symbol("value");
class ka {
  constructor(r, t) {
    if (r) {
      if (!t && t !== 0) throw new Rt("value");
    } else throw new Rt("operator");
    (this.operator = r), (this.value = t);
  }
  static isValidOperator(r) {
    return typeof r == "string" && /^(?:[<>!]?=|[<>]|<>)$/.test(r);
  }
  set operator(r) {
    if (!this.constructor.isValidOperator(r)) throw new Su(r);
    this[np] = r;
  }
  get operator() {
    return this[np];
  }
  set value(r) {
    if (!Er(r)) throw new TypeError("value must be a finite number");
    this[ap] = Number(r);
  }
  get value() {
    return this[ap];
  }
  isMatch(r) {
    return P6(r, this.value, this.operator);
  }
  toJSON() {
    const { operator: r, value: t } = this;
    return { operator: r, type: "compare-point", value: t };
  }
  toString() {
    return `${this.operator}${this.value}`;
  }
}
class Nn {
  constructor() {
    this.order = 999;
  }
  get name() {
    return "modifier";
  }
  get notation() {
    return "";
  }
  get maxIterations() {
    return 1e3;
  }
  run(r, t) {
    return r;
  }
  toJSON() {
    const { notation: r, name: t } = this;
    return { name: t, notation: r, type: "modifier" };
  }
  toString() {
    return this.notation;
  }
}
const ip = Symbol("compare-point");
class si extends Nn {
  constructor(r) {
    super(), r && (this.comparePoint = r);
  }
  get comparePoint() {
    return this[ip];
  }
  set comparePoint(r) {
    if (!(r instanceof ka))
      throw new TypeError("comparePoint must be instance of ComparePoint");
    this[ip] = r;
  }
  get name() {
    return "comparison";
  }
  get notation() {
    return `${this.comparePoint || ""}`;
  }
  isComparePoint(r) {
    return this.comparePoint ? this.comparePoint.isMatch(r) : !1;
  }
  toJSON() {
    const { comparePoint: r } = this;
    return Object.assign(super.toJSON(), { comparePoint: r });
  }
}
const op = Symbol("compound"),
  sp = Symbol("penetrate");
class Pd extends si {
  constructor(r = null, t = !1, a = !1) {
    super(r), (this[op] = !!t), (this[sp] = !!a), (this.order = 3);
  }
  get compound() {
    return this[op];
  }
  get name() {
    return "explode";
  }
  get notation() {
    return `!${this.compound ? "!" : ""}${this.penetrate ? "p" : ""}${
      super.notation
    }`;
  }
  get penetrate() {
    return this[sp];
  }
  run(r, t) {
    if (t.min === t.max) throw new yo(t, "explode");
    const a = r;
    return (
      (a.rolls = r.rolls
        .map((n) => {
          const i = [n];
          let c = n.value;
          for (
            let m = 0;
            m < this.maxIterations && this.isComparePoint(c);
            m++
          ) {
            const f = i[i.length - 1],
              u = t.rollOnce();
            (c = u.value),
              f.modifiers.add("explode"),
              this.penetrate && (f.modifiers.add("penetrate"), (u.value -= 1)),
              i.push(u);
          }
          return this.compound && i.length > 1
            ? ((n.value = q6(i.map((m) => m.value))),
              (n.modifiers = ["explode", "compound"]),
              this.penetrate && n.modifiers.add("penetrate"),
              n)
            : i;
        })
        .flat()),
      a
    );
  }
  toJSON() {
    const { compound: r, penetrate: t } = this;
    return Object.assign(super.toJSON(), { compound: r, penetrate: t });
  }
}
const yP = {
    compound: "!",
    explode: "!",
    "critical-failure": "__",
    "critical-success": "**",
    drop: "d",
    max: "v",
    min: "^",
    penetrate: "p",
    "re-roll": "r",
    "re-roll-once": "ro",
    "target-failure": "_",
    "target-success": "*",
  },
  qd = (...e) =>
    [...e].reduce((r, t) => {
      let a;
      return t instanceof Nn ? (a = t.name) : (a = t), r + (yP[a] || a);
    }, ""),
  jo = Symbol("calculation-value"),
  Ko = Symbol("modifiers"),
  Ba = Symbol("initial-value"),
  up = Symbol("use-in-total"),
  es = Symbol("value");
class ki {
  constructor(r, t = [], a = !0) {
    if (Er(r))
      (this[Ba] = Number(r)), (this.modifiers = t || []), (this.useInTotal = a);
    else if (r && typeof r == "object" && !Array.isArray(r)) {
      const n = Er(r.initialValue) ? r.initialValue : r.value;
      if (!Er(n)) throw new TypeError(`Result value is invalid: ${n}`);
      (this[Ba] = Number(n)),
        Er(r.value) && Number(r.value) !== this[Ba] && (this.value = r.value),
        Er(r.calculationValue) &&
          parseFloat(`${r.calculationValue}`) !== this.value &&
          (this.calculationValue = r.calculationValue),
        (this.modifiers = r.modifiers || t || []),
        (this.useInTotal =
          typeof r.useInTotal == "boolean" ? r.useInTotal : a || !1);
    } else
      throw r === 1 / 0
        ? new RangeError("Result value must be a finite number")
        : new TypeError(`Result value is invalid: ${r}`);
  }
  get calculationValue() {
    return Er(this[jo]) ? parseFloat(this[jo]) : this.value;
  }
  set calculationValue(r) {
    const t = Er(r);
    if (r === 1 / 0)
      throw new RangeError("Result calculation value must be a finite number");
    if (r && !t)
      throw new TypeError(`Result calculation value is invalid: ${r}`);
    this[jo] = t ? parseFloat(`${r}`) : null;
  }
  get initialValue() {
    return this[Ba];
  }
  get modifierFlags() {
    return qd(...this.modifiers);
  }
  get modifiers() {
    return this[Ko];
  }
  set modifiers(r) {
    if (
      (Array.isArray(r) || r instanceof Set) &&
      [...r].every((t) => typeof t == "string")
    ) {
      this[Ko] = new Set([...r]);
      return;
    }
    if (!r && r !== 0) {
      this[Ko] = new Set();
      return;
    }
    throw new TypeError(
      `modifiers must be a Set or array of modifier names: ${r}`
    );
  }
  get useInTotal() {
    return !!this[up];
  }
  set useInTotal(r) {
    this[up] = !!r;
  }
  get value() {
    return Er(this[es]) ? this[es] : this[Ba];
  }
  set value(r) {
    if (r === 1 / 0)
      throw new RangeError("Result value must be a finite number");
    if (!Er(r)) throw new TypeError(`Result value is invalid: ${r}`);
    this[es] = Number(r);
  }
  toJSON() {
    const {
      calculationValue: r,
      initialValue: t,
      modifierFlags: a,
      modifiers: n,
      useInTotal: i,
      value: c,
    } = this;
    return {
      calculationValue: r,
      initialValue: t,
      modifierFlags: a,
      modifiers: [...n],
      type: "result",
      useInTotal: i,
      value: c,
    };
  }
  toString() {
    return this.value + this.modifierFlags;
  }
}
const rs = Symbol("rolls");
class Jt {
  constructor(r = []) {
    this.rolls = r;
  }
  get length() {
    return this.rolls.length || 0;
  }
  get rolls() {
    return [...this[rs]];
  }
  set rolls(r) {
    if (!r || !Array.isArray(r))
      throw new TypeError(`rolls must be an array: ${r}`);
    (this[rs] = []),
      r.forEach((t) => {
        this.addRoll(t);
      });
  }
  get value() {
    return this.rolls.reduce(
      (r, t) => r + (t.useInTotal ? t.calculationValue : 0),
      0
    );
  }
  addRoll(r) {
    const t = r instanceof ki ? r : new ki(r);
    this[rs].push(t);
  }
  toJSON() {
    const { rolls: r, value: t } = this;
    return { rolls: r, type: "roll-results", value: t };
  }
  toString() {
    return `[${this.rolls.join(", ")}]`;
  }
}
const lp = Symbol("once");
class zd extends si {
  constructor(r = !1, t = null) {
    super(t), (this.once = !!r), (this.order = 4);
  }
  get name() {
    return "re-roll";
  }
  get notation() {
    return `r${this.once ? "o" : ""}${super.notation}`;
  }
  get once() {
    return !!this[lp];
  }
  set once(r) {
    this[lp] = !!r;
  }
  run(r, t) {
    if (t.min === t.max) throw new yo(t, "re-roll");
    return (
      r.rolls.map((a) => {
        for (
          let n = 0;
          n < this.maxIterations && this.isComparePoint(a.value);
          n++
        ) {
          const i = t.rollOnce();
          if (
            ((a.value = i.value),
            a.modifiers.add(`re-roll${this.once ? "-once" : ""}`),
            this.once)
          )
            break;
        }
        return a;
      }),
      r
    );
  }
  toJSON() {
    const { once: r } = this;
    return Object.assign(super.toJSON(), { once: r });
  }
}
const wi = Symbol("modifiers"),
  cp = Symbol("qty"),
  fp = Symbol("sides"),
  mp = Symbol("min-value"),
  pp = Symbol("max-value");
class fa {
  constructor(r, t = 1, a = null, n = 1, i = null) {
    if (!r && r !== 0) throw new Rt("sides");
    if (r === 1 / 0)
      throw new RangeError("numerical sides must be finite number");
    if (Er(r)) {
      if (r < 1 || !Ho(r))
        throw new RangeError(
          "numerical sides must be a positive finite number"
        );
    } else if (typeof r != "string")
      throw new TypeError("non-numerical sides must be a string");
    if (Er(t)) {
      if (t < 1 || t > 999)
        throw new RangeError("qty must be between 1 and 999");
    } else throw new TypeError("qty must be a positive finite integer");
    if (Er(n)) {
      if (!Ho(n)) throw new RangeError("min must a finite number");
    } else throw new TypeError("min must a finite number");
    if (i && !Er(i)) throw new TypeError("max must a finite number");
    if (i && !Ho(i)) throw new RangeError("max must a finite number");
    (this[cp] = parseInt(`${t}`, 10)),
      (this[fp] = r),
      a && (this.modifiers = a),
      (this[mp] = parseInt(n, 10)),
      (this[pp] = i ? parseInt(`${i}`, 10) : r);
  }
  get average() {
    return (this.min + this.max) / 2;
  }
  get modifiers() {
    return this[wi]
      ? new Map([...this[wi]].sort((r, t) => r[1].order - t[1].order))
      : null;
  }
  set modifiers(r) {
    let t;
    if (r instanceof Map) t = r;
    else if (Array.isArray(r)) t = new Map(r.map((a) => [a.name, a]));
    else if (typeof r == "object") t = new Map(Object.entries(r));
    else
      throw new TypeError(
        "modifiers should be a Map, array, or an Object containing Modifiers"
      );
    if (t.size && [...t.entries()].some((a) => !(a[1] instanceof Nn)))
      throw new TypeError("modifiers must only contain Modifier instances");
    (this[wi] = t),
      this[wi].forEach((a) => {
        a instanceof Pd && !a.comparePoint
          ? (a.comparePoint = new ka("=", this.max))
          : a instanceof zd &&
            !a.comparePoint &&
            (a.comparePoint = new ka("=", this.min));
      });
  }
  get max() {
    return this[pp];
  }
  get min() {
    return this[mp];
  }
  get name() {
    return "standard";
  }
  get notation() {
    let r = `${this.qty}d${this.sides}`;
    return (
      this.modifiers &&
        this.modifiers.size &&
        (r += [...this.modifiers.values()].reduce(
          (t, a) => t + a.notation,
          ""
        )),
      r
    );
  }
  get qty() {
    return this[cp];
  }
  get sides() {
    return this[fp];
  }
  roll() {
    const r = new Jt();
    for (let t = 0; t < this.qty; t++) r.addRoll(this.rollOnce());
    return (
      (this.modifiers || []).forEach((t) => {
        t.run(r, this);
      }),
      r
    );
  }
  rollOnce() {
    return new ki(ia.integer(this.min, this.max));
  }
  toJSON() {
    const {
      average: r,
      max: t,
      min: a,
      modifiers: n,
      name: i,
      notation: c,
      qty: m,
      sides: f,
    } = this;
    return {
      average: r,
      max: t,
      min: a,
      modifiers: n,
      name: i,
      notation: c,
      qty: m,
      sides: f,
      type: "die",
    };
  }
  toString() {
    return this.notation;
  }
}
class bP extends fa {
  constructor(r = 2, t = 1, a = null) {
    let n = r;
    if (!n && n !== 0) n = 2;
    else if (n !== 1 && n !== 2)
      throw new RangeError("nonBlanks must be 1 or 2");
    super(n, t, a, -1, 1);
  }
  get name() {
    return "fudge";
  }
  get nonBlanks() {
    return super.sides;
  }
  get sides() {
    return `F.${this.nonBlanks}`;
  }
  rollOnce() {
    let r = 0;
    if (this.nonBlanks === 2) r = ia.integer(1, 3) - 2;
    else if (this.nonBlanks === 1) {
      const t = ia.integer(1, 6);
      t === 1 ? (r = -1) : t === 6 && (r = 1);
    }
    return new ki(r);
  }
}
class xP extends fa {
  constructor(r = 1, t = null, a = !1) {
    super(100, r, t), (this.sidesAsNumber = !!a);
  }
  get name() {
    return "percentile";
  }
  get sides() {
    return this.sidesAsNumber ? super.sides : "%";
  }
}
class wP extends si {
  constructor(r) {
    super(r), (this.order = 9);
  }
  get name() {
    return "critical-failure";
  }
  get notation() {
    return `cf${super.notation}`;
  }
  run(r, t) {
    return (
      r.rolls.forEach(
        (a) => (
          this.isComparePoint(a.value) && a.modifiers.add("critical-failure"), a
        )
      ),
      r
    );
  }
}
class NP extends si {
  constructor(r) {
    super(r), (this.order = 8);
  }
  get name() {
    return "critical-success";
  }
  get notation() {
    return `cs${super.notation}`;
  }
  run(r, t) {
    return (
      r.rolls.forEach(
        (a) => (
          this.isComparePoint(a.value) && a.modifiers.add("critical-success"), a
        )
      ),
      r
    );
  }
}
const ts = Symbol("calculation-value"),
  vp = Symbol("is-roll-group"),
  ns = Symbol("modifiers"),
  as = Symbol("results"),
  hp = Symbol("use-in-total");
class Pr {
  constructor(r = [], t = [], a = !1, n = !0) {
    (this.isRollGroup = a),
      (this.modifiers = t),
      (this.results = r),
      (this.useInTotal = n);
  }
  get calculationValue() {
    return Er(this[ts]) ? parseFloat(this[ts]) : this.value;
  }
  set calculationValue(r) {
    const t = Er(r);
    if (r === 1 / 0)
      throw new RangeError("Results calculation value must be a finite number");
    if (r && !t)
      throw new TypeError(`Results calculation value is invalid: ${r}`);
    this[ts] = t ? parseFloat(`${r}`) : null;
  }
  get isRollGroup() {
    return this[vp];
  }
  set isRollGroup(r) {
    this[vp] = !!r;
  }
  get length() {
    return this.results.length || 0;
  }
  get modifierFlags() {
    return qd(...this.modifiers);
  }
  get modifiers() {
    return this[ns];
  }
  set modifiers(r) {
    if (
      (Array.isArray(r) || r instanceof Set) &&
      [...r].every((t) => typeof t == "string")
    )
      this[ns] = new Set([...r]);
    else if (!r && r !== 0) this[ns] = new Set();
    else
      throw new TypeError(
        `modifiers must be a Set or array of modifier names: ${r}`
      );
  }
  get results() {
    return [...this[as]];
  }
  set results(r) {
    if (!r || !Array.isArray(r))
      throw new TypeError(`results must be an array: ${r}`);
    (this[as] = []),
      r.forEach((t) => {
        this.addResult(t);
      });
  }
  get useInTotal() {
    return !!this[hp];
  }
  set useInTotal(r) {
    this[hp] = !!r;
  }
  get value() {
    if (!this.results.length) return 0;
    const r = this.results.reduce(
      (t, a) => {
        let n = a;
        return (
          a instanceof Pr
            ? (n = a.useInTotal ? a.calculationValue : 0)
            : a instanceof Jt && (n = a.value),
          t + n
        );
      },
      typeof this.results[0] == "string" ? "" : 0
    );
    return typeof r == "string" ? $d(r) : r;
  }
  addResult(r) {
    let t;
    if (r instanceof Pr || r instanceof Jt) t = r;
    else if (typeof r == "string" || Er(r)) t = r;
    else
      throw new TypeError(
        "value must be one of ResultGroup, RollResults, string, or number"
      );
    this[as].push(t);
  }
  toJSON() {
    const {
      calculationValue: r,
      isRollGroup: t,
      modifierFlags: a,
      modifiers: n,
      results: i,
      useInTotal: c,
      value: m,
    } = this;
    return {
      calculationValue: r,
      isRollGroup: t,
      modifierFlags: a,
      modifiers: [...n],
      results: i,
      type: "result-group",
      useInTotal: c,
      value: m,
    };
  }
  toString() {
    let r;
    return (
      this.isRollGroup
        ? (r = `{${this.results.join(", ")}}`)
        : (r = this.results.join("")),
      this.modifierFlags && (r = `(${r})${this.modifierFlags}`),
      r
    );
  }
}
const dp = Symbol("end"),
  gp = Symbol("qty");
class Ud extends Nn {
  constructor(r = "h", t = 1) {
    super(), (this.end = r), (this.qty = t), (this.order = 5);
  }
  get end() {
    return this[dp];
  }
  set end(r) {
    if (r !== "h" && r !== "l") throw new RangeError('End must be "h" or "l"');
    this[dp] = r;
  }
  get name() {
    return `keep-${this.end}`;
  }
  get notation() {
    return `k${this.end}${this.qty}`;
  }
  get qty() {
    return this[gp];
  }
  set qty(r) {
    if (r === 1 / 0) throw new RangeError("qty must be a finite number");
    if (!Er(r) || r < 1)
      throw new TypeError("qty must be a positive finite integer");
    this[gp] = Math.floor(r);
  }
  rangeToDrop(r) {
    return this.end === "h" ? [0, r.length - this.qty] : [this.qty, r.length];
  }
  run(r, t) {
    let a, n;
    return (
      r instanceof Pr
        ? ((a = r.results),
          a.length === 1 && a[0] instanceof Pr
            ? (n = a[0].results
                .map((i, c) =>
                  i instanceof Jt
                    ? i.rolls.map((m, f) => ({ value: m.value, index: [c, f] }))
                    : null
                )
                .flat()
                .filter(Boolean))
            : (n = [...a].map((i, c) => ({ value: i.value, index: c }))))
        : ((a = r.rolls),
          (n = [...a].map((i, c) => ({ value: i.value, index: c })))),
      (n = n
        .sort((i, c) => i.value - c.value)
        .map((i) => i.index)
        .slice(...this.rangeToDrop(n))),
      n.forEach((i) => {
        let c;
        Array.isArray(i) ? (c = a[0].results[i[0]].rolls[i[1]]) : (c = a[i]),
          c.modifiers.add("drop"),
          (c.useInTotal = !1);
      }),
      r
    );
  }
  toJSON() {
    const { end: r, qty: t } = this;
    return Object.assign(super.toJSON(), { end: r, qty: t });
  }
}
class MP extends Ud {
  constructor(r = "l", t = 1) {
    super(r, t), (this.order = 6);
  }
  get name() {
    return `drop-${this.end}`;
  }
  get notation() {
    return `d${this.end}${this.qty}`;
  }
  rangeToDrop(r) {
    return this.end === "h" ? [r.length - this.qty, r.length] : [0, this.qty];
  }
}
const yp = Symbol("max");
class AP extends Nn {
  constructor(r) {
    super(), (this.max = r), (this.order = 2);
  }
  get max() {
    return this[yp];
  }
  set max(r) {
    if (!Er(r)) throw new TypeError("max must be a number");
    this[yp] = parseFloat(`${r}`);
  }
  get name() {
    return "max";
  }
  get notation() {
    return `max${this.max}`;
  }
  run(r, t) {
    const a = r;
    return (
      (a.rolls = r.rolls.map((n) => {
        const i = n;
        return (
          n.value > this.max && ((i.value = this.max), i.modifiers.add("max")),
          i
        );
      })),
      a
    );
  }
  toJSON() {
    const { max: r } = this;
    return Object.assign(super.toJSON(), { max: r });
  }
}
const bp = Symbol("min");
class SP extends Nn {
  constructor(r) {
    super(), (this.min = r), (this.order = 1);
  }
  get min() {
    return this[bp];
  }
  set min(r) {
    if (!Er(r)) throw new TypeError("min must be a number");
    this[bp] = parseFloat(`${r}`);
  }
  get name() {
    return "min";
  }
  get notation() {
    return `min${this.min}`;
  }
  run(r, t) {
    const a = r;
    return (
      (a.rolls = r.rolls.map((n) => {
        const i = n;
        return (
          n.value < this.min && ((i.value = this.min), i.modifiers.add("min")),
          i
        );
      })),
      a
    );
  }
  toJSON() {
    const { min: r } = this;
    return Object.assign(super.toJSON(), { min: r });
  }
}
const xp = Symbol("direction");
class EP extends Nn {
  constructor(r = "a") {
    super(), (this.direction = r), (this.order = 10);
  }
  get direction() {
    return this[xp];
  }
  set direction(r) {
    if (r !== "a" && r !== "d")
      throw new RangeError(
        'Direction must be "a" (Ascending) or "d" (Descending)'
      );
    this[xp] = r;
  }
  get name() {
    return "sorting";
  }
  get notation() {
    return `s${this.direction}`;
  }
  run(r, t) {
    let a;
    return (
      r instanceof Pr ? (a = "results") : (a = "rolls"),
      (r[a] = r[a].sort((n, i) =>
        this.direction === "d" ? i.value - n.value : n.value - i.value
      )),
      r instanceof Pr &&
        (r[a] = r[a].map((n) =>
          n instanceof Pr || n instanceof Jt ? this.run(n, t) : n
        )),
      r
    );
  }
  toJSON() {
    const { direction: r } = this;
    return Object.assign(super.toJSON(), { direction: r });
  }
}
const wp = Symbol("failure-cp");
class CP extends si {
  constructor(r, t = null) {
    super(r), (this.failureComparePoint = t), (this.order = 7);
  }
  get failureComparePoint() {
    return this[wp];
  }
  set failureComparePoint(r) {
    if (r && !(r instanceof ka))
      throw new TypeError(
        "failure comparePoint must be instance of ComparePoint or null"
      );
    this[wp] = r || null;
  }
  get name() {
    return "target";
  }
  get notation() {
    return `${super.notation}${
      this.failureComparePoint ? `f${this.failureComparePoint}` : ""
    }`;
  }
  get successComparePoint() {
    return this.comparePoint;
  }
  set successComparePoint(r) {
    super.comparePoint = r;
  }
  getStateValue(r) {
    return this.isSuccess(r) ? 1 : this.isFailure(r) ? -1 : 0;
  }
  isFailure(r) {
    return this.failureComparePoint ? this.failureComparePoint.isMatch(r) : !1;
  }
  isNeutral(r) {
    return !this.isSuccess(r) && !this.isFailure(r);
  }
  isSuccess(r) {
    return this.isComparePoint(r);
  }
  run(r, t) {
    let a;
    return (
      r instanceof Pr ? (a = r.results) : (a = r.rolls),
      a.forEach((n) => {
        this.isSuccess(n.value)
          ? n.modifiers.add("target-success")
          : this.isFailure(n.value) && n.modifiers.add("target-failure"),
          (n.calculationValue = this.getStateValue(n.value));
      }),
      r
    );
  }
  toJSON() {
    const { failureComparePoint: r, successComparePoint: t } = this,
      a = super.toJSON();
    return (
      delete a.comparePoint,
      Object.assign(a, { failureComparePoint: r, successComparePoint: t })
    );
  }
}
const $P = (e) => {
    try {
      return !!(e && btoa(atob(e)) === e);
    } catch {
      return !1;
    }
  },
  OP = (e) => {
    try {
      const r = e ? JSON.parse(e) : !1;
      return !!(r && typeof r == "object");
    } catch {
      return !1;
    }
  },
  is = Symbol("modifiers"),
  os = Symbol("expressions");
class Ld {
  constructor(r = [], t = []) {
    (this.expressions = r), (this.modifiers = t);
  }
  get expressions() {
    return [...(this[os] || [])];
  }
  set expressions(r) {
    if (!r) throw new Rt("expressions");
    if (!Array.isArray(r))
      throw new TypeError(`expressions must be an array: ${r}`);
    (this[os] = []),
      r.forEach((t) => {
        if (!t || !Array.isArray(t))
          throw new TypeError(`Expressions must be an array of arrays: ${r}`);
        if (t.length === 0)
          throw new TypeError(`Sub expressions cannot be empty: ${r}`);
        if (
          !t.every(
            (a) =>
              a instanceof fa || typeof a == "string" || typeof a == "number"
          )
        )
          throw new TypeError(
            "Sub expression items must be Dice, numbers, or strings"
          );
        this[os].push(t);
      });
  }
  get modifiers() {
    return this[is]
      ? new Map([...this[is]].sort((r, t) => r[1].order - t[1].order))
      : null;
  }
  set modifiers(r) {
    let t;
    if (r instanceof Map) t = r;
    else if (Array.isArray(r)) t = new Map(r.map((a) => [a.name, a]));
    else if (typeof r == "object") t = new Map(Object.entries(r));
    else
      throw new TypeError(
        "modifiers should be a Map, array, or an Object containing Modifiers"
      );
    if (t.size && [...t.entries()].some((a) => !(a[1] instanceof Nn)))
      throw new TypeError("modifiers must only contain Modifier instances");
    this[is] = t;
  }
  get notation() {
    let r = this.expressions
      .map((t) => t.reduce((a, n) => a + n, ""))
      .join(", ");
    return (
      (r = `{${r}}`),
      this.modifiers &&
        this.modifiers.size &&
        (r += [...this.modifiers.values()].reduce(
          (t, a) => t + a.notation,
          ""
        )),
      r
    );
  }
  roll() {
    const r = new Pr(
      this.expressions.map((t) => {
        const a = t.map((n) => (n instanceof fa ? n.roll() : n));
        return new Pr(a);
      })
    );
    return (
      (r.isRollGroup = !0),
      (this.modifiers || []).forEach((t) => {
        t.run(r, this);
      }),
      r
    );
  }
  toJSON() {
    const { modifiers: r, notation: t, expressions: a } = this;
    return { expressions: a, modifiers: r, notation: t, type: "group" };
  }
  toString() {
    return this.notation;
  }
}
function TP(e, r) {
  function t() {
    this.constructor = e;
  }
  (t.prototype = r.prototype), (e.prototype = new t());
}
function ma(e, r, t, a) {
  var n = Error.call(this, e);
  return (
    Object.setPrototypeOf && Object.setPrototypeOf(n, ma.prototype),
    (n.expected = r),
    (n.found = t),
    (n.location = a),
    (n.name = "SyntaxError"),
    n
  );
}
TP(ma, Error);
function ss(e, r, t) {
  return (
    (t = t || " "),
    e.length > r ? e : ((r -= e.length), (t += t.repeat(r)), e + t.slice(0, r))
  );
}
ma.prototype.format = function (e) {
  var r = "Error: " + this.message;
  if (this.location) {
    var t = null,
      a;
    for (a = 0; a < e.length; a++)
      if (e[a].source === this.location.source) {
        t = e[a].text.split(/\r\n|\n|\r/g);
        break;
      }
    var n = this.location.start,
      i = this.location.source + ":" + n.line + ":" + n.column;
    if (t) {
      var c = this.location.end,
        m = ss("", n.line.toString().length),
        f = t[n.line - 1],
        u = n.line === c.line ? c.column : f.length + 1;
      r +=
        `
 --> ` +
        i +
        `
` +
        m +
        ` |
` +
        n.line +
        " | " +
        f +
        `
` +
        m +
        " | " +
        ss("", n.column - 1) +
        ss("", u - n.column, "^");
    } else
      r +=
        `
 at ` + i;
  }
  return r;
};
ma.buildMessage = function (e, r) {
  var t = {
    literal: function (u) {
      return '"' + n(u.text) + '"';
    },
    class: function (u) {
      var s = u.parts.map(function (o) {
        return Array.isArray(o) ? i(o[0]) + "-" + i(o[1]) : i(o);
      });
      return "[" + (u.inverted ? "^" : "") + s + "]";
    },
    any: function () {
      return "any character";
    },
    end: function () {
      return "end of input";
    },
    other: function (u) {
      return u.description;
    },
  };
  function a(u) {
    return u.charCodeAt(0).toString(16).toUpperCase();
  }
  function n(u) {
    return u
      .replace(/\\/g, "\\\\")
      .replace(/"/g, '\\"')
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g, function (s) {
        return "\\x0" + a(s);
      })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (s) {
        return "\\x" + a(s);
      });
  }
  function i(u) {
    return u
      .replace(/\\/g, "\\\\")
      .replace(/\]/g, "\\]")
      .replace(/\^/g, "\\^")
      .replace(/-/g, "\\-")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g, function (s) {
        return "\\x0" + a(s);
      })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (s) {
        return "\\x" + a(s);
      });
  }
  function c(u) {
    return t[u.type](u);
  }
  function m(u) {
    var s = u.map(c),
      o,
      l;
    if ((s.sort(), s.length > 0)) {
      for (o = 1, l = 1; o < s.length; o++)
        s[o - 1] !== s[o] && ((s[l] = s[o]), l++);
      s.length = l;
    }
    switch (s.length) {
      case 1:
        return s[0];
      case 2:
        return s[0] + " or " + s[1];
      default:
        return s.slice(0, -1).join(", ") + ", or " + s[s.length - 1];
    }
  }
  function f(u) {
    return u ? '"' + n(u) + '"' : "end of input";
  }
  return "Expected " + m(e) + " but " + f(r) + " found.";
};
function DP(e, r) {
  r = r !== void 0 ? r : {};
  var t = {},
    a = r.grammarSource,
    n = { Main: Ru },
    i = Ru,
    c = "{",
    m = ",",
    f = "}",
    u = "d",
    s = "d%",
    o = "dF",
    l = ".",
    p = "!",
    v = "p",
    h = "k",
    x = "max",
    b = "min",
    N = "r",
    d = "o",
    y = "cs",
    w = "cf",
    g = "s",
    S = "a",
    A = "f",
    E = "!=",
    M = "<=",
    B = ">=",
    C = "=",
    _ = "<>",
    z = ">",
    I = "<",
    T = "(",
    D = ")",
    Z = "abs",
    O = "ceil",
    H = "cos",
    Q = "exp",
    te = "floor",
    J = "log",
    re = "round",
    oe = "sign",
    ae = "sin",
    ce = "sqrt",
    se = "tan",
    pe = "pow",
    ne = "-",
    Ae = "**",
    Ce = "*",
    ge = "^",
    Se = "%",
    q = "/",
    Y = "+",
    V = /^[12]/,
    L = /^[lh]/,
    j = /^[.]/,
    F = /^[1-9]/,
    U = /^[0-9]/,
    ee = /^[ \t\n\r]/,
    k = Le("{", !1),
    me = Le(",", !1),
    he = Le("}", !1),
    Me = Le("d", !1),
    be = Le("d%", !1),
    xe = Le("dF", !1),
    Te = Le(".", !1),
    or = Gn(["1", "2"], !1, !1),
    br = Le("!", !1),
    mr = Le("p", !1),
    Jr = Gn(["l", "h"], !1, !1),
    Wr = Le("k", !1),
    ot = Le("max", !1),
    rr = Le("min", !1),
    $t = Le("r", !1),
    $ = Le("o", !1),
    X = Le("cs", !1),
    ue = Le("cf", !1),
    we = Le("s", !1),
    ke = Le("a", !1),
    Ye = Le("f", !1),
    Or = Le("!=", !1),
    Ca = Le("<=", !1),
    wo = Le(">=", !1),
    No = Le("=", !1),
    Mo = Le("<>", !1),
    Ao = Le(">", !1),
    So = Le("<", !1),
    kn = Le("(", !1),
    Vn = Le(")", !1),
    Eo = Le("abs", !1),
    Co = Le("ceil", !1),
    $o = Le("cos", !1),
    Oo = Le("exp", !1),
    To = Le("floor", !1),
    Do = Le("log", !1),
    Bo = Le("round", !1),
    $a = Le("sign", !1),
    dr = Le("sin", !1),
    _r = Le("sqrt", !1),
    st = Le("tan", !1),
    Wd = Le("pow", !1),
    Tu = Le("-", !1),
    Xd = Gn(["."], !1, !1),
    Yd = Gn([["1", "9"]], !1, !1),
    ui = Gn([["0", "9"]], !1, !1),
    Qd = Le("**", !1),
    jd = Le("*", !1),
    Kd = Le("^", !1),
    eg = Le("%", !1),
    rg = Le("/", !1),
    tg = Le("+", !1),
    ng = Og("whitespace"),
    Du = Gn(
      [
        " ",
        "	",
        `
`,
        "\r",
      ],
      !1,
      !1
    ),
    ag = function (R, K, ie) {
      return new Ld(
        [R, ...K.map((de) => de[3])],
        Object.assign({}, ...ie.map((de) => ({ [de.name]: de })))
      );
    },
    ig = function (R, K) {
      return (
        (R.modifiers = Object.assign(
          {},
          ...K.map((ie) => ({ [ie.name]: ie }))
        )),
        R
      );
    },
    og = function (R, K) {
      return new fa(K, R || 1);
    },
    sg = function (R) {
      return new xP(R || 1);
    },
    ug = function (R, K) {
      return new bP(K ? parseInt(K[1], 10) : 2, R || 1);
    },
    lg = function (R, K, ie) {
      return new Pd(ie, !!R, !!K);
    },
    cg = function (R, K) {
      return new CP(R, K);
    },
    fg = function (R, K) {
      return new MP(R || "l", K);
    },
    mg = function (R, K) {
      return new Ud(R || "h", K);
    },
    pg = function (R) {
      return new AP(R);
    },
    vg = function (R) {
      return new SP(R);
    },
    hg = function (R, K) {
      return new zd(!!R, K);
    },
    dg = function (R) {
      return new NP(R);
    },
    gg = function (R) {
      return new wP(R);
    },
    yg = function (R) {
      return new EP(R || "a");
    },
    bg = function (R) {
      return R;
    },
    xg = function (R, K) {
      return new ka(R, K);
    },
    wg = function (R, K, ie) {
      return $d(Io());
    },
    Ng = function (R, K) {
      return (
        (R = Array.isArray(R) ? R : [R]),
        [...R, ...K.map(([, ie, , de]) => [ie, de]).flat(2)]
      );
    },
    Mg = function (R, K, ie) {
      return [R, ...K, ie];
    },
    Ag = function (R, K) {
      return [`${R}(`, ...K, ")"];
    },
    Sg = function (R, K, ie) {
      return [`${R}(`, ...K, ",", ...ie, ")"];
    },
    Eg = function () {
      return parseFloat(Io());
    },
    Bu = function () {
      return parseInt(Io(), 10);
    },
    Cg = function () {
      return "^";
    },
    G = 0,
    gr = 0,
    li = [{ line: 1, column: 1 }],
    Ot = 0,
    _o = [],
    Ee = 0,
    ci;
  if ("startRule" in r) {
    if (!(r.startRule in n))
      throw new Error(`Can't start parsing from rule "` + r.startRule + '".');
    i = n[r.startRule];
  }
  function Io() {
    return e.substring(gr, G);
  }
  function Le(R, K) {
    return { type: "literal", text: R, ignoreCase: K };
  }
  function Gn(R, K, ie) {
    return { type: "class", parts: R, inverted: K, ignoreCase: ie };
  }
  function $g() {
    return { type: "end" };
  }
  function Og(R) {
    return { type: "other", description: R };
  }
  function _u(R) {
    var K = li[R],
      ie;
    if (K) return K;
    for (ie = R - 1; !li[ie]; ) ie--;
    for (K = li[ie], K = { line: K.line, column: K.column }; ie < R; )
      e.charCodeAt(ie) === 10 ? (K.line++, (K.column = 1)) : K.column++, ie++;
    return (li[R] = K), K;
  }
  function Iu(R, K) {
    var ie = _u(R),
      de = _u(K);
    return {
      source: a,
      start: { offset: R, line: ie.line, column: ie.column },
      end: { offset: K, line: de.line, column: de.column },
    };
  }
  function $e(R) {
    G < Ot || (G > Ot && ((Ot = G), (_o = [])), _o.push(R));
  }
  function Tg(R, K, ie) {
    return new ma(ma.buildMessage(R, K), R, K, ie);
  }
  function Ru() {
    var R;
    return (R = on()), R;
  }
  function Dg() {
    var R, K, ie, de, _e, He, ur, Sr, dt;
    if (
      ((R = G),
      e.charCodeAt(G) === 123 ? ((K = c), G++) : ((K = t), Ee === 0 && $e(k)),
      K !== t)
    )
      if ((wr(), (ie = on()), ie !== t)) {
        for (
          de = [],
            _e = G,
            He = wr(),
            e.charCodeAt(G) === 44
              ? ((ur = m), G++)
              : ((ur = t), Ee === 0 && $e(me)),
            ur !== t
              ? ((Sr = wr()),
                (dt = on()),
                dt !== t
                  ? ((He = [He, ur, Sr, dt]), (_e = He))
                  : ((G = _e), (_e = t)))
              : ((G = _e), (_e = t));
          _e !== t;

        )
          de.push(_e),
            (_e = G),
            (He = wr()),
            e.charCodeAt(G) === 44
              ? ((ur = m), G++)
              : ((ur = t), Ee === 0 && $e(me)),
            ur !== t
              ? ((Sr = wr()),
                (dt = on()),
                dt !== t
                  ? ((He = [He, ur, Sr, dt]), (_e = He))
                  : ((G = _e), (_e = t)))
              : ((G = _e), (_e = t));
        if (
          ((_e = wr()),
          e.charCodeAt(G) === 125
            ? ((He = f), G++)
            : ((He = t), Ee === 0 && $e(he)),
          He !== t)
        ) {
          for (ur = [], Sr = fi(); Sr !== t; ) ur.push(Sr), (Sr = fi());
          (gr = R), (R = ag(ie, de, ur));
        } else (G = R), (R = t);
      } else (G = R), (R = t);
    else (G = R), (R = t);
    return R;
  }
  function Bg() {
    var R, K, ie, de;
    if (
      ((R = G),
      (K = _g()),
      K === t && ((K = Ig()), K === t && (K = Rg())),
      K !== t)
    ) {
      for (ie = [], de = fi(); de !== t; ) ie.push(de), (de = fi());
      (gr = R), (R = ig(K, ie));
    } else (G = R), (R = t);
    return R;
  }
  function _g() {
    var R, K, ie, de;
    return (
      (R = G),
      (K = mi()),
      K === t && (K = null),
      e.charCodeAt(G) === 100
        ? ((ie = u), G++)
        : ((ie = t), Ee === 0 && $e(Me)),
      ie !== t
        ? ((de = mi()),
          de !== t ? ((gr = R), (R = og(K, de))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Ig() {
    var R, K, ie;
    return (
      (R = G),
      (K = mi()),
      K === t && (K = null),
      e.substr(G, 2) === s
        ? ((ie = s), (G += 2))
        : ((ie = t), Ee === 0 && $e(be)),
      ie !== t ? ((gr = R), (R = sg(K))) : ((G = R), (R = t)),
      R
    );
  }
  function Rg() {
    var R, K, ie, de, _e, He;
    return (
      (R = G),
      (K = mi()),
      K === t && (K = null),
      e.substr(G, 2) === o
        ? ((ie = o), (G += 2))
        : ((ie = t), Ee === 0 && $e(xe)),
      ie !== t
        ? ((de = G),
          e.charCodeAt(G) === 46
            ? ((_e = l), G++)
            : ((_e = t), Ee === 0 && $e(Te)),
          _e !== t
            ? (V.test(e.charAt(G))
                ? ((He = e.charAt(G)), G++)
                : ((He = t), Ee === 0 && $e(or)),
              He !== t ? ((_e = [_e, He]), (de = _e)) : ((G = de), (de = t)))
            : ((G = de), (de = t)),
          de === t && (de = null),
          (gr = R),
          (R = ug(K, de)))
        : ((G = R), (R = t)),
      R
    );
  }
  function fi() {
    var R;
    return (
      (R = Fg()),
      R === t &&
        ((R = Pg()),
        R === t &&
          ((R = qg()),
          R === t &&
            ((R = zg()),
            R === t &&
              ((R = kg()),
              R === t &&
                ((R = Vg()),
                R === t &&
                  ((R = Gg()),
                  R === t &&
                    ((R = Hg()),
                    R === t && ((R = Ug()), R === t && (R = Lg()))))))))),
      R
    );
  }
  function Fg() {
    var R, K, ie, de, _e;
    return (
      (R = G),
      e.charCodeAt(G) === 33 ? ((K = p), G++) : ((K = t), Ee === 0 && $e(br)),
      K !== t
        ? (e.charCodeAt(G) === 33
            ? ((ie = p), G++)
            : ((ie = t), Ee === 0 && $e(br)),
          ie === t && (ie = null),
          e.charCodeAt(G) === 112
            ? ((de = v), G++)
            : ((de = t), Ee === 0 && $e(mr)),
          de === t && (de = null),
          (_e = Hn()),
          _e === t && (_e = null),
          (gr = R),
          (R = lg(ie, de, _e)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Pg() {
    var R, K, ie;
    return (
      (R = G),
      (K = Hn()),
      K !== t
        ? ((ie = Zg()), ie === t && (ie = null), (gr = R), (R = cg(K, ie)))
        : ((G = R), (R = t)),
      R
    );
  }
  function qg() {
    var R, K, ie, de;
    return (
      (R = G),
      e.charCodeAt(G) === 100 ? ((K = u), G++) : ((K = t), Ee === 0 && $e(Me)),
      K !== t
        ? (L.test(e.charAt(G))
            ? ((ie = e.charAt(G)), G++)
            : ((ie = t), Ee === 0 && $e(Jr)),
          ie === t && (ie = null),
          (de = Fo()),
          de !== t ? ((gr = R), (R = fg(ie, de))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function zg() {
    var R, K, ie, de;
    return (
      (R = G),
      e.charCodeAt(G) === 107 ? ((K = h), G++) : ((K = t), Ee === 0 && $e(Wr)),
      K !== t
        ? (L.test(e.charAt(G))
            ? ((ie = e.charAt(G)), G++)
            : ((ie = t), Ee === 0 && $e(Jr)),
          ie === t && (ie = null),
          (de = Fo()),
          de !== t ? ((gr = R), (R = mg(ie, de))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Ug() {
    var R, K, ie;
    return (
      (R = G),
      e.substr(G, 3) === x
        ? ((K = x), (G += 3))
        : ((K = t), Ee === 0 && $e(ot)),
      K !== t
        ? ((ie = Mn()),
          ie !== t ? ((gr = R), (R = pg(ie))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Lg() {
    var R, K, ie;
    return (
      (R = G),
      e.substr(G, 3) === b
        ? ((K = b), (G += 3))
        : ((K = t), Ee === 0 && $e(rr)),
      K !== t
        ? ((ie = Mn()),
          ie !== t ? ((gr = R), (R = vg(ie))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function kg() {
    var R, K, ie, de;
    return (
      (R = G),
      e.charCodeAt(G) === 114 ? ((K = N), G++) : ((K = t), Ee === 0 && $e($t)),
      K !== t
        ? (e.charCodeAt(G) === 111
            ? ((ie = d), G++)
            : ((ie = t), Ee === 0 && $e($)),
          ie === t && (ie = null),
          (de = Hn()),
          de === t && (de = null),
          (gr = R),
          (R = hg(ie, de)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Vg() {
    var R, K, ie;
    return (
      (R = G),
      e.substr(G, 2) === y ? ((K = y), (G += 2)) : ((K = t), Ee === 0 && $e(X)),
      K !== t
        ? ((ie = Hn()),
          ie !== t ? ((gr = R), (R = dg(ie))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Gg() {
    var R, K, ie;
    return (
      (R = G),
      e.substr(G, 2) === w
        ? ((K = w), (G += 2))
        : ((K = t), Ee === 0 && $e(ue)),
      K !== t
        ? ((ie = Hn()),
          ie !== t ? ((gr = R), (R = gg(ie))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Hg() {
    var R, K, ie;
    return (
      (R = G),
      e.charCodeAt(G) === 115 ? ((K = g), G++) : ((K = t), Ee === 0 && $e(we)),
      K !== t
        ? (e.charCodeAt(G) === 97
            ? ((ie = S), G++)
            : ((ie = t), Ee === 0 && $e(ke)),
          ie === t &&
            (e.charCodeAt(G) === 100
              ? ((ie = u), G++)
              : ((ie = t), Ee === 0 && $e(Me))),
          ie === t && (ie = null),
          (gr = R),
          (R = yg(ie)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Zg() {
    var R, K, ie;
    return (
      (R = G),
      e.charCodeAt(G) === 102 ? ((K = A), G++) : ((K = t), Ee === 0 && $e(Ye)),
      K !== t
        ? ((ie = Hn()),
          ie !== t ? ((gr = R), (R = bg(ie))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Hn() {
    var R, K, ie;
    return (
      (R = G),
      (K = Jg()),
      K !== t
        ? ((ie = Mn()),
          ie !== t ? ((gr = R), (R = xg(K, ie))) : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R
    );
  }
  function Jg() {
    var R;
    return (
      e.substr(G, 2) === E
        ? ((R = E), (G += 2))
        : ((R = t), Ee === 0 && $e(Or)),
      R === t &&
        (e.substr(G, 2) === M
          ? ((R = M), (G += 2))
          : ((R = t), Ee === 0 && $e(Ca)),
        R === t &&
          (e.substr(G, 2) === B
            ? ((R = B), (G += 2))
            : ((R = t), Ee === 0 && $e(wo)),
          R === t &&
            (e.charCodeAt(G) === 61
              ? ((R = C), G++)
              : ((R = t), Ee === 0 && $e(No)),
            R === t &&
              (e.substr(G, 2) === _
                ? ((R = _), (G += 2))
                : ((R = t), Ee === 0 && $e(Mo)),
              R === t &&
                (e.charCodeAt(G) === 62
                  ? ((R = z), G++)
                  : ((R = t), Ee === 0 && $e(Ao)),
                R === t &&
                  (e.charCodeAt(G) === 60
                    ? ((R = I), G++)
                    : ((R = t), Ee === 0 && $e(So)))))))),
      R
    );
  }
  function mi() {
    var R, K, ie, de, _e, He, ur, Sr, dt, Zn;
    if (((R = Fo()), R === t))
      if (
        ((R = G),
        e.charCodeAt(G) === 40 ? ((K = T), G++) : ((K = t), Ee === 0 && $e(kn)),
        K !== t)
      ) {
        if ((wr(), (ie = G), (de = Mn()), de !== t)) {
          if (
            ((_e = []),
            (He = G),
            (ur = wr()),
            (Sr = pi()),
            Sr !== t
              ? ((dt = wr()),
                (Zn = Mn()),
                Zn !== t
                  ? ((ur = [ur, Sr, dt, Zn]), (He = ur))
                  : ((G = He), (He = t)))
              : ((G = He), (He = t)),
            He !== t)
          )
            for (; He !== t; )
              _e.push(He),
                (He = G),
                (ur = wr()),
                (Sr = pi()),
                Sr !== t
                  ? ((dt = wr()),
                    (Zn = Mn()),
                    Zn !== t
                      ? ((ur = [ur, Sr, dt, Zn]), (He = ur))
                      : ((G = He), (He = t)))
                  : ((G = He), (He = t));
          else _e = t;
          _e !== t ? ((de = [de, _e]), (ie = de)) : ((G = ie), (ie = t));
        } else (G = ie), (ie = t);
        ie !== t
          ? ((de = wr()),
            e.charCodeAt(G) === 41
              ? ((_e = D), G++)
              : ((_e = t), Ee === 0 && $e(Vn)),
            _e !== t ? ((gr = R), (R = wg())) : ((G = R), (R = t)))
          : ((G = R), (R = t));
      } else (G = R), (R = t);
    return R;
  }
  function on() {
    var R, K, ie, de, _e, He, ur, Sr;
    if (((R = G), (K = Ro()), K !== t)) {
      for (
        ie = [],
          de = G,
          _e = wr(),
          He = pi(),
          He !== t
            ? ((ur = wr()),
              (Sr = Ro()),
              Sr !== t
                ? ((_e = [_e, He, ur, Sr]), (de = _e))
                : ((G = de), (de = t)))
            : ((G = de), (de = t));
        de !== t;

      )
        ie.push(de),
          (de = G),
          (_e = wr()),
          (He = pi()),
          He !== t
            ? ((ur = wr()),
              (Sr = Ro()),
              Sr !== t
                ? ((_e = [_e, He, ur, Sr]), (de = _e))
                : ((G = de), (de = t)))
            : ((G = de), (de = t));
      (gr = R), (R = Ng(K, ie));
    } else (G = R), (R = t);
    return R;
  }
  function Ro() {
    var R, K, ie, de;
    return (
      (R = Wg()),
      R === t &&
        ((R = Bg()),
        R === t &&
          ((R = Mn()),
          R === t &&
            ((R = G),
            e.charCodeAt(G) === 40
              ? ((K = T), G++)
              : ((K = t), Ee === 0 && $e(kn)),
            K !== t
              ? (wr(),
                (ie = on()),
                ie !== t
                  ? (wr(),
                    e.charCodeAt(G) === 41
                      ? ((de = D), G++)
                      : ((de = t), Ee === 0 && $e(Vn)),
                    de !== t
                      ? ((gr = R), (R = Mg(K, ie, de)))
                      : ((G = R), (R = t)))
                  : ((G = R), (R = t)))
              : ((G = R), (R = t)),
            R === t && (R = Dg())))),
      R
    );
  }
  function Wg() {
    var R, K, ie, de, _e, He, ur;
    return (
      (R = G),
      e.substr(G, 3) === Z
        ? ((K = Z), (G += 3))
        : ((K = t), Ee === 0 && $e(Eo)),
      K === t &&
        (e.substr(G, 4) === O
          ? ((K = O), (G += 4))
          : ((K = t), Ee === 0 && $e(Co)),
        K === t &&
          (e.substr(G, 3) === H
            ? ((K = H), (G += 3))
            : ((K = t), Ee === 0 && $e($o)),
          K === t &&
            (e.substr(G, 3) === Q
              ? ((K = Q), (G += 3))
              : ((K = t), Ee === 0 && $e(Oo)),
            K === t &&
              (e.substr(G, 5) === te
                ? ((K = te), (G += 5))
                : ((K = t), Ee === 0 && $e(To)),
              K === t &&
                (e.substr(G, 3) === J
                  ? ((K = J), (G += 3))
                  : ((K = t), Ee === 0 && $e(Do)),
                K === t &&
                  (e.substr(G, 5) === re
                    ? ((K = re), (G += 5))
                    : ((K = t), Ee === 0 && $e(Bo)),
                  K === t &&
                    (e.substr(G, 4) === oe
                      ? ((K = oe), (G += 4))
                      : ((K = t), Ee === 0 && $e($a)),
                    K === t &&
                      (e.substr(G, 3) === ae
                        ? ((K = ae), (G += 3))
                        : ((K = t), Ee === 0 && $e(dr)),
                      K === t &&
                        (e.substr(G, 4) === ce
                          ? ((K = ce), (G += 4))
                          : ((K = t), Ee === 0 && $e(_r)),
                        K === t &&
                          (e.substr(G, 3) === se
                            ? ((K = se), (G += 3))
                            : ((K = t), Ee === 0 && $e(st)))))))))))),
      K !== t
        ? (e.charCodeAt(G) === 40
            ? ((ie = T), G++)
            : ((ie = t), Ee === 0 && $e(kn)),
          ie !== t
            ? (wr(),
              (de = on()),
              de !== t
                ? (wr(),
                  e.charCodeAt(G) === 41
                    ? ((_e = D), G++)
                    : ((_e = t), Ee === 0 && $e(Vn)),
                  _e !== t ? ((gr = R), (R = Ag(K, de))) : ((G = R), (R = t)))
                : ((G = R), (R = t)))
            : ((G = R), (R = t)))
        : ((G = R), (R = t)),
      R === t &&
        ((R = G),
        e.substr(G, 3) === pe
          ? ((K = pe), (G += 3))
          : ((K = t), Ee === 0 && $e(Wd)),
        K === t &&
          (e.substr(G, 3) === x
            ? ((K = x), (G += 3))
            : ((K = t), Ee === 0 && $e(ot)),
          K === t &&
            (e.substr(G, 3) === b
              ? ((K = b), (G += 3))
              : ((K = t), Ee === 0 && $e(rr)))),
        K !== t
          ? (e.charCodeAt(G) === 40
              ? ((ie = T), G++)
              : ((ie = t), Ee === 0 && $e(kn)),
            ie !== t
              ? (wr(),
                (de = on()),
                de !== t
                  ? (wr(),
                    e.charCodeAt(G) === 44
                      ? ((_e = m), G++)
                      : ((_e = t), Ee === 0 && $e(me)),
                    _e !== t
                      ? (wr(),
                        (He = on()),
                        He !== t
                          ? (wr(),
                            e.charCodeAt(G) === 41
                              ? ((ur = D), G++)
                              : ((ur = t), Ee === 0 && $e(Vn)),
                            ur !== t
                              ? ((gr = R), (R = Sg(K, de, He)))
                              : ((G = R), (R = t)))
                          : ((G = R), (R = t)))
                      : ((G = R), (R = t)))
                  : ((G = R), (R = t)))
              : ((G = R), (R = t)))
          : ((G = R), (R = t))),
      R
    );
  }
  function Mn() {
    var R, K, ie, de, _e;
    return (
      (R = G),
      e.charCodeAt(G) === 45 ? G++ : Ee === 0 && $e(Tu),
      (K = Fu()),
      K !== t
        ? ((ie = G),
          j.test(e.charAt(G))
            ? ((de = e.charAt(G)), G++)
            : ((de = t), Ee === 0 && $e(Xd)),
          de !== t
            ? ((_e = Fu()),
              _e !== t ? ((de = [de, _e]), (ie = de)) : ((G = ie), (ie = t)))
            : ((G = ie), (ie = t)),
          ie === t && (ie = null),
          (gr = R),
          (R = Eg()))
        : ((G = R), (R = t)),
      R
    );
  }
  function Fo() {
    var R, K, ie, de;
    if (
      ((R = G),
      F.test(e.charAt(G))
        ? ((K = e.charAt(G)), G++)
        : ((K = t), Ee === 0 && $e(Yd)),
      K !== t)
    ) {
      for (
        ie = [],
          U.test(e.charAt(G))
            ? ((de = e.charAt(G)), G++)
            : ((de = t), Ee === 0 && $e(ui));
        de !== t;

      )
        ie.push(de),
          U.test(e.charAt(G))
            ? ((de = e.charAt(G)), G++)
            : ((de = t), Ee === 0 && $e(ui));
      (gr = R), (R = Bu());
    } else (G = R), (R = t);
    return R;
  }
  function Fu() {
    var R, K, ie;
    if (
      ((R = G),
      (K = []),
      U.test(e.charAt(G))
        ? ((ie = e.charAt(G)), G++)
        : ((ie = t), Ee === 0 && $e(ui)),
      ie !== t)
    )
      for (; ie !== t; )
        K.push(ie),
          U.test(e.charAt(G))
            ? ((ie = e.charAt(G)), G++)
            : ((ie = t), Ee === 0 && $e(ui));
    else K = t;
    return K !== t && ((gr = R), (K = Bu())), (R = K), R;
  }
  function pi() {
    var R, K;
    return (
      (R = G),
      e.substr(G, 2) === Ae
        ? ((K = Ae), (G += 2))
        : ((K = t), Ee === 0 && $e(Qd)),
      K !== t && ((gr = R), (K = Cg())),
      (R = K),
      R === t &&
        (e.charCodeAt(G) === 42
          ? ((R = Ce), G++)
          : ((R = t), Ee === 0 && $e(jd)),
        R === t &&
          (e.charCodeAt(G) === 94
            ? ((R = ge), G++)
            : ((R = t), Ee === 0 && $e(Kd)),
          R === t &&
            (e.charCodeAt(G) === 37
              ? ((R = Se), G++)
              : ((R = t), Ee === 0 && $e(eg)),
            R === t &&
              (e.charCodeAt(G) === 47
                ? ((R = q), G++)
                : ((R = t), Ee === 0 && $e(rg)),
              R === t &&
                (e.charCodeAt(G) === 43
                  ? ((R = Y), G++)
                  : ((R = t), Ee === 0 && $e(tg)),
                R === t &&
                  (e.charCodeAt(G) === 45
                    ? ((R = ne), G++)
                    : ((R = t), Ee === 0 && $e(Tu)))))))),
      R
    );
  }
  function wr() {
    var R, K;
    for (
      Ee++,
        R = [],
        ee.test(e.charAt(G))
          ? ((K = e.charAt(G)), G++)
          : ((K = t), Ee === 0 && $e(Du));
      K !== t;

    )
      R.push(K),
        ee.test(e.charAt(G))
          ? ((K = e.charAt(G)), G++)
          : ((K = t), Ee === 0 && $e(Du));
    return Ee--, (K = t), Ee === 0 && $e(ng), R;
  }
  if (((ci = i()), ci !== t && G === e.length)) return ci;
  throw (
    (ci !== t && G < e.length && $e($g()),
    Tg(
      _o,
      Ot < e.length ? e.charAt(Ot) : null,
      Ot < e.length ? Iu(Ot, Ot + 1) : Iu(Ot, Ot)
    ))
  );
}
class Np {
  static parse(r) {
    if (!r) throw new Rt("notation");
    if (typeof r != "string") throw new TypeError("Notation must be a string");
    return DP(r);
  }
}
const Kn = Object.freeze({ BASE_64: 1, JSON: 0, OBJECT: 2 }),
  us = Symbol("notation"),
  ls = Symbol("maxTotal"),
  cs = Symbol("minTotal"),
  ea = Symbol("expressions"),
  Ni = Symbol("roll-method"),
  sn = Symbol("rolls"),
  Mp = Symbol("set-rolls"),
  Mi = Symbol("total"),
  fs = (e) => z6(e.calculationValue, 2);
class yt {
  constructor(r) {
    if (!r) throw new Rt("notation");
    if (((this[ea] = []), r instanceof Object && !Array.isArray(r))) {
      if (r.notation) {
        if (typeof r.notation != "string") throw new Ui(r.notation);
        r.rolls && this[Mp](r.rolls);
      } else throw new Rt("notation");
      (this[us] = r.notation),
        (this[ea] = Np.parse(this.notation)),
        this.hasRolls() || this.roll();
    } else if (typeof r == "string")
      (this[us] = r), (this[ea] = Np.parse(this.notation)), this.roll();
    else throw new Ui(r);
  }
  get averageTotal() {
    return (this.maxTotal + this.minTotal) / 2;
  }
  get maxTotal() {
    if (!this.hasExpressions()) return 0;
    if (!this[ls]) {
      const r = this[Ni](tp.max);
      this[ls] = fs(r);
    }
    return this[ls];
  }
  get minTotal() {
    if (!this.hasExpressions()) return 0;
    if (!this[cs]) {
      const r = this[Ni](tp.min);
      this[cs] = fs(r);
    }
    return this[cs];
  }
  get notation() {
    return this[us];
  }
  get output() {
    let r = `${this.notation}: `;
    return (
      this.hasRolls()
        ? (r += `${this[sn]} = ${this.total}`)
        : (r += "No dice rolled"),
      r
    );
  }
  get rolls() {
    return this[sn] ? this[sn].results : [];
  }
  get total() {
    return (
      !this[Mi] && this.hasRolls() && (this[Mi] = fs(this[sn])), this[Mi] || 0
    );
  }
  export(r = Kn.JSON) {
    switch (r) {
      case Kn.BASE_64:
        return btoa(this.export(Kn.JSON));
      case Kn.JSON:
        return JSON.stringify(this);
      case Kn.OBJECT:
        return JSON.parse(this.export(Kn.JSON));
      default:
        throw new TypeError(`Invalid export format "${r}"`);
    }
  }
  hasExpressions() {
    return this[ea] && this[ea].length > 0;
  }
  hasRolls() {
    return this.hasExpressions() && this.rolls.length > 0;
  }
  roll() {
    return (this[Mi] = 0), (this[sn] = this[Ni]()), this.rolls;
  }
  toJSON() {
    const {
      averageTotal: r,
      maxTotal: t,
      minTotal: a,
      notation: n,
      output: i,
      rolls: c,
      total: m,
    } = this;
    return {
      averageTotal: r,
      maxTotal: t,
      minTotal: a,
      notation: n,
      output: i,
      rolls: c,
      total: m,
      type: "dice-roll",
    };
  }
  toString() {
    return this.output;
  }
  static import(r) {
    if (r) {
      if (OP(r)) return yt.import(JSON.parse(r));
      if ($P(r)) return yt.import(atob(r));
      if (typeof r == "object") return new yt(r);
      throw new Eu(r);
    } else throw new Rt("data");
  }
  [Ni](r) {
    let t;
    r && ((t = ia.engine), (ia.engine = r));
    const a = new Pr(
      this[ea]
        .map((n) => (n instanceof fa || n instanceof Ld ? n.roll() : n))
        .filter((n) => !!n || n === 0)
    );
    return r && (ia.engine = t), a;
  }
  [Mp](r) {
    if (r instanceof Pr) this[sn] = r;
    else if (r instanceof Jt) this[sn] = new Pr([r]);
    else if (Array.isArray(r))
      this[sn] = new Pr(
        r.map((t) => {
          if (t instanceof Pr || t instanceof Jt) return t;
          if (Array.isArray(t)) return new Jt(t);
          if (typeof t == "object") {
            if (Array.isArray(t.results))
              return new Pr(
                t.results,
                t.modifiers || [],
                t.isRollGroup || !1,
                typeof t.useInTotal == "boolean" ? t.useInTotal : !0
              );
            if (Array.isArray(t.rolls)) return new Jt(t.rolls);
          }
          return t;
        })
      );
    else
      throw new TypeError("Rolls must be a valid result object, or an array");
  }
}
const Iq = {
    name: "",
    player: "",
    attributes: { str: 0, dex: 0, int: 0, con: 0, pre: 0 },
    backgroundName: "",
    className: "",
    nex: "",
    movement: 9,
    maxPv: 0,
    currentPv: 0,
    maxPe: 0,
    currentPe: 0,
    maxSan: 0,
    currentSan: 0,
    maxPd: 0,
    currentPd: 0,
    nexString: "0%",
    isSobrevivendoAoHorror: !1,
    protectionDefense: 0,
    bonusDefense: 0,
    currentProtection: "",
    resistances: "",
    proficiencies: "",
    skills: ty,
    attacks: [],
    powers: [],
    rituals: [],
    ritualsDc: 0,
    patent: "",
    prestigePoints: 0,
    inventory: [],
    itemsLimit: { I: 0, II: 0, III: 0, IV: 0 },
    currentItemsLimit: { I: 0, II: 0, III: 0, IV: 0 },
    creditsLimit: "",
    maxLoad: 0,
    currentLoad: 0,
    description: {
      anotation: "",
      physical: "",
      personal: "",
      history: "",
      goal: "",
    },
    deathMarks: [],
    madnessMarks: [],
    deathMode: !1,
    madnessMode: !1,
    sheetPictureURL: "",
    sheetPictureFullPath: "",
    statsClass: "Combatant",
    canDMEdit: !0,
    canAnyoneEdit: !1,
    block: null,
    evade: null,
    private: !1,
    campaignDocId: "",
    resistencias: {},
    imunidades: [],
    vulnerabilidades: [],
    skinDice: ny[0],
    pdMarks: [],
    pdMode: !1,
    isNexLevelOn: !1,
    isPdOn: !1,
  },
  BP = {
    name: "New Attack",
    attackBonus: 0,
    damage: "1d4",
    extraDamage: "0",
    criticalRange: 20,
    criticalMult: 2,
    damageType: "-",
    range: "-",
    skillUsed: "Fighting",
    damageAttribute: "Strength",
  },
  Rq = {
    str: "Strength",
    dex: "Agility",
    int: "Intellect",
    con: "Vigor",
    pre: "Presence",
  },
  Vi = [
    "5%",
    "10%",
    "15%",
    "20%",
    "25%",
    "30%",
    "35%",
    "40%",
    "45%",
    "50%",
    "55%",
    "60%",
    "65%",
    "70%",
    "75%",
    "80%",
    "85%",
    "90%",
    "95%",
    "99%",
  ],
  Ap = {
    "5%": "1",
    "10%": "2",
    "15%": "3",
    "20%": "4",
    "25%": "5",
    "30%": "6",
    "35%": "7",
    "40%": "8",
    "45%": "9",
    "50%": "10",
    "55%": "11",
    "60%": "12",
    "65%": "13",
    "70%": "14",
    "75%": "15",
    "80%": "16",
    "85%": "17",
    "90%": "18",
    "95%": "19",
    "99%": "20",
  },
  kd = { STR: "str", AGI: "dex", INT: "int", PRE: "pre", VIG: "con" },
  Sp = {
    Strength: "str",
    Agility: "dex",
    Intellect: "int",
    Vigor: "con",
    Presence: "pre",
  },
  _P = {
    Strength: "STR",
    Agility: "AGI",
    Intellect: "INT",
    Vigor: "VIG",
    Presence: "PRE",
  },
  Ep = {
    "5%": 1,
    "10%": 2,
    "15%": 3,
    "20%": 4,
    "25%": 5,
    "30%": 6,
    "35%": 7,
    "40%": 8,
    "45%": 9,
    "50%": 10,
    "55%": 11,
    "60%": 12,
    "65%": 13,
    "70%": 14,
    "75%": 15,
    "80%": 16,
    "85%": 17,
    "90%": 18,
    "95%": 19,
    "99%": 20,
  },
  _t = (e, r, t = !0, a = !0) => {
    const n = { 1: 9, 2: 99, 3: 999, 4: 9999 },
      i = { 1: -9, 2: -99, 3: -999, 4: -9999 };
    return (
      isNaN(e) && (e = 0),
      e > n[r] && (e = n[r]),
      a ? e < 0 && (e = 0) : e < i[r] && (e = i[r]),
      t ? Math.floor(e) : e
    );
  },
  Fq = (e, r, t) => {
    t === "maxPv" ||
    t === "maxPe" ||
    t === "maxSan" ||
    t === "currentPv" ||
    t === "currentPe" ||
    t === "currentSan"
      ? (e[t] = _t(r, 4))
      : t === "bonusDefense"
      ? (e[t] = _t(r, 3, !0, !1))
      : t === "movement"
      ? (e[t] = _t(r, 3, !1, !0))
      : (e[t] = _t(r, 3)),
      parseInt(e.peTurn) < 1 && (e.peTurn = "1");
  },
  IP = (e, r) => {
    let t = e.attributes.pre;
    t < 0 && (t = 0), r < 0 && (r = 0);
    const a = Math.abs(t - r);
    let n = 1;
    Vi.indexOf(e.nex) >= 1 && (n = Vi.indexOf(e.nex) + 1),
      t > r
        ? ((e.ritualsDc += a),
          (e.maxPe += a * n),
          (e.currentPe += a * n),
          (e.maxPd += a * n),
          (e.currentPd += a * n))
        : ((e.ritualsDc -= a),
          (e.maxPe -= a * n),
          (e.currentPe -= a * n),
          (e.maxPd -= a * n),
          (e.currentPd -= a * n)),
      e.ritualsDc < 0 && (e.ritualsDc = 0),
      e.maxPe < 0 && (e.maxPe = 0);
  },
  RP = (e, r) => {
    let t = e.attributes.str;
    if ((t < 0 && (t = 0), r < 0 && (r = 0), t !== r)) {
      if (t === 0) (e.maxLoad -= (r - 1) * 5), (e.maxLoad -= 3);
      else if (r === 0) {
        if (e.attributes.str < 0) return;
        (e.maxLoad += (t - 1) * 5), (e.maxLoad += 3);
      } else {
        const a = Math.abs(t - r);
        t > r ? (e.maxLoad += a * 5) : (e.maxLoad -= a * 5);
      }
      e.maxLoad < 0 && (e.maxLoad = 0);
    }
  },
  FP = (e, r) => {
    let t = e.attributes.con;
    t < 0 && (t = 0), r < 0 && (r = 0);
    const a = Math.abs(t - r);
    let n = 1;
    Vi.indexOf(e.nex) >= 1 && (n = Vi.indexOf(e.nex) + 1),
      t > r
        ? ((e.maxPv += a * n), (e.currentPv += a * n))
        : ((e.maxPv -= a * n), (e.currentPv -= a * n)),
      e.maxPv < 1 && (e.maxPv = 1);
  },
  Pq = (e, r, t) => {
    const a = { ...e.attributes };
    (e.attributes[t] = _t(r, 2, !0, !1)),
      t === "str" && RP(e, a.str),
      t === "con" && FP(e, a.con),
      t === "pre" && IP(e, a.pre);
  },
  qq = (e, r) => {
    isNaN(r) && (r = 0),
      r > 666 && (r = 666),
      r < 0 && (r = 0),
      r === 0 ? (e.movement = 0) : (e.movement = Math.floor(r) * 1.5);
  },
  zq = (e) => e.split("=")[0].split(":")[1],
  Uq = (e) => e.split("=")[0].split(":")[0],
  Lq = (e, r) => {
    let t;
    const a = e.attributes[r];
    return (
      a > 0 ? (t = `${a}d20kh1`) : (t = `${Math.abs(a) + 2}d20kl1`), new yt(t)
    );
  },
  kq = (e) => new yt(e.trim()),
  PP = (e) => {
    const r = `(${e.damage} - ${e.damageType})`,
      t = e.damageAttribute !== "None" ? ` + ${_P[e.damageAttribute]}` : "",
      a = [];
    if (e.aditionalDamage)
      for (const i of e.aditionalDamage)
        a.push(`(${i.value} - ${i.damageType})`);
    const n = a.join(" + ");
    return r + (n ? ` + ${n}` : "") + t;
  },
  qP = (e, r, t) =>
    `${e}d20kh1` + (r !== 0 ? `+${r}` : "") + (t !== 0 ? `+${t}` : ""),
  zP = (e, r, t) =>
    `${Math.abs(e) + 2}d20kl1` +
    (r !== 0 ? `+${r}` : "") +
    (t !== 0 ? `+${t}` : ""),
  Vq = (e, r) => {
    const t = e.skills.findIndex((b) => b.name === r.skillUsed),
      a = e.skills[t],
      n = e.attributes[kd[a.attribute]],
      i =
        `${a.name} (${a.attribute})` +
        (r.attackBonus !== 0 ? ` + ${r.attackBonus}` : ""),
      c = PP(r),
      m = `${r.criticalRange}/x${r.criticalMult}`;
    let f;
    n > 0
      ? (f = qP(n, a.bonus, r.attackBonus))
      : (f = zP(n, a.bonus, r.attackBonus));
    const u = new yt(f.trim()),
      s = u.total,
      o = u.output
        .substring(u.output.indexOf("[") + 1, u.output.indexOf("]"))
        .split(",");
    let l = 0;
    if (o.length > 1)
      o.map((b) => {
        b.includes("d") ||
          (parseInt(b) >= r.criticalRange && (l = 1),
          parseInt(b) === 1 && (l = -1),
          parseInt(b) === 1 && r.criticalRange === 1 && (l = 1));
      });
    else {
      const b = u.output.substring(
        u.output.indexOf("[") + 1,
        u.output.indexOf("]")
      );
      parseInt(b) >= r.criticalRange && (l = 1), parseInt(b) === 1 && (l = -1);
    }
    const p = r.damage !== "" ? `${r.damage}` : "0";
    let v = 0,
      h = "";
    if (l === 1)
      for (let b = 0; b < r.criticalMult; b++) {
        const N = new yt(p.trim());
        (v += N.total),
          (h +=
            N.output.substring(
              N.output.indexOf(":") + 1,
              N.output.indexOf("=") - 1
            ) + "+");
      }
    else {
      const b = new yt(p.trim());
      (v += b.total),
        (h +=
          b.output.substring(
            b.output.indexOf(":") + 1,
            b.output.indexOf("=") - 1
          ) + "+");
    }
    if (r.aditionalDamage && r.aditionalDamage.length > 0) {
      const b = [];
      for (const d of r.aditionalDamage) b.push(d.value);
      const N = new yt(b.join("+"));
      (v += N.total),
        N.output.includes("[")
          ? (h +=
              N.output.substring(
                N.output.indexOf(":") + 1,
                N.output.indexOf("=") - 1
              ) + "+")
          : (h += N.total + "+");
    }
    return (
      r.damageAttribute !== "None" &&
        ((v += e.attributes[Sp[r.damageAttribute]]),
        (h += e.attributes[Sp[r.damageAttribute]])),
      h.charAt(h.length - 1) === "+" && (h = h.slice(0, -1)),
      {
        attackTotal: s,
        damageTotal: v,
        critical: l,
        attackInfo: i,
        damageInfo: c,
        criticalInfo: m,
        attackRollInfo:
          u.output.substring(u.output.indexOf("["), u.output.indexOf("]") + 1) +
          (r.attackBonus !== 0 ? `+${r.attackBonus}` : ""),
        damageRollInfo: `${h.trim().replace(/\s/g, "")}`,
      }
    );
  },
  Gq = (e, r) => {
    let t;
    const a = e.attributes[kd[r.attribute]];
    return (
      a > 0
        ? (t = `${a}d20kh1` + (r.bonus !== 0 ? `+${r.bonus}` : ""))
        : (t =
            `${Math.abs(a) + 2}d20kl1` + (r.bonus !== 0 ? `+${r.bonus}` : "")),
      new yt(t.trim())
    );
  },
  Hq = (e, r) => {
    const t = e.skills.findIndex((n) => n.name === r),
      a = e.skills[t];
    a.bonus = parseInt(a.trainingDegree) + a.otherBonus;
  },
  Zq = (e, r, t) => {
    const a = e.skills.findIndex((n) => n.name === t);
    e.skills[a].otherBonus = _t(r, 2, !0, !1);
  },
  Jq = (e, r) => {
    const t = e.attacks.findIndex((a) => a.id === r);
    if (e.attacks[t].itemId) {
      const a = e.inventory.findIndex((n) => n.id === e.attacks[t].itemId);
      e.inventory[a].equipped = !1;
    }
    e.attacks.splice(t, 1);
  },
  UP = (e, r) => {
    if (e.inventory[r].itemType === "weapon") {
      const t = e.inventory[r],
        a = { ...BP };
      (a.id = Ga()),
        (a.itemId = t.id),
        (a.name = t.name),
        (a.damage = t.damage),
        (a.criticalRange = t.criticalRange),
        (a.criticalMult = t.criticalMult),
        (a.damageType = t.damageType),
        (a.range = t.range),
        (a.pictureURL = t.pictureURL || ""),
        (a.pictureFullPath = t.pictureFullPath || ""),
        t.type !== "Melee" &&
          ((a.skillUsed = "Marksmanship"), (a.damageAttribute = "None")),
        e.attacks.push(a);
    }
    if (e.inventory[r].itemType === "protection") {
      const t = e.inventory[r];
      (e.protectionDefense += t.defense),
        e.currentProtection === ""
          ? (e.currentProtection += t.name)
          : (e.currentProtection += ` ${t.name}`);
    }
  },
  Vd = (e, r) => {
    if (e.inventory[r].itemType === "weapon") {
      const t = e.inventory[r],
        a = e.attacks.findIndex((n) => n.itemId === t.id);
      e.attacks.splice(a, 1);
    }
    if (e.inventory[r].itemType === "protection") {
      const t = e.inventory[r];
      (e.protectionDefense -= t.defense),
        (e.currentProtection = e.currentProtection.replace(t.name, "")),
        (e.currentProtection = e.currentProtection.trim());
    }
  },
  Wq = (e, r) => {
    const t = e.inventory.findIndex((a) => a.id === r);
    e.inventory[t].itemType === "misc" ||
      e.inventory[t].itemType === "cursedItem" ||
      ((e.inventory[t].equipped = !e.inventory[t].equipped),
      e.inventory[t].equipped ? UP(e, t) : Vd(e, t));
  },
  Xq = (e, r, t) => {
    e[t] = _t(r, 3);
  },
  Yq = (e, r, t) => {
    e.itemsLimit[t] = _t(r, 2);
  },
  Qq = (e, r) => {
    const t = { ...r };
    if (((t.id = Ga()), e.powers.push(t), r.hasAutomation)) {
      const a = Ci.find((n) => n.id === r.automationId);
      if (!(a != null && a.onAdd)) return;
      a.onAdd(e);
    }
  },
  jq = (e, r) => {
    const t = e.powers.findIndex((n) => n.id === r),
      a = e.powers.find((n) => n.id === r);
    if (
      t !== -1 &&
      (e.powers.splice(t, 1), a != null && a.hasAutomation && a.isAutomationOn)
    ) {
      const n = Ci.find((i) => i.id === a.automationId);
      if (!(n != null && n.onRemove)) return;
      n.onRemove(e);
    }
  },
  Kq = (e, r) => {
    const t = { ...r };
    (t.id = Ga()), e.rituals.push(t);
  },
  e8 = (e, r) => {
    const t = { ...r };
    (t.id = Ga()), (t.equipped = !1);
    let a;
    if (
      (isNaN(t.slots) ? (a = 0) : (a = parseFloat(t.slots)),
      t.itemType === "weapon")
    ) {
      const n = t;
      n.ammunition &&
        ((a += parseFloat(n.ammunition.slots)),
        n.ammunition.category !== "-" &&
          n.ammunition.category !== "0" &&
          (e.currentItemsLimit[n.ammunition.category] += 1));
    }
    t.category !== "-" &&
      t.category !== "0" &&
      (e.currentItemsLimit[t.category] += 1),
      (e.currentLoad += a),
      e.inventory.push(t);
  },
  r8 = (e, r) => {
    const t = e.inventory.findIndex((i) => i.id === r),
      a = e.inventory[t];
    let n;
    if ((isNaN(a.slots) ? (n = 0) : (n = a.slots), a.itemType === "weapon")) {
      const i = a;
      i.ammunition &&
        ((n += i.ammunition.slots),
        i.ammunition.category !== "-" &&
          i.ammunition.category !== "0" &&
          ((e.currentItemsLimit[i.ammunition.category] -= 1),
          e.currentItemsLimit[i.ammunition.category] < 0 &&
            (e.currentItemsLimit[i.ammunition.category] = 0)));
    }
    a.category !== "-" &&
      a.category !== "0" &&
      ((e.currentItemsLimit[a.category] -= 1),
      e.currentItemsLimit[a.category] < 0 &&
        (e.currentItemsLimit[a.category] = 0)),
      (e.currentLoad -= n),
      e.inventory[t].equipped && Vd(e, t),
      e.inventory.splice(t, 1);
  },
  t8 = (e, r) => {
    e.ritualsDc = _t(r, 3);
  },
  n8 = (e, r) => {
    if (e.nex === r) return;
    const t = iy.find((o) => o.name === e.statsClass);
    if (!t) return;
    const a = Ep[e.nex],
      n = Ep[r],
      i = Math.abs(a - n),
      c = (t.levelPv + e.attributes.con) * i,
      m = (t.levelPe + e.attributes.pre) * i,
      f = (t.levelPd + e.attributes.pre) * i,
      u = t.levelSan * i,
      s = Math.abs(parseInt(Ap[e.nex]) - parseInt(Ap[r]));
    if (a > n) {
      (e.maxPv += c),
        (e.currentPv += c),
        (e.maxPe += m),
        (e.currentPe += m),
        (e.maxPd += f),
        (e.currentPd += f),
        (e.maxSan += u),
        (e.currentSan += u),
        (e.ritualsDc += i),
        (e.peTurn = (parseInt(e.peTurn) + s).toString());
      for (const o of e.powers)
        if (o.hasAutomation && o.isAutomationOn) {
          const l = Ci.find((p) => p.id === o.automationId);
          if (!(l != null && l.onNexUp)) return;
          for (let p = 0; p < i; p++) l.onNexUp(e);
        }
    } else {
      (e.maxPv -= c),
        (e.currentPv -= c),
        (e.maxPe -= m),
        (e.currentPe -= m),
        (e.maxPd -= f),
        (e.currentPd -= f),
        (e.maxSan -= u),
        (e.currentSan -= u),
        (e.ritualsDc -= i),
        (e.peTurn = (parseInt(e.peTurn) - s).toString());
      for (const o of e.powers)
        if (o.hasAutomation && o.isAutomationOn) {
          const l = Ci.find((p) => p.id === o.automationId);
          if (!(l != null && l.onNexDown)) return;
          for (let p = 0; p < i; p++) l.onNexDown(e);
        }
    }
    e.currentPv < 0 && (e.currentPv = 0),
      e.currentPe < 0 && (e.currentPe = 0),
      e.currentSan < 0 && (e.currentSan = 0),
      e.maxPv < 1 && (e.maxPv = 1),
      e.maxPe < 1 && (e.maxPe = 1),
      e.maxSan < 1 && (e.maxSan = 1),
      e.ritualsDc < 0 && (e.ritualsDc = 0),
      parseInt(e.peTurn) < 1 && (e.peTurn = "1");
  },
  a8 = (e, r) => {
    const t = e.inventory.findIndex((n) => n.id === r.id),
      a = { ...e.inventory[t] };
    if (JSON.stringify(a) !== JSON.stringify(r)) {
      if (((e.inventory[t] = r), a.slots !== r.slots)) {
        if (isNaN(parseInt(r.slots))) e.currentLoad -= a.slots;
        else {
          const n = Math.abs(a.slots - r.slots);
          r.slots > a.slots ? (e.currentLoad += n) : (e.currentLoad -= n);
        }
        e.currentLoad < 0 && (e.currentLoad = 0);
      }
      if (
        (a.category !== r.category &&
          (a.category !== "-" &&
            a.category !== "0" &&
            (e.currentItemsLimit[a.category] -= 1),
          r.category !== "-" &&
            r.category !== "0" &&
            (e.currentItemsLimit[r.category] += 1)),
        r.itemType === "protection" && r.equipped)
      ) {
        const n = a,
          i = r;
        if (n.defense !== i.defense) {
          const c = Math.abs(n.defense - i.defense);
          i.defense > n.defense
            ? (e.protectionDefense += c)
            : (e.protectionDefense -= c);
        }
        n.name !== i.name &&
          e.currentProtection.includes(n.name) &&
          (e.currentProtection = e.currentProtection.replace(n.name, i.name));
      }
      if (r.itemType === "weapon" && r.equipped) {
        const n = a,
          i = r,
          c = e.attacks.findIndex((m) => m.itemId === r.id);
        n.name !== i.name && (e.attacks[c].name = i.name),
          n.damage !== i.damage && (e.attacks[c].damage = i.damage),
          n.criticalRange !== i.criticalRange &&
            (e.attacks[c].criticalRange = i.criticalRange),
          n.criticalMult !== i.criticalMult &&
            (e.attacks[c].criticalMult = i.criticalMult),
          n.damageType !== i.damageType &&
            (e.attacks[c].damageType = i.damageType),
          n.range !== i.range && (e.attacks[c].range = i.range);
      }
    }
  },
  i8 = (e, r) => {
    (e.statsClass = r.name), (e.className = r.name);
    for (const t of r.abilities) (t.id = Ga()), e.powers.push(t);
    (e.maxPv = r.initialPv + e.attributes.con),
      (e.currentPv = e.maxPv),
      (e.maxPe = r.initialPe + e.attributes.pre),
      (e.currentPe = e.maxPe),
      (e.maxPd = r.initialPd + e.attributes.pre),
      (e.currentPd = e.maxPd),
      (e.maxSan = r.initialSan),
      (e.currentSan = e.maxSan),
      (e.proficiencies = r.proficiencies);
  },
  LP =
    "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20height='24px'%20viewBox='0%200%2024%2024'%20width='24px'%20fill='%23FFFFFF'%3e%3cpath%20d='M0%200h24v24H0V0z'%20fill='none'/%3e%3cpath%20d='M9%2016.2L4.8%2012l-1.4%201.4L9%2019%2021%207l-1.4-1.4L9%2016.2z'/%3e%3c/svg%3e",
  Gd = (e) => (Kt("data-v-555f9c83"), (e = e()), en(), e),
  kP = { class: "attr-container" },
  VP = { class: "image-container" },
  GP = Gd(() =>
    le("img", { class: "attr-image", src: Dp, alt: "atributos" }, null, -1)
  ),
  HP = ["value"],
  ZP = ["value"],
  JP = ["value"],
  WP = ["value"],
  XP = ["value"],
  YP = { class: "change-button-container" },
  QP = Gd(() => le("img", { src: LP, alt: "concluir" }, null, -1)),
  jP = [QP],
  KP = Nt({
    __name: "AttributesEdit",
    props: { character: {} },
    emits: ["handleChangeAttribute", "handleEdit"],
    setup(e, { emit: r }) {
      const t = r,
        a = Yg(),
        n = (i, c) => {
          var m;
          t("handleChangeAttribute", { e: i, key: c }),
            (m = a == null ? void 0 : a.proxy) == null || m.$forceUpdate();
        };
      return (i, c) => (
        Re(),
        Pe("div", kP, [
          le("div", VP, [
            GP,
            le(
              "input",
              {
                type: "number",
                class: "input str",
                value: i.character.attributes.str,
                onBlur: c[0] || (c[0] = (m) => n(m, "str")),
              },
              null,
              40,
              HP
            ),
            le(
              "input",
              {
                type: "number",
                class: "input dex",
                value: i.character.attributes.dex,
                onBlur: c[1] || (c[1] = (m) => n(m, "dex")),
              },
              null,
              40,
              ZP
            ),
            le(
              "input",
              {
                type: "number",
                class: "input int",
                value: i.character.attributes.int,
                onBlur: c[2] || (c[2] = (m) => n(m, "int")),
              },
              null,
              40,
              JP
            ),
            le(
              "input",
              {
                type: "number",
                class: "input con",
                value: i.character.attributes.con,
                onBlur: c[3] || (c[3] = (m) => n(m, "con")),
              },
              null,
              40,
              WP
            ),
            le(
              "input",
              {
                type: "number",
                class: "input pre",
                value: i.character.attributes.pre,
                onBlur: c[4] || (c[4] = (m) => n(m, "pre")),
              },
              null,
              40,
              XP
            ),
          ]),
          le("div", YP, [
            le(
              "button",
              {
                class: "change-button",
                onClick: c[5] || (c[5] = (m) => i.$emit("handleEdit")),
              },
              jP
            ),
          ]),
        ])
      );
    },
  }),
  e9 = Mt(KP, [["__scopeId", "data-v-555f9c83"]]),
  Hd = (e) => (Kt("data-v-807e2a9b"), (e = e()), en(), e),
  r9 = { class: "attr-container" },
  t9 = { class: "image-container" },
  n9 = Hd(() =>
    le("img", { class: "attr-image", src: Dp, alt: "atributos" }, null, -1)
  ),
  a9 = { key: 0, class: "change-button-container" },
  i9 = Hd(() => le("img", { src: ry, alt: "editar" }, null, -1)),
  o9 = [i9],
  s9 = Nt({
    __name: "AttributesRoll",
    props: {
      character: {},
      disabledSheet: { type: Boolean },
      combatSheet: { type: Boolean },
    },
    emits: ["handleRollAttribute", "handleEdit"],
    setup(e, { emit: r }) {
      const t = e,
        a = r,
        n = (i) => {
          t.disabledSheet || a("handleRollAttribute", i);
        };
      return (i, c) => (
        Re(),
        Pe("div", r9, [
          le("div", t9, [
            n9,
            le(
              "button",
              {
                class: pr(["attr str", { disabled: i.disabledSheet }]),
                onClick: c[0] || (c[0] = (m) => n("str")),
              },
              nr(i.character.attributes.str),
              3
            ),
            le(
              "button",
              {
                class: pr(["attr dex", { disabled: i.disabledSheet }]),
                onClick: c[1] || (c[1] = (m) => n("dex")),
              },
              nr(i.character.attributes.dex),
              3
            ),
            le(
              "button",
              {
                class: pr(["attr int", { disabled: i.disabledSheet }]),
                onClick: c[2] || (c[2] = (m) => n("int")),
              },
              nr(i.character.attributes.int),
              3
            ),
            le(
              "button",
              {
                class: pr(["attr con", { disabled: i.disabledSheet }]),
                onClick: c[3] || (c[3] = (m) => n("con")),
              },
              nr(i.character.attributes.con),
              3
            ),
            le(
              "button",
              {
                class: pr(["attr pre", { disabled: i.disabledSheet }]),
                onClick: c[4] || (c[4] = (m) => n("pre")),
              },
              nr(i.character.attributes.pre),
              3
            ),
          ]),
          !i.disabledSheet && !i.combatSheet
            ? (Re(),
              Pe("div", a9, [
                le(
                  "button",
                  {
                    class: "change-button",
                    onClick: c[5] || (c[5] = (m) => i.$emit("handleEdit")),
                  },
                  o9
                ),
              ]))
            : Fr("", !0),
        ])
      );
    },
  }),
  u9 = Mt(s9, [["__scopeId", "data-v-807e2a9b"]]),
  l9 = { key: 0, class: "att-container" },
  c9 = { key: 1, class: "att-container" },
  f9 = Nt({
    __name: "AttributesView",
    props: {
      character: {},
      disabledSheet: { type: Boolean },
      combatSheet: { type: Boolean },
    },
    emits: ["handleChangeAttribute", "handleRollAttribute"],
    setup(e, { emit: r }) {
      const t = r,
        a = (i) => {
          t("handleRollAttribute", i);
        },
        n = It(!1);
      return (i, c) =>
        n.value
          ? (Re(),
            Pe("div", l9, [
              Ra(
                e9,
                {
                  character: i.character,
                  onHandleEdit: c[0] || (c[0] = (m) => (n.value = !1)),
                  onHandleChangeAttribute:
                    c[1] || (c[1] = (m) => i.$emit("handleChangeAttribute", m)),
                },
                null,
                8,
                ["character"]
              ),
            ]))
          : (Re(),
            Pe("div", c9, [
              Ra(
                u9,
                {
                  character: i.character,
                  "disabled-sheet": i.disabledSheet,
                  "combat-sheet": i.combatSheet,
                  onHandleEdit: c[2] || (c[2] = (m) => (n.value = !0)),
                  onHandleRollAttribute: a,
                },
                null,
                8,
                ["character", "disabled-sheet", "combat-sheet"]
              ),
            ]));
    },
  }),
  o8 = Mt(f9, [["__scopeId", "data-v-e6595177"]]),
  m9 = ["placeholder", "value"],
  p9 = Nt({
    __name: "FilterInput",
    props: {
      value: { type: String, required: !0 },
      placeholder: { type: String, default: "" },
      width: { type: String, default: "23.5rem" },
    },
    emits: ["update"],
    setup(e, { emit: r }) {
      On((c) => ({ "3e2347da": n.value }));
      const t = e,
        a = r,
        n = It(t.width),
        i = (c) => {
          a("update", c.target.value);
        };
      return (c, m) => (
        Re(),
        Pe(
          "input",
          {
            class: "sheet-input filter-input",
            type: "text",
            placeholder: e.placeholder,
            value: e.value,
            onInput: i,
          },
          null,
          40,
          m9
        )
      );
    },
  }),
  s8 = Mt(p9, [["__scopeId", "data-v-a24ea236"]]),
  Zd = (e) => (Kt("data-v-0f772e72"), (e = e()), en(), e),
  v9 = { class: "card" },
  h9 = Zd(() => le("img", { src: oy, alt: "ver mais" }, null, -1)),
  d9 = [h9],
  g9 = { class: "first-row" },
  y9 = { class: "title" },
  b9 = { class: "item-info-container" },
  x9 = { class: "item-info" },
  w9 = { class: "item-info" },
  N9 = { key: 0 },
  M9 = { key: 1 },
  A9 = { key: 2 },
  S9 = { class: "button-container" },
  E9 = ["disabled", "onClick"],
  C9 = Zd(() => le("img", { src: Va, alt: "rolar" }, null, -1)),
  $9 = [C9],
  O9 = { key: 0 },
  T9 = { class: "content" },
  D9 = { class: "only-sheet-content-container" },
  B9 = { class: "card-info-image-container" },
  _9 = { class: "item-info" },
  I9 = { class: "item-info" },
  R9 = { key: 0, class: "item-info" },
  F9 = { key: 0 },
  P9 = { class: "item-info" },
  q9 = { class: "item-info" },
  z9 = { class: "item-info" },
  U9 = ["src"],
  L9 = ["innerHTML"],
  k9 = { key: 0, class: "card-footer" },
  V9 = ["onClick"],
  G9 = { key: 0 },
  H9 = ["src"],
  Z9 = Nt({
    __name: "AttackCard",
    props: {
      attack: { type: Object, required: !0 },
      id: { type: String, default: "" },
      disabled: Boolean,
      disabledEdit: Boolean,
    },
    emits: ["handleRemoveAttack", "handleRollAttack", "handleEdit"],
    setup(e, { emit: r }) {
      const t = e,
        a = r,
        n = It(!1),
        i = It(!1),
        c = () => {
          t.disabled || a("handleRollAttack", t.attack);
        },
        m = () => {
          t.disabled || a("handleEdit", t.attack);
        };
      return (f, u) => {
        const s = Qg("vue-final-modal");
        return (
          Re(),
          Pe(
            Ei,
            null,
            [
              le("div", v9, [
                le(
                  "div",
                  {
                    class: "header",
                    onClick: u[1] || (u[1] = (o) => (n.value = !n.value)),
                  },
                  [
                    le(
                      "button",
                      {
                        class: pr(["show-more", { rotate: n.value }]),
                        onClick:
                          u[0] ||
                          (u[0] = vi((o) => (n.value = !n.value), ["stop"])),
                      },
                      d9,
                      2
                    ),
                    le("div", null, [
                      le("div", g9, [le("h3", y9, nr(e.attack.name), 1)]),
                      le("div", b9, [
                        le("div", x9, [
                          le("h3", null, [
                            Rr(" Damage: "),
                            le("span", null, nr(e.attack.damage), 1),
                          ]),
                        ]),
                        le("div", w9, [
                          le("h3", null, [
                            Rr(" Critical: "),
                            e.attack.criticalRange < 20 &&
                            e.attack.criticalMult > 2
                              ? (Re(),
                                Pe(
                                  "span",
                                  N9,
                                  nr(e.attack.criticalRange) +
                                    "/x" +
                                    nr(e.attack.criticalMult),
                                  1
                                ))
                              : e.attack.criticalRange < 20
                              ? (Re(),
                                Pe("span", M9, nr(e.attack.criticalRange), 1))
                              : (Re(),
                                Pe(
                                  "span",
                                  A9,
                                  "x" + nr(e.attack.criticalMult),
                                  1
                                )),
                          ]),
                        ]),
                      ]),
                    ]),
                    le("div", S9, [
                      le(
                        "button",
                        {
                          class: pr(["roll-button", { disabled: e.disabled }]),
                          disabled: e.disabled,
                          onClick: vi(c, ["stop"]),
                        },
                        $9,
                        10,
                        E9
                      ),
                    ]),
                  ]
                ),
                Ra(
                  jg,
                  { name: "card", mode: "out-in" },
                  {
                    default: qu(() => [
                      n.value
                        ? (Re(),
                          Pe("div", O9, [
                            Ra(Kg),
                            le("div", T9, [
                              le("div", D9, [
                                le("div", B9, [
                                  le("div", null, [
                                    le("div", _9, [
                                      le("h3", null, [
                                        Rr("Attack Bonus: "),
                                        le(
                                          "span",
                                          null,
                                          nr(e.attack.attackBonus),
                                          1
                                        ),
                                      ]),
                                    ]),
                                    le("div", I9, [
                                      le("h3", null, [
                                        Rr("Damage Type: "),
                                        le(
                                          "span",
                                          null,
                                          nr(e.attack.damageType),
                                          1
                                        ),
                                      ]),
                                    ]),
                                    e.attack.aditionalDamage
                                      ? (Re(),
                                        Pe("div", R9, [
                                          le("h3", null, [
                                            Rr(" Extra Damage: "),
                                            (Re(!0),
                                            Pe(
                                              Ei,
                                              null,
                                              Rs(
                                                e.attack.aditionalDamage,
                                                (o, l) => (
                                                  Re(),
                                                  Pe("span", { key: o.id }, [
                                                    Rr(
                                                      nr(o.value) +
                                                        " " +
                                                        nr(o.damageType),
                                                      1
                                                    ),
                                                    l !==
                                                    e.attack.aditionalDamage
                                                      .length -
                                                      1
                                                      ? (Re(),
                                                        Pe("span", F9, ", "))
                                                      : Fr("", !0),
                                                  ])
                                                )
                                              ),
                                              128
                                            )),
                                          ]),
                                        ]))
                                      : Fr("", !0),
                                    le("div", P9, [
                                      le("h3", null, [
                                        Rr("Range: "),
                                        le("span", null, nr(e.attack.range), 1),
                                      ]),
                                    ]),
                                    le("div", q9, [
                                      le("h3", null, [
                                        Rr("Skill: "),
                                        le(
                                          "span",
                                          null,
                                          nr(e.attack.skillUsed),
                                          1
                                        ),
                                      ]),
                                    ]),
                                    le("div", z9, [
                                      le("h3", null, [
                                        Rr("Damage Attribute: "),
                                        le(
                                          "span",
                                          null,
                                          nr(e.attack.damageAttribute),
                                          1
                                        ),
                                      ]),
                                    ]),
                                  ]),
                                  e.attack.pictureURL
                                    ? (Re(),
                                      Pe(
                                        "div",
                                        {
                                          key: 0,
                                          onClick:
                                            u[2] ||
                                            (u[2] = (o) => (i.value = !0)),
                                        },
                                        [
                                          le(
                                            "img",
                                            {
                                              class: "card-image",
                                              src: e.attack.pictureURL,
                                            },
                                            null,
                                            8,
                                            U9
                                          ),
                                        ]
                                      ))
                                    : Fr("", !0),
                                ]),
                              ]),
                              le(
                                "div",
                                {
                                  class: "sheet-content",
                                  innerHTML: e.attack.description,
                                },
                                null,
                                8,
                                L9
                              ),
                              !e.disabled && !e.disabledEdit
                                ? (Re(),
                                  Pe("div", k9, [
                                    le(
                                      "button",
                                      {
                                        class: "button-remove",
                                        onClick:
                                          u[3] ||
                                          (u[3] = vi(
                                            (o) =>
                                              f.$emit(
                                                "handleRemoveAttack",
                                                e.id
                                              ),
                                            ["stop"]
                                          )),
                                      },
                                      " Remove "
                                    ),
                                    le(
                                      "button",
                                      {
                                        class: "button-remove button-edit",
                                        onClick: vi(m, ["stop"]),
                                      },
                                      " Edit ",
                                      8,
                                      V9
                                    ),
                                  ]))
                                : Fr("", !0),
                            ]),
                          ]))
                        : Fr("", !0),
                    ]),
                    _: 1,
                  }
                ),
              ]),
              i.value
                ? (Re(),
                  Pe("div", G9, [
                    Ra(
                      s,
                      {
                        modelValue: i.value,
                        "onUpdate:modelValue":
                          u[4] || (u[4] = (o) => (i.value = o)),
                        classes: "modal-container",
                      },
                      {
                        default: qu(() => [
                          le(
                            "img",
                            {
                              class: "card-image-full",
                              src: e.attack.pictureURL,
                            },
                            null,
                            8,
                            H9
                          ),
                        ]),
                        _: 1,
                      },
                      8,
                      ["modelValue"]
                    ),
                  ]))
                : Fr("", !0),
            ],
            64
          )
        );
      };
    },
  }),
  u8 = Mt(Z9, [["__scopeId", "data-v-0f772e72"]]);
function l8(
  e,
  {
    volume: r = 1,
    playbackRate: t = 1,
    soundEnabled: a = !0,
    interrupt: n = !1,
    autoplay: i = !1,
    onload: c,
    ...m
  } = {}
) {
  const f = It(null),
    u = It(!1),
    s = It(null),
    o = It(null);
  function l() {
    var b;
    typeof c == "function" && c.call(this),
      (s.value =
        (s.value || ((b = o.value) == null ? void 0 : b.duration()) || 0) *
        1e3),
      i === !0 && (u.value = !0);
  }
  return (
    Is(async () => {
      const b = await ey(
        () => import("./howler-Lam4OMv2.js").then((N) => N.h),
        __vite__mapDeps([0, 1])
      );
      (f.value = b.default.Howl),
        (o.value = new f.value({
          src: Tt(e),
          volume: Tt(r),
          rate: Tt(t),
          onload: l,
          ...m,
        }));
    }),
    Si(
      () => [e],
      () => {
        f.value &&
          f.value &&
          o &&
          o.value &&
          (o.value = new f.value({
            src: Tt(e),
            volume: Tt(r),
            rate: Tt(t),
            onload: l,
            ...m,
          }));
      }
    ),
    Si(
      () => [Tt(r), Tt(t)],
      () => {
        o.value && (o.value.volume(Tt(r)), o.value.rate(Tt(t)));
      }
    ),
    {
      play: (b) => {
        typeof b > "u" && (b = {}),
          !(!o.value || (!a && !b.forceSoundEnabled)) &&
            (n && o.value.stop(),
            b.playbackRate && o.value.rate(b.playbackRate),
            o.value.play(b.id),
            o.value.once("end", () => {
              o.value && o.value && !o.value.playing() && (u.value = !1);
            }),
            (u.value = !0));
      },
      sound: o,
      isPlaying: u,
      duration: s,
      pause: (b) => {
        o.value &&
          (o.value.pause(typeof b == "number" ? b : void 0), (u.value = !1));
      },
      stop: (b) => {
        o.value &&
          (o.value.stop(typeof b == "number" ? b : void 0), (u.value = !1));
      },
    }
  );
}
const c8 = "/assets/dice-roll-8rICIfwE.mp3",
  Jd = (e) => (Kt("data-v-e2b14727"), (e = e()), en(), e),
  J9 = { class: "toast-content" },
  W9 = ["src"],
  X9 = { key: 1, class: "toast-icon", src: Va, alt: "d20" },
  Y9 = { class: "text" },
  Q9 = { class: "title" },
  j9 = { class: "result" },
  K9 = { class: "result-container" },
  eq = { key: 0 },
  rq = Jd(() => le("span", null, "=", -1)),
  tq = { class: "total-container" },
  nq = Jd(() => le("img", { src: Hi, alt: "fechar" }, null, -1)),
  aq = [nq],
  Cp = "#5cb85c",
  $p = "#d9534f",
  iq = "#fff",
  oq = Nt({
    __name: "ToastDice",
    props: { toast: {} },
    emits: ["dismiss"],
    setup(e) {
      On((n) => ({ "740de92c": a.value, "6015218e": t.value }));
      const r = e,
        t = tt(() => {
          let n = iq;
          if (r.toast.defaultColor || r.toast.title === "Result") return n;
          const i = r.toast.output
            .substring(
              r.toast.output.indexOf("[") + 1,
              r.toast.output.indexOf("]")
            )
            .split(",");
          if (i.length > 1)
            i.map((c) => {
              c.includes("d") ||
                (parseInt(c) === 20 && (n = Cp), parseInt(c) === 1 && (n = $p));
            });
          else {
            const c = r.toast.output.substring(
              r.toast.output.indexOf("[") + 1,
              r.toast.output.indexOf("]")
            );
            parseInt(c) === 20 && (n = Cp), parseInt(c) === 1 && (n = $p);
          }
          return n;
        }),
        a = tt(() =>
          r.toast.skinDice ? r.toast.skinDice.color : "var(--color-primary)"
        );
      return (n, i) => {
        const c = Gi("tooltip");
        return (
          Re(),
          Pe(
            "div",
            {
              class: "toast-wrapper",
              onClick: i[1] || (i[1] = (m) => n.$emit("dismiss")),
            },
            [
              le(
                "div",
                {
                  class: pr([
                    "toast",
                    {
                      "toast-border":
                        n.toast.skinDice && n.toast.skinDice.isSolid,
                      "toast-img-border":
                        n.toast.skinDice && !n.toast.skinDice.isSolid,
                    },
                  ]),
                },
                [
                  le("div", J9, [
                    n.toast.skinDice
                      ? (Re(),
                        Pe(
                          "img",
                          {
                            key: 0,
                            class: "toast-icon",
                            src: n.toast.skinDice.img,
                            alt: "d20",
                          },
                          null,
                          8,
                          W9
                        ))
                      : (Re(), Pe("img", X9)),
                    le("div", Y9, [
                      le("h3", Q9, nr(n.toast.title), 1),
                      le("div", j9, [
                        le("div", K9, [
                          vn(
                            (Re(), Pe("h4", null, [Rr(nr(n.toast.output), 1)])),
                            [
                              [
                                c,
                                {
                                  content: n.toast.output,
                                  triggers: ["hover", "click"],
                                },
                              ],
                            ]
                          ),
                          n.toast.title === "Result"
                            ? vn(
                                (Re(),
                                Pe("h4", eq, [Rr(nr(n.toast.notation), 1)])),
                                [
                                  [
                                    c,
                                    {
                                      content: n.toast.notation,
                                      triggers: ["hover", "click"],
                                    },
                                  ],
                                ]
                              )
                            : Fr("", !0),
                        ]),
                        rq,
                        le("div", tq, [le("h3", null, nr(n.toast.total), 1)]),
                      ]),
                    ]),
                    le(
                      "button",
                      {
                        class: "close-icon",
                        onClick: i[0] || (i[0] = (m) => n.$emit("dismiss")),
                      },
                      aq
                    ),
                  ]),
                ],
                2
              ),
            ]
          )
        );
      };
    },
  }),
  f8 = Mt(oq, [["__scopeId", "data-v-e2b14727"]]),
  xo = (e) => (Kt("data-v-c6906cd2"), (e = e()), en(), e),
  sq = { class: "toast-content" },
  uq = ["src"],
  lq = { key: 1, class: "toast-icon", src: Va, alt: "d20" },
  cq = { class: "text" },
  fq = { class: "title" },
  mq = { class: "result" },
  pq = { class: "attack-container" },
  vq = xo(() => le("h4", null, "TO HIT", -1)),
  hq = xo(() => le("div", { class: "divider" }, null, -1)),
  dq = { class: "damage-container" },
  gq = xo(() => le("h4", { class: "padding-left" }, " DAMAGE ", -1)),
  yq = xo(() => le("img", { src: Hi, alt: "fechar" }, null, -1)),
  bq = [yq],
  xq = "#5cb85c",
  wq = "#d9534f",
  Nq = "#fff",
  Mq = Nt({
    __name: "ToastAttack",
    props: { toast: {} },
    emits: ["dismiss"],
    setup(e) {
      On((i) => ({ "0af4102b": n.value, "27e358c0": a.value }));
      const r = e,
        t = It(window.innerWidth),
        a = tt(() =>
          r.toast.critical === 1 ? xq : r.toast.critical === -1 ? wq : Nq
        );
      Is(() => {
        window.addEventListener("resize", () => {
          t.value = window.innerWidth;
        });
      });
      const n = tt(() =>
        r.toast.skinDice ? r.toast.skinDice.color : "var(--color-primary)"
      );
      return (i, c) => {
        const m = Gi("tooltip");
        return (
          Re(),
          Pe(
            "div",
            {
              class: "toast-wrapper",
              onClick:
                c[1] ||
                (c[1] = (f) => (t.value >= 1023 ? i.$emit("dismiss") : void 0)),
            },
            [
              le(
                "div",
                {
                  class: pr([
                    "toast",
                    {
                      "toast-border":
                        i.toast.skinDice && i.toast.skinDice.isSolid,
                      "toast-img-border":
                        i.toast.skinDice && !i.toast.skinDice.isSolid,
                    },
                  ]),
                },
                [
                  le("div", sq, [
                    i.toast.skinDice
                      ? (Re(),
                        Pe(
                          "img",
                          {
                            key: 0,
                            class: "toast-icon",
                            src: i.toast.skinDice.img,
                            alt: "d20",
                          },
                          null,
                          8,
                          uq
                        ))
                      : (Re(), Pe("img", lq)),
                    le("div", cq, [
                      le("h3", fq, nr(i.toast.title), 1),
                      le("div", mq, [
                        le("div", pq, [
                          vn(
                            (Re(),
                            Pe("h3", null, [Rr(nr(i.toast.totalAttack), 1)])),
                            [
                              [
                                m,
                                {
                                  content: `${i.toast.attackTooltip} = ${i.toast.attackRollTooltip}`,
                                  triggers: ["hover", "click"],
                                },
                              ],
                            ]
                          ),
                          vq,
                        ]),
                        hq,
                        le("div", dq, [
                          vn(
                            (Re(),
                            Pe("h3", null, [Rr(nr(i.toast.totalDamage), 1)])),
                            [
                              [
                                m,
                                {
                                  content: `${i.toast.damageTooltip} | ${i.toast.criticalTooltip} = ${i.toast.damageRollTooltip}`,
                                  triggers: ["hover", "click"],
                                },
                              ],
                            ]
                          ),
                          gq,
                        ]),
                      ]),
                    ]),
                    le(
                      "button",
                      {
                        class: "close-icon",
                        onClick: c[0] || (c[0] = (f) => i.$emit("dismiss")),
                      },
                      bq
                    ),
                  ]),
                ],
                2
              ),
            ]
          )
        );
      };
    },
  }),
  m8 = Mt(Mq, [["__scopeId", "data-v-c6906cd2"]]);
export {
  o8 as A,
  Yq as B,
  Bq as C,
  yt as D,
  t8 as E,
  s8 as F,
  Qq as G,
  Kq as H,
  _q as I,
  e8 as J,
  a8 as K,
  i8 as L,
  f8 as T,
  u8 as a,
  m8 as b,
  Fq as c,
  c8 as d,
  kq as e,
  zq as f,
  Uq as g,
  Vi as h,
  Iq as i,
  Pq as j,
  n8 as k,
  qq as l,
  Rq as m,
  Ep as n,
  Lq as o,
  Ap as p,
  Hq as q,
  Vq as r,
  Zq as s,
  Gq as t,
  l8 as u,
  Jq as v,
  jq as w,
  r8 as x,
  Wq as y,
  Xq as z,
};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = [
      "assets/howler-Lam4OMv2.js",
      "assets/_commonjsHelpers-4gQjN7DL.js",
    ];
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i]);
}
